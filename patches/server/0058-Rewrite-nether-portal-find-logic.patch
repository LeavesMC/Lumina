From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7@outlook.com>
Date: Sun, 18 Aug 2024 21:44:23 +0800
Subject: [PATCH] Rewrite nether portal find logic


diff --git a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
index d72041aa814ff179e6e29a45dcd359a91d426d47..aaf2afe2f101e4b292be079a0ae64dce284ba431 100644
--- a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
+++ b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
@@ -201,6 +201,7 @@ public final class PoiChunk {
                 // completely empty, no point in storing this
                 continue;
             }
+            for (net.minecraft.core.BlockPos pos : deserialized.loadedNetherPortalPoi) world.netherPortalPoiManager.addPoi(pos); // Lumina - rewrite nether portal find logic
 
             readAnything = true;
             ret.sections[sectionY - ret.minSection] = deserialized;
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index a33389dbc9c80d0ff0c962218ea9f05f27de62bb..6ff4d767c6bf4e0f9908069834dc97f4351d6236 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -203,6 +203,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final SleepStatus sleepStatus;
     private int emptyTime;
     private final PortalForcer portalForcer;
+    public final org.leavesmc.lumina.utils.LevelNetherPortalPoiManager netherPortalPoiManager; // Lumina - rewrite nether portal find logic
     //private final LevelTicks<Block> blockTicks; // Folia - region threading
     //private final LevelTicks<Fluid> fluidTicks; // Folia - region threading
     //private final PathTypeCache pathTypesByPosCache; // Folia - region threading
@@ -827,6 +828,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         });
         this.chunkSource.getGeneratorState().ensureStructuresGenerated();
         this.portalForcer = new PortalForcer(this);
+        this.netherPortalPoiManager = new org.leavesmc.lumina.utils.LevelNetherPortalPoiManager(this.getTypeKey() == LevelStem.NETHER); // Lumina - rewrite nether portal find logic
         //this.updateSkyBrightness(); // Folia - region threading - delay until first tick
         this.prepareWeather();
         this.getWorldBorder().setAbsoluteMaxSize(minecraftserver.getAbsoluteMaxWorldSize());
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
index 4ee7d75c56d9f9ff3607276857dde84410ba3f2a..3f2f4ae25de3ecf559bd3650290fe27d60d1d6b8 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
@@ -30,6 +30,8 @@ public class PoiSection {
     private final Runnable setDirty;
     private boolean isValid;
     public final Optional<PoiSection> noAllocateOptional = Optional.of(this); // Paper - rewrite chunk system
+    private boolean loading = false; // Lumina - rewrite nether portal find logic
+    public final Set<BlockPos> loadedNetherPortalPoi = new java.util.HashSet<>();
 
     public static Codec<PoiSection> codec(Runnable updateListener) {
         return RecordCodecBuilder.<PoiSection>create(
@@ -56,7 +58,9 @@ public class PoiSection {
     private PoiSection(Runnable updateListener, boolean valid, List<PoiRecord> pois) {
         this.setDirty = updateListener;
         this.isValid = valid;
+        this.loading = true; // Lumina - rewrite nether portal find logic
         pois.forEach(this::add);
+        this.loading = false; // Lumina - rewrite nether portal find logic
     }
 
     public Stream<PoiRecord> getRecords(Predicate<Holder<PoiType>> predicate, PoiManager.Occupancy occupationStatus) {
@@ -87,6 +91,7 @@ public class PoiSection {
 
             Util.logAndPauseIfInIde("POI data mismatch: already registered at " + blockPos);
         }
+        if (holder.is(PoiTypes.NETHER_PORTAL) && loading) loadedNetherPortalPoi.add(blockPos); // Lumina - rewrite nether portal find logic
 
         this.records.put(s, poi);
         this.byType.computeIfAbsent(holder, type -> Sets.newHashSet()).add(poi);
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 7fb23c02dc91ed3af27eb4420ce920ab22bdb359..554a3286a1c3a55f3713507d20487b43826b731f 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1021,6 +1021,15 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public boolean setBlock(BlockPos pos, BlockState state, int flags, int maxUpdateDepth) {
         io.papermc.paper.util.TickThread.ensureTickThread((ServerLevel)this, pos, "Updating block asynchronously"); // Folia - region threading
         io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.getCurrentWorldData(); // Folia - region threading
+        // Lumina start - rewrite nether portal find logic
+        BlockState oldState = getBlockState(pos);
+        if (oldState.is(net.minecraft.world.level.block.Blocks.NETHER_PORTAL)) {
+            ((ServerLevel)this).netherPortalPoiManager.addPoi(pos);
+        }
+        if (state.is(net.minecraft.world.level.block.Blocks.NETHER_PORTAL)) {
+            ((ServerLevel)this).netherPortalPoiManager.removePoi(pos);
+        }
+        // Lumina end - rewrite nether portal find logic
         // CraftBukkit start - tree generation
         if (worldData.captureTreeGeneration) { // Folia - region threading
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
diff --git a/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java b/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..32dced0e22d54628226faf8b33ed7fbba4d14d4e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java
@@ -0,0 +1,183 @@
+package org.leavesmc.lumina.utils;
+
+import net.minecraft.core.Vec3i;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public class LevelNetherPortalPoiManager {
+    private final int maxBuildSubChunkY;
+    private final int minBuildSubChunkY;
+    private final int maxFindSubChunkDistance;
+    private final int maxFindDistance;
+    private final boolean isNether;
+    private final ConcurrentMap<Vec3i, Set<Vec3i>> poiData = new ConcurrentHashMap<>();
+
+    public LevelNetherPortalPoiManager(boolean isNether) {
+        this.isNether = isNether;
+        this.maxFindSubChunkDistance = isNether ? 1 : 8;
+        this.maxFindDistance = isNether ? 16 : 128;
+        int minBuildHeight = isNether ? 0 : -64;
+        int maxBuildHeight = isNether ? 256 : 320;
+        this.minBuildSubChunkY = minBuildHeight >> 4;
+        this.maxBuildSubChunkY = maxBuildHeight >> 4;
+    }
+
+    public void addPoi(Vec3i pos) {
+        System.out.println("add nether portal poi at " + (isNether ? "nether" : "overworld") +": " + pos);
+        poiData.computeIfAbsent(
+                calcSubChunkPos(pos),
+                (k) -> ConcurrentHashMap.newKeySet()
+        ).add(pos);
+    }
+
+    public void removePoi(Vec3i pos) {
+        Set<Vec3i> set = poiData.get(calcSubChunkPos(pos));
+        if (set != null) {
+            set.remove(pos);
+        }
+    }
+
+    public Set<Vec3i> getSubChunkData(Vec3i subChunkPos) {
+        return poiData.getOrDefault(subChunkPos, Set.of());
+    }
+
+    public Vec3i findClosestPoi(Vec3i center) {
+        Vec3i centerSubChunk = calcSubChunkPos(center);
+        Set<Vec3i> now = new HashSet<>();
+        Set<Vec3i> all = new HashSet<>();
+        int n = 0;
+        now.add(centerSubChunk);
+        boolean shouldContinue = true;
+        Vec3i result = null;
+        double nowDistanceSqr = Double.MAX_VALUE;
+        while (shouldContinue) {
+            n++;
+            shouldContinue = false;
+            Set<Vec3i> next = new HashSet<>();
+            for (Vec3i subChunkPos : now) {
+                all.add(subChunkPos);
+                Set<Vec3i> subChunkData = getSubChunkData(subChunkPos);
+                if (subChunkData != null) {
+                    for (Vec3i poi : subChunkData) {
+                        if (poi.getX() - center.getX() > maxFindDistance
+                                || poi.getZ() - center.getZ() > maxFindDistance) {
+                            continue;
+                        }
+                        double distSqr = center.distSqr(poi);
+                        if (distSqr < nowDistanceSqr) {
+                            result = poi;
+                            nowDistanceSqr = distSqr;
+                        } else if (distSqr == nowDistanceSqr) {
+                            assert result != null; // if result is null, distance = Double.MAX_VALUE != nowDistance
+                            if (poi.getY() < result.getY()) {
+                                result = poi;
+                            }
+                        }
+                    }
+                }
+                shouldContinue = addNeighborsToNext(subChunkPos, next, all, centerSubChunk) || shouldContinue;
+            }
+            now = next;
+            if (getMaxDistanceSqr(n) >= nowDistanceSqr) {
+                shouldContinue = false;
+            }
+        }
+        return result;
+    }
+
+    private boolean addNeighborsToNext(@NotNull Vec3i subChunkPos, Set<Vec3i> next, Set<Vec3i> all, Vec3i center) {
+        boolean shouldContinue = addToNext(subChunkPos.above(), next, all, center);
+        shouldContinue = addToNext(subChunkPos.below(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.north(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.south(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.east(), next, all, center) || shouldContinue;
+        return addToNext(subChunkPos.west(), next, all, center) || shouldContinue;
+    }
+
+    @Contract("_ -> new")
+    private @NotNull Vec3i calcSubChunkPos(@NotNull Vec3i pos) {
+        return new Vec3i(pos.getX() >> 4, pos.getY() >> 4, pos.getZ() >> 4);
+    }
+
+    private boolean addToNext(Vec3i subChunkPos, Set<Vec3i> next, @NotNull Set<Vec3i> all, Vec3i center) {
+        if (!all.contains(subChunkPos)
+                && Math.abs(center.getX() - subChunkPos.getX()) <= maxFindSubChunkDistance
+                && Math.abs(center.getZ() - subChunkPos.getZ()) <= maxFindSubChunkDistance
+                && subChunkPos.getY() <= maxBuildSubChunkY
+                && subChunkPos.getY() >= minBuildSubChunkY) {
+            next.add(subChunkPos);
+            return true;
+        }
+        return false;
+    }
+
+    private int getMaxDistanceSqr(int n) {
+        return isNether ? netherMaxDistanceSqr.get(n-1) : overworldMaxDistanceSqr.get(n-1);
+    }
+
+    private final List<Integer> overworldMaxDistanceSqr = List.of(
+            0,
+            1,
+            2,
+            290,
+            578,
+            866,
+            1666,
+            2466,
+            3266,
+            4578,
+            5890,
+            7202,
+            9026,
+            10850,
+            12674,
+            15010,
+            17346,
+            19682,
+            22530,
+            25378,
+            28226,
+            31586,
+            34946,
+            38306,
+            42178,
+            46050,
+            49922,
+            54306,
+            58690,
+            63074,
+            67970,
+            72866,
+            77762,
+            83170,
+            88578,
+            93986,
+            99906,
+            105826,
+            111746,
+            118178
+    );
+    private final List<Integer> netherMaxDistanceSqr = List.of(
+            0,
+            1,
+            2,
+            290,
+            1090,
+            2402,
+            4226,
+            6562,
+            9410,
+            12770,
+            16642,
+            21026,
+            25922,
+            31330,
+            37250,
+            43682,
+            50626
+    );
+}
