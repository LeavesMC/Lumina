From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7@outlook.com>
Date: Sun, 18 Aug 2024 21:44:23 +0800
Subject: [PATCH] Rewrite nether portal find logic


diff --git a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
index d72041aa814ff179e6e29a45dcd359a91d426d47..730cd3b9355a1d26012ad22f83e1c9b47a5ab0aa 100644
--- a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
+++ b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
@@ -201,6 +201,7 @@ public final class PoiChunk {
                 // completely empty, no point in storing this
                 continue;
             }
+            world.chunkTaskScheduler.scheduleChunkTask(chunkX, chunkZ, () -> { for (net.minecraft.core.BlockPos pos : deserialized.loadedNetherPortalPoi) world.netherPortalPoiManager.addPoi(pos, world.getBlockState(pos)); }, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGHEST); // Lumina - rewrite nether portal find logic
 
             readAnything = true;
             ret.sections[sectionY - ret.minSection] = deserialized;
diff --git a/src/main/java/net/minecraft/BlockUtil.java b/src/main/java/net/minecraft/BlockUtil.java
index 840611677feb4979eb2d492063ae4388ea350506..ab2a2cf0df10cee8045fbb86abce9eafad176f2c 100644
--- a/src/main/java/net/minecraft/BlockUtil.java
+++ b/src/main/java/net/minecraft/BlockUtil.java
@@ -143,6 +143,25 @@ public class BlockUtil {
             this.axis1Size = width;
             this.axis2Size = height;
         }
+
+        // Lumina start - rewrite nether portal find logic
+        @Override
+        public int hashCode() {
+            return java.util.Objects.hash(minCorner, axis1Size, axis2Size);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            } else if (obj instanceof FoundRectangle other) {
+                return minCorner.equals(other.minCorner) &&
+                        axis1Size == other.axis1Size &&
+                        axis2Size == other.axis2Size;
+            }
+            return false;
+        }
+        // Lumina end - rewrite nether portal find logic
     }
 
     public static class IntBounds {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index a33389dbc9c80d0ff0c962218ea9f05f27de62bb..5ebdcca24e8bee4e154fd5fbb10638d0b83ba405 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -203,6 +203,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final SleepStatus sleepStatus;
     private int emptyTime;
     private final PortalForcer portalForcer;
+    public final org.leavesmc.lumina.utils.LevelNetherPortalPoiManager netherPortalPoiManager; // Lumina - rewrite nether portal find logic
     //private final LevelTicks<Block> blockTicks; // Folia - region threading
     //private final LevelTicks<Fluid> fluidTicks; // Folia - region threading
     //private final PathTypeCache pathTypesByPosCache; // Folia - region threading
@@ -827,6 +828,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         });
         this.chunkSource.getGeneratorState().ensureStructuresGenerated();
         this.portalForcer = new PortalForcer(this);
+        this.netherPortalPoiManager = new org.leavesmc.lumina.utils.LevelNetherPortalPoiManager(this); // Lumina - rewrite nether portal find logic
         //this.updateSkyBrightness(); // Folia - region threading - delay until first tick
         this.prepareWeather();
         this.getWorldBorder().setAbsoluteMaxSize(minecraftserver.getAbsoluteMaxWorldSize());
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 38c6403c780e276910cb0c30cb12b066249be81e..45eb414e4771ddff644d0231d819cb35b1130ca9 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -4389,12 +4389,16 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                     net.minecraft.world.level.chunk.status.ChunkStatus.EMPTY,
                     ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.HIGH,
                     (chunks) -> {
-                        BlockUtil.FoundRectangle portal =
-                            destination.getPortalForcer().findPortalAround(targetPos, destinationBorder, portalSearchRadius).orElse(null);
+                        // Lumina start - rewrite nether portal find logic
+                        BlockUtil.FoundRectangle portal = destination.netherPortalPoiManager.findClosestPortal(targetPos, destinationBorder);
+                        if (portal == null) {
+                            portal = destination.getPortalForcer().findPortalAround(targetPos, destinationBorder, portalSearchRadius).orElse(null);
+                        }
                         if (portal != null) {
                             portalFound.complete(portal);
                             return;
                         }
+                        // Lumina end - rewrite nether portal find logic
 
                         // add tickets so that we can re-search for a portal once the chunks are loaded
                         Long ticketId = Long.valueOf(CREATE_PORTAL_DOUBLE_CHECK.getAndIncrement());
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
index 4ee7d75c56d9f9ff3607276857dde84410ba3f2a..3f2f4ae25de3ecf559bd3650290fe27d60d1d6b8 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
@@ -30,6 +30,8 @@ public class PoiSection {
     private final Runnable setDirty;
     private boolean isValid;
     public final Optional<PoiSection> noAllocateOptional = Optional.of(this); // Paper - rewrite chunk system
+    private boolean loading = false; // Lumina - rewrite nether portal find logic
+    public final Set<BlockPos> loadedNetherPortalPoi = new java.util.HashSet<>();
 
     public static Codec<PoiSection> codec(Runnable updateListener) {
         return RecordCodecBuilder.<PoiSection>create(
@@ -56,7 +58,9 @@ public class PoiSection {
     private PoiSection(Runnable updateListener, boolean valid, List<PoiRecord> pois) {
         this.setDirty = updateListener;
         this.isValid = valid;
+        this.loading = true; // Lumina - rewrite nether portal find logic
         pois.forEach(this::add);
+        this.loading = false; // Lumina - rewrite nether portal find logic
     }
 
     public Stream<PoiRecord> getRecords(Predicate<Holder<PoiType>> predicate, PoiManager.Occupancy occupationStatus) {
@@ -87,6 +91,7 @@ public class PoiSection {
 
             Util.logAndPauseIfInIde("POI data mismatch: already registered at " + blockPos);
         }
+        if (holder.is(PoiTypes.NETHER_PORTAL) && loading) loadedNetherPortalPoi.add(blockPos); // Lumina - rewrite nether portal find logic
 
         this.records.put(s, poi);
         this.byType.computeIfAbsent(holder, type -> Sets.newHashSet()).add(poi);
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 7fb23c02dc91ed3af27eb4420ce920ab22bdb359..72d71c4ad3a4a16352fd425e1203a7ce56bc1091 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -57,6 +57,7 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.border.BorderChangeListener;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.ChunkAccess;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 1e96806c974a9fdb574f851daea2fb67cb9ac409..146f50d0a56cd6031b74c0c770a68dc73e54a3e3 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -39,6 +39,7 @@ import net.minecraft.world.level.block.entity.BlockEntityTicker;
 import net.minecraft.world.level.block.entity.BlockEntityType;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.gameevent.EuclideanGameEventListenerRegistry;
 import net.minecraft.world.level.gameevent.GameEventListener;
@@ -494,6 +495,15 @@ public class LevelChunk extends ChunkAccess {
     public BlockState setBlockState(BlockPos blockposition, BlockState iblockdata, boolean flag, boolean doPlace) {
         io.papermc.paper.util.TickThread.ensureTickThread(this.level, blockposition, "Updating block asynchronously"); // Folia - region threading
         // CraftBukkit end
+        // Lumina start - rewrite nether portal find logic
+        BlockState oldState = getBlockState(blockposition);
+        if (oldState.is(net.minecraft.world.level.block.Blocks.NETHER_PORTAL)) {
+            level.netherPortalPoiManager.removePoi(blockposition);
+        }
+        if (iblockdata.is(net.minecraft.world.level.block.Blocks.NETHER_PORTAL)) {
+            level.netherPortalPoiManager.addPoi(blockposition, iblockdata);
+        }
+        // Lumina end - rewrite nether portal find logic
         int i = blockposition.getY();
         LevelChunkSection chunksection = this.getSection(this.getSectionIndex(i));
         boolean flag1 = chunksection.hasOnlyAir();
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
index 4739bdb828be18d9bec7ae2d6c6b332de879acee..8cb99bc8719165824e434023fbff8be1eca844c0 100644
--- a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
@@ -11,4 +11,5 @@ public class Performance {
     public boolean entityGoalSelectorInactiveTick = false;
     public boolean allowLoadChunksToActiveClimbingEntities = false;
     public boolean optimizeSuffocation = false;
+    public boolean cacheNetherPortalFind = true;
 }
diff --git a/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java b/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c3ccf39202ca7b19229be03fd6a3ffd2060edbd
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java
@@ -0,0 +1,264 @@
+package org.leavesmc.lumina.utils;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import net.minecraft.BlockUtil;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.level.dimension.LevelStem;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.leavesmc.lumina.config.LuminaConfig;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import static net.minecraft.BlockUtil.*;
+
+public class LevelNetherPortalPoiManager {
+    private final int maxBuildSubChunkY;
+    private final int minBuildSubChunkY;
+    private final int maxFindSubChunkDistance;
+    private final int maxFindDistance;
+    private final ServerLevel level;
+    private final boolean isNether;
+    private final ConcurrentMap<BlockPos, ConcurrentMap<BlockPos, FoundRectangle>> poiData = new ConcurrentHashMap<>();
+    private final ConcurrentMap<BlockPos, FoundRectangle> cache = new ConcurrentHashMap<>(); // this may cause error when border move
+    private final ConcurrentMap<FoundRectangle, Set<BlockPos>> reserveCache = new ConcurrentHashMap<>();
+    private final ConcurrentMap<BlockPos, Set<FoundRectangle>> affectCache = new ConcurrentHashMap<>();
+    private final ConcurrentMap<FoundRectangle, Set<BlockPos>> reserveAffectCache = new ConcurrentHashMap<>();
+    private static final ConcurrentMap<BlockPos, FoundRectangle> EMPTY_SUB_CHUNK_DATA = new ConcurrentHashMap<>();
+
+    public LevelNetherPortalPoiManager(@NotNull ServerLevel level) {
+        this.isNether = level.getTypeKey() == LevelStem.NETHER;
+        this.maxFindSubChunkDistance = isNether ? 1 : 8;
+        this.maxFindDistance = isNether ? 16 : 128;
+        this.level = level;
+        int minBuildHeight = isNether ? 0 : -64;
+        int maxBuildHeight = isNether ? 256 : 320;
+        this.minBuildSubChunkY = minBuildHeight >> 4;
+        this.maxBuildSubChunkY = maxBuildHeight >> 4;
+    }
+
+    public void addPoi(@NotNull BlockPos pos, @NotNull BlockState state) {
+        FoundRectangle foundRectangle = BlockUtil.getLargestRectangleAround(
+                pos,
+                state.getValue(BlockStateProperties.HORIZONTAL_AXIS),
+                21,
+                Direction.Axis.Y,
+                21,
+                (blockPos) -> this.level.getBlockStateFromEmptyChunk(blockPos) == state
+        );
+        BlockPos subChunkPos = calcSubChunkPos(pos);
+        if(foundRectangle.axis2Size == 1 && foundRectangle.axis1Size == 1) {
+            addInternal(pos, subChunkPos, foundRectangle);
+        } else {
+            RegionizedServer.getInstance().taskQueue.queueChunkTask(
+                    level, subChunkPos.getX(), subChunkPos.getZ(), () -> {
+                addInternal(pos, subChunkPos, foundRectangle);
+            });
+        }
+    }
+
+    private void addInternal(@NotNull BlockPos pos, @NotNull BlockPos subChunkPos, @NotNull FoundRectangle foundRectangle) {
+        if (LuminaConfig.configModule.performance.cacheNetherPortalFind) {
+            Set<FoundRectangle> affectSet = affectCache.getOrDefault(subChunkPos, Set.of());
+            affectCache.remove(subChunkPos);
+            for (FoundRectangle affect : affectSet) {
+                Set<BlockPos> startSet = reserveCache.getOrDefault(affect, Set.of());
+                reserveCache.remove(affect);
+                for (BlockPos start : startSet) {
+                    cache.remove(start);
+                }
+            }
+        }
+        poiData.computeIfAbsent(
+                calcSubChunkPos(pos),
+                (k) -> new ConcurrentHashMap<>()
+        ).put(pos, foundRectangle);
+    }
+
+    public void removePoi(BlockPos pos) {
+        ConcurrentMap<BlockPos, FoundRectangle> set = poiData.get(calcSubChunkPos(pos));
+        if (set != null) {
+            if (LuminaConfig.configModule.performance.cacheNetherPortalFind) {
+                FoundRectangle foundRectangle = set.get(pos);
+                if (foundRectangle != null) {
+                    Set<BlockPos> affectSet = reserveAffectCache.get(foundRectangle);
+                    reserveAffectCache.remove(foundRectangle);
+                    for (BlockPos affect : affectSet) {
+                        affectCache.remove(affect);
+                    }
+                    affectCache.remove(calcSubChunkPos(pos));
+                    cache.remove(pos);
+                }
+            }
+            set.remove(pos);
+        }
+    }
+
+    private ConcurrentMap<BlockPos, FoundRectangle> getSubChunkData(BlockPos subChunkPos) {
+        return poiData.getOrDefault(subChunkPos, EMPTY_SUB_CHUNK_DATA);
+    }
+
+    public @Nullable FoundRectangle findClosestPortal(BlockPos center, WorldBorder worldborder) {
+        if (LuminaConfig.configModule.performance.cacheNetherPortalFind && cache.containsKey(center)) {
+            return cache.get(center);
+        }
+        BlockPos centerSubChunk = calcSubChunkPos(center);
+        Set<BlockPos> now = new HashSet<>();
+        Set<BlockPos> all = new HashSet<>();
+        int n = 0;
+        now.add(centerSubChunk);
+        boolean shouldContinue = true;
+        FoundRectangle result = null;
+        BlockPos resultPos = null;
+        double nowDistanceSqr = Double.MAX_VALUE;
+        while (shouldContinue) {
+            n++;
+            shouldContinue = false;
+            Set<BlockPos> next = new HashSet<>();
+            for (BlockPos subChunkPos : now) {
+                all.add(subChunkPos);
+                ConcurrentMap<BlockPos, FoundRectangle> subChunkData = getSubChunkData(subChunkPos);
+                if (subChunkData != null) {
+                    for (BlockPos poi : subChunkData.keySet()) {
+                        if (!worldborder.isWithinBounds(poi) || (isNether && level.paperConfig()
+                                .environment
+                                .netherCeilingVoidDamageHeight
+                                .test(v -> poi.getY() >= v))) {
+                            continue;
+                        }
+                        if (poi.getX() - center.getX() > maxFindDistance
+                                || poi.getZ() - center.getZ() > maxFindDistance) {
+                            continue;
+                        }
+                        double distSqr = center.distSqr(poi);
+                        if (distSqr < nowDistanceSqr) {
+                            result = subChunkData.get(poi);
+                            resultPos = poi;
+                            nowDistanceSqr = distSqr;
+                        } else if (distSqr == nowDistanceSqr) {
+                            assert result != null; // if result is null, distance = Double.MAX_VALUE != nowDistance
+                            if (poi.getY() < resultPos.getY()) {
+                                result = subChunkData.get(poi);
+                            }
+                        }
+                    }
+                }
+                shouldContinue = addNeighborsToNext(subChunkPos, next, all, centerSubChunk) || shouldContinue;
+            }
+            now = next;
+            if (getMaxDistanceSqr(n) >= nowDistanceSqr) {
+                shouldContinue = false;
+            }
+        }
+        if (LuminaConfig.configModule.performance.cacheNetherPortalFind && result != null) {
+            cache.put(center, result);
+            reserveCache.computeIfAbsent(result, (k) -> ConcurrentHashMap.newKeySet()).add(center);
+            reserveAffectCache.computeIfAbsent(result, (k) -> ConcurrentHashMap.newKeySet()).addAll(all);
+            for (BlockPos subChunkPos : all) {
+                affectCache.computeIfAbsent(subChunkPos, (k) -> ConcurrentHashMap.newKeySet()).add(result);
+            }
+        }
+        return result;
+    }
+
+    private boolean addNeighborsToNext(@NotNull BlockPos subChunkPos, Set<BlockPos> next, Set<BlockPos> all, BlockPos center) {
+        boolean shouldContinue = addToNext(subChunkPos.above(), next, all, center);
+        shouldContinue = addToNext(subChunkPos.below(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.north(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.south(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.east(), next, all, center) || shouldContinue;
+        return addToNext(subChunkPos.west(), next, all, center) || shouldContinue;
+    }
+
+    @Contract("_ -> new")
+    private @NotNull BlockPos calcSubChunkPos(@NotNull BlockPos pos) {
+        return new BlockPos(pos.getX() >> 4, pos.getY() >> 4, pos.getZ() >> 4);
+    }
+
+    private boolean addToNext(BlockPos subChunkPos, Set<BlockPos> next, @NotNull Set<BlockPos> all, BlockPos center) {
+        if (!all.contains(subChunkPos)
+                && Math.abs(center.getX() - subChunkPos.getX()) <= maxFindSubChunkDistance
+                && Math.abs(center.getZ() - subChunkPos.getZ()) <= maxFindSubChunkDistance
+                && subChunkPos.getY() <= maxBuildSubChunkY
+                && subChunkPos.getY() >= minBuildSubChunkY) {
+            next.add(subChunkPos);
+            return true;
+        }
+        return false;
+    }
+
+    private int getMaxDistanceSqr(int n) {
+        return isNether ? netherMaxDistanceSqr[n - 1] : overworldMaxDistanceSqr[n - 1];
+    }
+
+    private final int[] overworldMaxDistanceSqr = {
+            0,
+            1,
+            2,
+            290,
+            578,
+            866,
+            1666,
+            2466,
+            3266,
+            4578,
+            5890,
+            7202,
+            9026,
+            10850,
+            12674,
+            15010,
+            17346,
+            19682,
+            22530,
+            25378,
+            28226,
+            31586,
+            34946,
+            38306,
+            42178,
+            46050,
+            49922,
+            54306,
+            58690,
+            63074,
+            67970,
+            72866,
+            77762,
+            83170,
+            88578,
+            93986,
+            99906,
+            105826,
+            111746,
+            118178
+    };
+    private final int[] netherMaxDistanceSqr = {
+            0,
+            1,
+            2,
+            290,
+            1090,
+            2402,
+            4226,
+            6562,
+            9410,
+            12770,
+            16642,
+            21026,
+            25922,
+            31330,
+            37250,
+            43682,
+            50626,
+            58082
+    };
+}
