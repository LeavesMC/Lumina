From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7@outlook.com>
Date: Sun, 18 Aug 2024 21:44:23 +0800
Subject: [PATCH] Rewrite nether portal find logic


diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index a33389dbc9c80d0ff0c962218ea9f05f27de62bb..6ff4d767c6bf4e0f9908069834dc97f4351d6236 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -203,6 +203,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final SleepStatus sleepStatus;
     private int emptyTime;
     private final PortalForcer portalForcer;
+    public final org.leavesmc.lumina.utils.LevelNetherPortalPoiManager netherPortalPoiManager; // Lumina - rewrite nether portal find logic
     //private final LevelTicks<Block> blockTicks; // Folia - region threading
     //private final LevelTicks<Fluid> fluidTicks; // Folia - region threading
     //private final PathTypeCache pathTypesByPosCache; // Folia - region threading
@@ -827,6 +828,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         });
         this.chunkSource.getGeneratorState().ensureStructuresGenerated();
         this.portalForcer = new PortalForcer(this);
+        this.netherPortalPoiManager = new org.leavesmc.lumina.utils.LevelNetherPortalPoiManager(this.getTypeKey() == LevelStem.NETHER); // Lumina - rewrite nether portal find logic
         //this.updateSkyBrightness(); // Folia - region threading - delay until first tick
         this.prepareWeather();
         this.getWorldBorder().setAbsoluteMaxSize(minecraftserver.getAbsoluteMaxWorldSize());
diff --git a/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java b/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fb6d7cefa26ffbb9044936e83f79281e2881824
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/LevelNetherPortalPoiManager.java
@@ -0,0 +1,182 @@
+package org.leavesmc.lumina.utils;
+
+import net.minecraft.core.Vec3i;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public class LevelNetherPortalPoiManager {
+    private final int maxBuildSubChunkY;
+    private final int minBuildSubChunkY;
+    private final int maxFindSubChunkDistance;
+    private final int maxFindDistance;
+    private final boolean isNether;
+    private final ConcurrentMap<Vec3i, Set<Vec3i>> poiData = new ConcurrentHashMap<>();
+
+    public LevelNetherPortalPoiManager(boolean isNether) {
+        this.isNether = isNether;
+        this.maxFindSubChunkDistance = isNether ? 1 : 8;
+        this.maxFindDistance = isNether ? 16 : 128;
+        int minBuildHeight = isNether ? 0 : -64;
+        int maxBuildHeight = isNether ? 256 : 320;
+        this.minBuildSubChunkY = minBuildHeight >> 4;
+        this.maxBuildSubChunkY = maxBuildHeight >> 4;
+    }
+
+    public void addPoi(Vec3i pos) {
+        poiData.computeIfAbsent(
+                calcSubChunkPos(pos),
+                (k) -> ConcurrentHashMap.newKeySet()
+        ).add(pos);
+    }
+
+    public void removePoi(Vec3i pos) {
+        Set<Vec3i> set = poiData.get(calcSubChunkPos(pos));
+        if (set != null) {
+            set.remove(pos);
+        }
+    }
+
+    public Set<Vec3i> getSubChunkData(Vec3i subChunkPos) {
+        return poiData.getOrDefault(subChunkPos, Set.of());
+    }
+
+    public Vec3i findClosestPoi(Vec3i center) {
+        Vec3i centerSubChunk = calcSubChunkPos(center);
+        Set<Vec3i> now = new HashSet<>();
+        Set<Vec3i> all = new HashSet<>();
+        int n = 0;
+        now.add(centerSubChunk);
+        boolean shouldContinue = true;
+        Vec3i result = null;
+        double nowDistanceSqr = Double.MAX_VALUE;
+        while (shouldContinue) {
+            n++;
+            shouldContinue = false;
+            Set<Vec3i> next = new HashSet<>();
+            for (Vec3i subChunkPos : now) {
+                all.add(subChunkPos);
+                Set<Vec3i> subChunkData = getSubChunkData(subChunkPos);
+                if (subChunkData != null) {
+                    for (Vec3i poi : subChunkData) {
+                        if (poi.getX() - center.getX() > maxFindDistance
+                                || poi.getZ() - center.getZ() > maxFindDistance) {
+                            continue;
+                        }
+                        double distSqr = center.distSqr(poi);
+                        if (distSqr < nowDistanceSqr) {
+                            result = poi;
+                            nowDistanceSqr = distSqr;
+                        } else if (distSqr == nowDistanceSqr) {
+                            assert result != null; // if result is null, distance = Double.MAX_VALUE != nowDistance
+                            if (poi.getY() < result.getY()) {
+                                result = poi;
+                            }
+                        }
+                    }
+                }
+                shouldContinue = addNeighborsToNext(subChunkPos, next, all, centerSubChunk) || shouldContinue;
+            }
+            now = next;
+            if (getMaxDistanceSqr(n) >= nowDistanceSqr) {
+                shouldContinue = false;
+            }
+        }
+        return result;
+    }
+
+    private boolean addNeighborsToNext(@NotNull Vec3i subChunkPos, Set<Vec3i> next, Set<Vec3i> all, Vec3i center) {
+        boolean shouldContinue = addToNext(subChunkPos.above(), next, all, center);
+        shouldContinue = addToNext(subChunkPos.below(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.north(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.south(), next, all, center) || shouldContinue;
+        shouldContinue = addToNext(subChunkPos.east(), next, all, center) || shouldContinue;
+        return addToNext(subChunkPos.west(), next, all, center) || shouldContinue;
+    }
+
+    @Contract("_ -> new")
+    private @NotNull Vec3i calcSubChunkPos(@NotNull Vec3i pos) {
+        return new Vec3i(pos.getX() >> 4, pos.getY() >> 4, pos.getZ() >> 4);
+    }
+
+    private boolean addToNext(Vec3i subChunkPos, Set<Vec3i> next, @NotNull Set<Vec3i> all, Vec3i center) {
+        if (!all.contains(subChunkPos)
+                && Math.abs(center.getX() - subChunkPos.getX()) <= maxFindSubChunkDistance
+                && Math.abs(center.getZ() - subChunkPos.getZ()) <= maxFindSubChunkDistance
+                && subChunkPos.getY() <= maxBuildSubChunkY
+                && subChunkPos.getY() >= minBuildSubChunkY) {
+            next.add(subChunkPos);
+            return true;
+        }
+        return false;
+    }
+
+    private int getMaxDistanceSqr(int n) {
+        return isNether ? netherMaxDistanceSqr.get(n-1) : overworldMaxDistanceSqr.get(n-1);
+    }
+
+    private final List<Integer> overworldMaxDistanceSqr = List.of(
+            0,
+            1,
+            2,
+            290,
+            578,
+            866,
+            1666,
+            2466,
+            3266,
+            4578,
+            5890,
+            7202,
+            9026,
+            10850,
+            12674,
+            15010,
+            17346,
+            19682,
+            22530,
+            25378,
+            28226,
+            31586,
+            34946,
+            38306,
+            42178,
+            46050,
+            49922,
+            54306,
+            58690,
+            63074,
+            67970,
+            72866,
+            77762,
+            83170,
+            88578,
+            93986,
+            99906,
+            105826,
+            111746,
+            118178
+    );
+    private final List<Integer> netherMaxDistanceSqr = List.of(
+            0,
+            1,
+            2,
+            290,
+            1090,
+            2402,
+            4226,
+            6562,
+            9410,
+            12770,
+            16642,
+            21026,
+            25922,
+            31330,
+            37250,
+            43682,
+            50626
+    );
+}
