From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7studio@foxmail.com>
Date: Thu, 11 Apr 2024 22:58:15 +0800
Subject: [PATCH] Lumina server config and command


diff --git a/src/main/java/org/leavesmc/leaves/bot/BotCommand.java b/src/main/java/org/leavesmc/leaves/bot/BotCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..407d2691249283e9ab6b9638e50cc1e4dca0496b
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/bot/BotCommand.java
@@ -0,0 +1,518 @@
+package org.leavesmc.leaves.bot;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.command.CommandUtil;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.generator.WorldInfo;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.bot.agent.Actions;
+import org.leavesmc.leaves.bot.agent.BotAction;
+import org.leavesmc.leaves.bot.agent.BotConfig;
+import org.leavesmc.leaves.bot.agent.Configs;
+import org.leavesmc.leaves.bot.agent.actions.CraftCustomBotAction;
+import org.leavesmc.leaves.command.CommandArgumentResult;
+import org.leavesmc.leaves.entity.Bot;
+import org.leavesmc.leaves.event.bot.BotActionStopEvent;
+import org.leavesmc.leaves.event.bot.BotConfigModifyEvent;
+import org.leavesmc.leaves.event.bot.BotCreateEvent;
+import org.leavesmc.leaves.event.bot.BotRemoveEvent;
+import org.leavesmc.leaves.plugin.MinecraftInternalPlugin;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.slf4j.Logger;
+
+import java.util.*;
+
+import static net.kyori.adventure.text.Component.text;
+
+public class BotCommand extends Command {
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+    private final Component unknownMessage;
+
+    public BotCommand(String name) {
+        super(name);
+        this.description = "FakePlayer Command";
+        this.usageMessage = "/bot [create | remove | action | list | config]";
+        this.unknownMessage = text("Usage: " + usageMessage, NamedTextColor.RED);
+        this.setPermission("bukkit.command.bot");
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+        if (pluginManager.getPermission("bukkit.command.bot") == null) {
+            pluginManager.addPermission(new Permission("bukkit.command.bot", PermissionDefault.OP));
+        }
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, String @NotNull [] args, Location location) throws IllegalArgumentException {
+        List<String> list = new ArrayList<>();
+        BotList botList = BotList.INSTANCE;
+
+        if (args.length <= 1) {
+            list.add("create");
+            list.add("remove");
+            list.add("action");
+            list.add("config");
+            list.add("save");
+            list.add("load");
+            list.add("list");
+        }
+
+        if (args.length == 2) {
+            switch (args[0]) {
+                case "create" -> list.add("<BotName>");
+                case "remove", "action", "config", "save" ->
+                        list.addAll(botList.bots.stream().map(e -> e.getName().getString()).toList());
+                case "list" -> list.addAll(Bukkit.getWorlds().stream().map(WorldInfo::getName).toList());
+                case "load" -> list.addAll(botList.getSavedBotList().getAllKeys());
+            }
+        }
+
+        if (args.length == 3) {
+            switch (args[0]) {
+                case "action" -> {
+                    list.add("list");
+                    list.add("stop");
+                    list.addAll(Actions.getNames());
+                }
+                case "create" -> list.add("<BotSkinName>");
+                case "config" -> list.addAll(acceptConfig);
+                case "remove" -> list.addAll(List.of("cancel", "[hour]"));
+            }
+        }
+
+        if (args[0].equals("remove") && args.length >= 3) {
+            if (!Objects.equals(args[3], "cancel")) {
+                switch (args.length) {
+                    case 4 -> list.add("[minute]");
+                    case 5 -> list.add("[second]");
+                }
+            }
+        }
+
+        if (args.length >= 4 && args[0].equals("action")) {
+            ServerBot bot = botList.getBotByName(args[1]);
+
+            if (bot == null) {
+                return Collections.singletonList("<" + args[1] + " not found>");
+            }
+
+            if (args[2].equals("stop")) {
+                list.add("all");
+                for (int i = 0; i < bot.getBotActions().size(); i++) {
+                    list.add(String.valueOf(i));
+                }
+            } else {
+                BotAction<?> action = Actions.getForName(args[2]);
+                if (action != null) {
+                    list.addAll(action.getArgument().tabComplete(args.length - 4));
+                }
+            }
+        }
+
+        if (args.length >= 4 && args[0].equals("config")) {
+            Configs<?> config = Configs.getConfig(args[2]);
+            if (config != null) {
+                list.addAll(config.config.getArgument().tabComplete(args.length - 4));
+            }
+        }
+
+        return CommandUtil.getListMatchingLast(sender, args, list);
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String[] args) {
+        if (!testPermission(sender) || !LuminaConfig.configModule().modify.fakeplayer.enable) return true;
+
+        if (args.length == 0) {
+            sender.sendMessage(unknownMessage);
+            return false;
+        }
+
+        if (List.of("action", "config", "save", "load").contains(args[0]) && !sender.hasPermission("bukkit.command.bot." + args[0])) {
+            sender.sendMessage(unknownMessage);
+            return false;
+        }
+
+        switch (args[0]) {
+            case "create" -> this.onCreate(sender, args);
+            case "remove" -> this.onRemove(sender, args);
+            case "action" -> this.onAction(sender, args);
+            case "config" -> this.onConfig(sender, args);
+            case "list" -> this.onList(sender, args);
+            case "save" -> this.onSave(sender, args);
+            case "load" -> this.onLoad(sender, args);
+            default -> {
+                sender.sendMessage(unknownMessage);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private void onCreate(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(text("Use /bot create <name> [skin_name] to create a fakeplayer", NamedTextColor.RED));
+            return;
+        }
+
+        String botName = args[1];
+        if (this.canCreate(sender, botName)) {
+            BotCreateState.Builder builder = BotCreateState.builder(botName, Bukkit.getWorlds().getFirst().getSpawnLocation()).createReason(BotCreateEvent.CreateReason.COMMAND).creator(sender);
+
+            if (args.length >= 3) {
+                builder.skinName(args[2]);
+            }
+
+            if (sender instanceof Player player) {
+                builder.location(player.getLocation());
+            } else if (sender instanceof ConsoleCommandSender) {
+                if (args.length >= 7) {
+                    try {
+                        World world = Bukkit.getWorld(args[3]);
+                        double x = Double.parseDouble(args[4]);
+                        double y = Double.parseDouble(args[5]);
+                        double z = Double.parseDouble(args[6]);
+                        if (world != null) {
+                            builder.location(new Location(world, x, y, z));
+                        }
+                    } catch (Exception e) {
+                        LOGGER.warn("Can't build location", e);
+                    }
+                }
+            }
+
+            builder.spawnWithSkin(null);
+        }
+    }
+
+    private boolean canCreate(CommandSender sender, @NotNull String name) {
+        BotList botList = BotList.INSTANCE;
+        if (!name.matches("^[a-zA-Z0-9_]{4,16}$")) {
+            sender.sendMessage(text("This name is illegal", NamedTextColor.RED));
+            return false;
+        }
+
+        if (Bukkit.getPlayerExact(name) != null || botList.getBotByName(name) != null) {
+            sender.sendMessage(text("This player is in server", NamedTextColor.RED));
+            return false;
+        }
+
+        return true;
+    }
+
+    private void onRemove(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2 || args.length > 5) {
+            sender.sendMessage(text("Use /bot remove <name> [hour] [minute] [second] to remove a fakeplayer", NamedTextColor.RED));
+            return;
+        }
+
+        BotList botList = BotList.INSTANCE;
+        ServerBot bot = botList.getBotByName(args[1]);
+
+        if (bot == null) {
+            sender.sendMessage(text("This fakeplayer is not in server", NamedTextColor.RED));
+            return;
+        }
+
+        if (args.length > 2) {
+            if (args[2].equals("cancel")) {
+                if (bot.removeTaskId == -1) {
+                    sender.sendMessage(text("This fakeplayer is not scheduled to be removed", NamedTextColor.RED));
+                    return;
+                }
+                Bukkit.getScheduler().cancelTask(bot.removeTaskId);
+                bot.removeTaskId = -1;
+                sender.sendMessage(text("Remove cancel"));
+                return;
+            }
+
+            long time = 0;
+            int h; // Preventing out-of-range
+            long s = 0;
+            long m = 0;
+
+            try {
+                h = Integer.parseInt(args[2]);
+                if (h < 0) {
+                    throw new NumberFormatException();
+                }
+                time += ((long) h) * 3600 * 20;
+                if (args.length > 3) {
+                    m = Long.parseLong(args[3]);
+                    if (m > 59 || m < 0) {
+                        throw new NumberFormatException();
+                    }
+                    time += m * 60 * 20;
+                }
+                if (args.length > 4) {
+                    s = Long.parseLong(args[4]);
+                    if (s > 59 || s < 0) {
+                        throw new NumberFormatException();
+                    }
+                    time += s * 20;
+                }
+            } catch (NumberFormatException e) {
+                sender.sendMessage(text("This fakeplayer is not scheduled to be removed", NamedTextColor.RED));
+                return;
+            }
+
+            boolean isReschedule = bot.removeTaskId != -1;
+
+            if (isReschedule) {
+                Bukkit.getScheduler().cancelTask(bot.removeTaskId);
+            }
+            bot.removeTaskId = Bukkit.getScheduler().runTaskLater(MinecraftInternalPlugin.INSTANCE, () -> {
+                bot.removeTaskId = -1;
+                botList.removeBot(bot, BotRemoveEvent.RemoveReason.COMMAND, sender, false);
+            }, time).getTaskId();
+
+            sender.sendMessage("This fakeplayer will be removed in " + h + "h " + m + "m " + s + "s" + (isReschedule ? " (rescheduled)" : ""));
+
+            return;
+        }
+
+        botList.removeBot(bot, BotRemoveEvent.RemoveReason.COMMAND, sender, false);
+    }
+
+    private void onAction(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 3) {
+            sender.sendMessage(text("Use /bot action <name> <action> to make fakeplayer do action", NamedTextColor.RED));
+            return;
+        }
+
+        ServerBot bot = BotList.INSTANCE.getBotByName(args[1]);
+        if (bot == null) {
+            sender.sendMessage(text("This fakeplayer is not in server", NamedTextColor.RED));
+            return;
+        }
+
+        if (args[2].equals("list")) {
+            sender.sendMessage(bot.getScoreboardName() + "'s action list:");
+            for (int i = 0; i < bot.getBotActions().size(); i++) {
+                sender.sendMessage(i + " " + bot.getBotActions().get(i).getName());
+            }
+            return;
+        }
+
+        if (args[2].equals("stop")) {
+            if (args.length < 4) {
+                sender.sendMessage(text("Invalid index", NamedTextColor.RED));
+                return;
+            }
+
+            String index = args[3];
+            if (index.equals("all")) {
+                Set<BotAction<?>> forRemoval = new HashSet<>();
+                for (int i = 0; i < bot.getBotActions().size(); i++) {
+                    BotAction<?> action = bot.getBotActions().get(i);
+                    BotActionStopEvent event = new BotActionStopEvent(
+                            bot.getBukkitEntity(), action.getName(), action.getUUID(), BotActionStopEvent.Reason.COMMAND, sender
+                    );
+                    event.callEvent();
+                    if (!event.isCancelled()) {
+                        forRemoval.add(action);
+                    }
+                }
+                bot.getBotActions().removeAll(forRemoval);
+                sender.sendMessage(bot.getScoreboardName() + "'s action list cleared.");
+            } else {
+                try {
+                    int i = Integer.parseInt(index);
+                    if (i < 0 || i >= bot.getBotActions().size()) {
+                        sender.sendMessage(text("Invalid index", NamedTextColor.RED));
+                        return;
+                    }
+
+                    BotAction<?> action = bot.getBotActions().get(i);
+                    BotActionStopEvent event = new BotActionStopEvent(
+                            bot.getBukkitEntity(), action.getName(), action.getUUID(), BotActionStopEvent.Reason.COMMAND, sender
+                    );
+                    event.callEvent();
+                    if (!event.isCancelled()) {
+                        bot.getBotActions().remove(i);
+                        sender.sendMessage(bot.getScoreboardName() + "'s " + action.getName() + " stopped.");
+
+                    }
+                } catch (NumberFormatException e) {
+                    sender.sendMessage(text("Invalid index", NamedTextColor.RED));
+                }
+            }
+            return;
+        }
+
+        BotAction<?> action = Actions.getForName(args[2]);
+        if (action == null) {
+            sender.sendMessage(text("Invalid action", NamedTextColor.RED));
+            return;
+        }
+
+        CraftPlayer player;
+        if (sender instanceof CraftPlayer) {
+            player = (CraftPlayer) sender;
+        } else {
+            player = bot.getBukkitEntity();
+        }
+
+        String[] realArgs = new String[args.length - 3];
+        if (realArgs.length != 0) {
+            System.arraycopy(args, 3, realArgs, 0, realArgs.length);
+        }
+
+        BotAction<?> newAction = null;
+        try {
+            if (action instanceof CraftCustomBotAction customBotAction) {
+                newAction = customBotAction.createCraft(player, realArgs);
+            } else {
+                newAction = action.create();
+                newAction.loadCommand(player.getHandle(), action.getArgument().parse(0, realArgs));
+            }
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        if (newAction == null) {
+            sender.sendMessage(text("Action create error, please check your arguments", NamedTextColor.RED));
+            return;
+        }
+
+        if (bot.addBotAction(newAction, sender)) {
+            sender.sendMessage("Action " + action.getName() + " has been issued to " + bot.getName().getString());
+        }
+    }
+
+    private static final List<String> acceptConfig = Configs.getConfigs().stream().map(config -> config.config.getName()).toList();
+
+    private void onConfig(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 3) {
+            sender.sendMessage(text("Use /bot config <name> <config> to modify fakeplayer's config", NamedTextColor.RED));
+            return;
+        }
+
+        ServerBot bot = BotList.INSTANCE.getBotByName(args[1]);
+        if (bot == null) {
+            sender.sendMessage(text("This fakeplayer is not in server", NamedTextColor.RED));
+            return;
+        }
+
+        if (!acceptConfig.contains(args[2])) {
+            sender.sendMessage(text("This config is not accept", NamedTextColor.RED));
+            return;
+        }
+
+        BotConfig<?> config = Objects.requireNonNull(Configs.getConfig(args[2])).config;
+        if (args.length < 4) {
+            config.getMessage().forEach(sender::sendMessage);
+        } else {
+            String[] realArgs = new String[args.length - 3];
+            System.arraycopy(args, 3, realArgs, 0, realArgs.length);
+
+            BotConfigModifyEvent event = new BotConfigModifyEvent(bot.getBukkitEntity(), config.getName(), realArgs, sender);
+            Bukkit.getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+            CommandArgumentResult result = config.getArgument().parse(0, realArgs);
+
+            try {
+                config.setValue(result);
+                config.getChangeMessage().forEach(sender::sendMessage);
+            } catch (IllegalArgumentException e) {
+                sender.sendMessage(text(e.getMessage(), NamedTextColor.RED));
+            }
+        }
+    }
+
+    private void onSave(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(text("Use /bot save <name> to save a fakeplayer", NamedTextColor.RED));
+            return;
+        }
+
+        BotList botList = BotList.INSTANCE;
+        ServerBot bot = botList.getBotByName(args[1]);
+
+        if (bot == null) {
+            sender.sendMessage(text("This fakeplayer is not in server", NamedTextColor.RED));
+            return;
+        }
+
+        if (botList.removeBot(bot, BotRemoveEvent.RemoveReason.COMMAND, sender, true)) {
+            sender.sendMessage(bot.getScoreboardName() + " saved to " + bot.createState.realName());
+        }
+    }
+
+    private void onLoad(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(text("Use /bot save <name> to save a fakeplayer", NamedTextColor.RED));
+            return;
+        }
+
+        String realName = args[1];
+        BotList botList = BotList.INSTANCE;
+        if (!botList.getSavedBotList().contains(realName)) {
+            sender.sendMessage(text("This fakeplayer is not saved", NamedTextColor.RED));
+            return;
+        }
+
+        if (botList.loadNewBot(realName) == null) {
+            sender.sendMessage(text("Can't load bot, please check", NamedTextColor.RED));
+        }
+    }
+
+    private void onList(CommandSender sender, String @NotNull [] args) {
+        BotList botList = BotList.INSTANCE;
+        if (args.length < 2) {
+            Map<World, List<String>> botMap = new HashMap<>();
+            for (World world : Bukkit.getWorlds()) {
+                botMap.put(world, new ArrayList<>());
+            }
+
+            for (ServerBot bot : botList.bots) {
+                Bot bukkitBot = bot.getBukkitEntity();
+                botMap.get(bukkitBot.getWorld()).add(bukkitBot.getName());
+            }
+
+            sender.sendMessage("Total number: (" + botList.bots.size() + ")");
+            for (World world : botMap.keySet()) {
+                sender.sendMessage(world.getName() + "(" + botMap.get(world).size() + "): " + formatPlayerNameList(botMap.get(world)));
+            }
+        } else {
+            World world = Bukkit.getWorld(args[1]);
+
+            if (world == null) {
+                sender.sendMessage(text("Unknown world", NamedTextColor.RED));
+                return;
+            }
+
+            List<String> snowBotList = new ArrayList<>();
+            for (ServerBot bot : botList.bots) {
+                Bot bukkitBot = bot.getBukkitEntity();
+                if (bukkitBot.getWorld() == world) {
+                    snowBotList.add(bukkitBot.getName());
+                }
+            }
+
+            sender.sendMessage(world.getName() + "(" + botList.bots.size() + "): " + formatPlayerNameList(snowBotList));
+        }
+    }
+
+    @NotNull
+    private static String formatPlayerNameList(@NotNull List<String> list) {
+        if (list.isEmpty()) {
+            return "";
+        }
+        String string = list.toString();
+        return string.substring(1, string.length() - 1);
+    }
+}
diff --git a/src/main/java/org/leavesmc/leaves/command/CommandArgument.java b/src/main/java/org/leavesmc/leaves/command/CommandArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..0bccbf7816ef621316f0da4911ec112f4753f88e
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/command/CommandArgument.java
@@ -0,0 +1,55 @@
+package org.leavesmc.leaves.command;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class CommandArgument {
+
+    public static final CommandArgument EMPTY = new CommandArgument();
+
+    private final List<CommandArgumentType<?>> argumentTypes;
+    private final List<List<String>> tabComplete;
+
+    private CommandArgument(CommandArgumentType<?>... argumentTypes) {
+        this.argumentTypes = List.of(argumentTypes);
+        this.tabComplete = new ArrayList<>();
+        for (int i = 0; i < argumentTypes.length; i++) {
+            tabComplete.add(new ArrayList<>());
+        }
+    }
+
+    public static CommandArgument of(CommandArgumentType<?>... argumentTypes) {
+        return new CommandArgument(argumentTypes);
+    }
+
+    public List<String> tabComplete(int n) {
+        if (tabComplete.size() > n) {
+            return tabComplete.get(n);
+        } else {
+            return List.of();
+        }
+    }
+
+    public CommandArgument setTabComplete(int index, List<String> list) {
+        tabComplete.set(index, list);
+        return this;
+    }
+
+    public CommandArgument setAllTabComplete(List<List<String>> tabComplete) {
+        this.tabComplete.clear();
+        this.tabComplete.addAll(tabComplete);
+        return this;
+    }
+
+    public CommandArgumentResult parse(int index, String @NotNull [] args) {
+        Object[] result = new Object[argumentTypes.size()];
+        Arrays.fill(result, null);
+        for (int i = index, j = 0; i < args.length && j < result.length; i++, j++) {
+            result[j] = argumentTypes.get(j).pasre(args[i]);
+        }
+        return new CommandArgumentResult(new ArrayList<>(Arrays.asList(result)));
+    }
+}
diff --git a/src/main/java/org/leavesmc/leaves/command/CommandArgumentResult.java b/src/main/java/org/leavesmc/leaves/command/CommandArgumentResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..46aa6eaa75b65aad6bdbe4a5f517b42e87bcca77
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/command/CommandArgumentResult.java
@@ -0,0 +1,69 @@
+package org.leavesmc.leaves.command;
+
+import net.minecraft.core.BlockPos;
+import org.bukkit.util.Vector;
+
+import java.util.List;
+import java.util.Objects;
+
+public class CommandArgumentResult {
+
+    private final List<Object> result;
+
+    public CommandArgumentResult(List<Object> result) {
+        this.result = result;
+    }
+
+    public int readInt(int def) {
+        return Objects.requireNonNullElse(read(Integer.class), def);
+    }
+
+    public double readDouble(double def) {
+        return Objects.requireNonNullElse(read(Double.class), def);
+    }
+
+    public float readFloat(float def) {
+        return Objects.requireNonNullElse(read(Float.class), def);
+    }
+
+    public String readString(String def) {
+        return Objects.requireNonNullElse(read(String.class), def);
+    }
+
+    public boolean readBoolean(boolean def) {
+        return Objects.requireNonNullElse(read(Boolean.class), def);
+    }
+
+    public BlockPos readPos() {
+        Integer[] pos = {read(Integer.class), read(Integer.class), read(Integer.class)};
+        for (Integer po : pos) {
+            if (po == null) {
+                return null;
+            }
+        }
+        return new BlockPos(pos[0], pos[1], pos[2]);
+    }
+
+    public Vector readVector() {
+        Double[] pos = {read(Double.class), read(Double.class), read(Double.class)};
+        for (Double po : pos) {
+            if (po == null) {
+                return null;
+            }
+        }
+        return new Vector(pos[0], pos[1], pos[2]);
+    }
+
+    public <T> T read(Class<T> tClass) {
+        if (result.isEmpty()) {
+            return null;
+        }
+
+        Object obj = result.remove(0);
+        if (tClass.isInstance(obj)) {
+            return tClass.cast(obj);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/leaves/command/CommandArgumentType.java b/src/main/java/org/leavesmc/leaves/command/CommandArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ca3508475bbd9771768704e300fe12b717489d6
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/command/CommandArgumentType.java
@@ -0,0 +1,55 @@
+package org.leavesmc.leaves.command;
+
+import org.jetbrains.annotations.NotNull;
+
+public abstract class CommandArgumentType<E> {
+
+    public static final CommandArgumentType<Integer> INTEGER = new CommandArgumentType<>() {
+        @Override
+        public Integer pasre(@NotNull String arg) {
+            try {
+                return Integer.parseInt(arg);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+    };
+
+    public static final CommandArgumentType<Double> DOUBLE = new CommandArgumentType<>() {
+        @Override
+        public Double pasre(@NotNull String arg) {
+            try {
+                return Double.parseDouble(arg);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+    };
+
+    public static final CommandArgumentType<Float> FLOAT = new CommandArgumentType<>() {
+        @Override
+        public Float pasre(@NotNull String arg) {
+            try {
+                return Float.parseFloat(arg);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+    };
+
+    public static final CommandArgumentType<String> STRING = new CommandArgumentType<>() {
+        @Override
+        public String pasre(@NotNull String arg) {
+            return arg;
+        }
+    };
+
+    public static final CommandArgumentType<Boolean> BOOLEAN = new CommandArgumentType<>() {
+        @Override
+        public Boolean pasre(@NotNull String arg) {
+            return Boolean.parseBoolean(arg);
+        }
+    };
+
+    public abstract E pasre(@NotNull String arg);
+}
diff --git a/src/main/java/org/leavesmc/lumina/LuminaCommand.java b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..872c620b9fd90e41f1c012c9462ab90f8c8b1dd1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
@@ -0,0 +1,27 @@
+package org.leavesmc.lumina;
+
+import com.mojang.logging.LogUtils;
+import dev.jorel.commandapi.CommandAPICommand;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.slf4j.Logger;
+
+public class LuminaCommand {
+    private LuminaCommand() {
+    }
+
+    public static LuminaCommand INSTANCE = new LuminaCommand();
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public void registerCommands() {
+        registerLuminaCommand();
+    }
+
+    private void registerLuminaCommand() {
+        new CommandAPICommand("lumina")
+                .withSubcommand(LuminaConfig.INSTANCE.generateConfigCommand())
+                .withSubcommand(new CommandAPICommand("carpet")
+                        .withSubcommand(CarpetConfig.INSTANCE.generateConfigCommand()))
+                .register();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..228b90a23058ac9035684dc708376f87ae6c11cc
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java
@@ -0,0 +1,109 @@
+package org.leavesmc.lumina.carpet;
+
+import net.minecraft.world.level.block.Block;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.protocol.CarpetServerProtocol;
+import org.leavesmc.lumina.carpet.utils.ConfigIdentifier;
+import org.leavesmc.lumina.config.AbstractConfig;
+import org.leavesmc.lumina.utils.ConfigUtils;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.NodePath;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+import org.spongepowered.configurate.loader.ConfigurationLoader;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.objectmapping.meta.Comment;
+
+import java.lang.annotation.Annotation;
+import java.nio.file.Paths;
+import java.util.Locale;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public class CarpetConfig extends AbstractConfig<CarpetConfigModule, CommentedConfigurationNode> {
+    public static final CarpetConfig INSTANCE = new CarpetConfig();
+
+    public static CarpetConfigModule configModule() {
+        return INSTANCE.getConfigModule();
+    }
+
+    public final ThreadLocal<Boolean> IMPENDING_FILL_SKIP_UPDATES = ThreadLocal.withInitial(() -> false);
+    public final ThreadLocal<Boolean> SKIP_GENERATION_CHECKS = ThreadLocal.withInitial(() -> false);
+    public Block structureBlockIgnoredBlock;
+    private ConcurrentMap<String, Rule> RULE_CACHE;
+
+    @Override
+    protected void init() {
+        RULE_CACHE = new ConcurrentHashMap<>();
+        super.init();
+    }
+
+    private void setRuleCache(ConfigurationNode node, Object value, Annotation annotation) {
+        if (value != null) {
+            String v;
+            if (value instanceof Enum<?> e) {
+                v = e.name().toLowerCase(Locale.ROOT);
+            } else if (value instanceof Boolean b) {
+                v = Boolean.toString(b);
+            } else {
+                v = value.toString();
+            }
+            NodePath path = node.path();
+            String name = ConfigUtils.toCamelCase(path.get(path.size() - 1).toString());
+            Rule rule = RULE_CACHE.computeIfAbsent(name, k -> new Rule());
+            rule.name = name;
+            rule.value = v;
+            if (annotation instanceof ConfigIdentifier identifier) {
+                rule.identifier = identifier.value();
+            }
+        }
+    }
+
+    @Override
+    protected ConfigurationLoader<@NotNull CommentedConfigurationNode> getConfigLoader() {
+        final ObjectMapper.Factory customFactory = ObjectMapper.factoryBuilder()
+                .addProcessor(Comment.class, (data, fieldType) -> (value, destination) -> setRuleCache(destination, value, data))
+                .addProcessor(ConfigIdentifier.class, (data, fieldType) -> (value, destination) -> setRuleCache(destination, value, data))
+                .build();
+        return HoconConfigurationLoader.builder()
+                .emitComments(true)
+                .prettyPrinting(true)
+                .defaultOptions(opts -> opts.serializers(build -> build.registerAnnotatedObjects(customFactory)))
+                .path(Paths.get("carpet.conf"))
+                .build();
+    }
+
+    @Override
+    public void loadConfig() {
+        super.loadConfig();
+        RULE_CACHE.values().forEach(Rule::register);
+    }
+
+    @Override
+    protected Class<CarpetConfigModule> getConfigModuleClass() {
+        return CarpetConfigModule.class;
+    }
+
+    @Override
+    protected String getName() {
+        return "Carpet";
+    }
+
+    @Override
+    protected String getPermissionParent() {
+        return "carpet";
+    }
+
+    private static class Rule {
+        public String identifier;
+        public String name;
+        public String value;
+
+        public void register() {
+            if (identifier == null) {
+                identifier = "carpet";
+            }
+            CarpetServerProtocol.CarpetRules.register(new CarpetServerProtocol.CarpetRule(identifier, name, value));
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d6de4b557dfb5fdef7d246f15872b9f2d7bdc60
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
@@ -0,0 +1,493 @@
+package org.leavesmc.lumina.carpet;
+
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.StructureBlockEntity;
+import net.minecraft.world.level.block.piston.PistonStructureResolver;
+import net.minecraft.world.level.border.BorderStatus;
+import net.minecraft.world.level.border.WorldBorder;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.Comment;
+
+import java.util.Optional;
+
+@ConfigSerializable
+public class CarpetConfigModule {
+    @Comment("Sets the language for Carpet")
+    public Lang language = Lang.zh_cn;
+
+    @Comment("Dropping entire stacks works also from on the crafting UI result slot")
+    public boolean ctrlQCraftingFix = false;
+
+    @Comment("""
+            Parrots don't get of your shoulders until you receive proper damage
+            It is not exactly the same as paper's `entities.behavior.parrots-are-unaffected-by-player-movement`
+            configuration in paper-world.yml""")
+    public boolean persistentParrots = false;
+
+    @Comment("Players absorb XP instantly, without delay")
+    public boolean xpNoCooldown = false;
+
+    @Validate(ShulkerBoxValidator.class)
+    @Comment("""
+            When set more than 1, empty shulker boxes can stack when thrown on the ground,
+            or when manipulated inside the inventories""")
+    public int shulkerBoxStackSize = 1;
+
+    @Comment("Explosions won't destroy blocks")
+    public boolean explosionNoBlockDamage = false;
+
+    @Comment("Experience will drop from all experience barring blocks with any explosion type")
+    public boolean xpFromExplosions = false;
+
+    @Comment("Removes random TNT momentum when primed")
+    public boolean tntPrimerMomentumRemoved = false;
+
+    // @Validate(TNTRandomRangeValidator.class)
+    // @Comment("Sets the tnt random explosion range to a fixed value, set to -1 for default behavior")
+    // public double tntRandomRange = -1; // TODO
+
+    @Validate(TNTAngleValidator.class)
+    @Comment("Sets the horizontal random angle on TNT for debugging of TNT contraptions, set to -1 for default behavior")
+    public double hardcodeTNTangle = -1.0D;
+
+    @Comment("Merges stationary primed TNT entities")
+    public boolean mergeTNT = false;
+
+    @Comment("Only husks spawn in desert temples")
+    public boolean huskSpawningInTemples = false;
+
+    @Comment("Shulkers will respawn in end cities")
+    public boolean shulkerSpawningInEndCities = false;
+
+    @Comment("""
+            Piglins will respawn in bastion remnants
+            Includes piglins, brutes, and a few hoglins""")
+    public boolean piglinsSpawningInBastions = false;
+
+    @Comment("TNT doesn't update when placed against a power source")
+    public boolean tntDoNotUpdate = false;
+
+    @Comment("""
+            Prevents players from rubberbanding when moving too fast or being kicked out for 'flying'
+            Puts more trust in clients positioning, increases player allowed mining distance to 32 blocks""")
+    public boolean antiCheatDisabled = false;
+
+    @Validate(QuasiConnectivityValidator.class)
+    @Comment("""
+            Pistons, droppers, and dispensers check for power to the block(s) above them.
+            Defines the range at which pistons, droppers, and dispensers check for quasi power""")
+    public int quasiConnectivity = 1;
+
+    @Comment("""
+            Players can flip and rotate blocks when holding cactus
+            Doesn't cause block updates when rotated/flipped
+            Applies to pistons, observers, droppers, repeaters, stairs, glazed terracotta etc...""")
+    public boolean flippinCactus = false;
+
+    @Comment("""
+            hoppers pointing to wool will count items passing through them
+            Enables /counter command, and actions while placing red and green carpets on wool blocks
+            Use /counter <color?> reset to reset the counter, and /counter <color?> to query
+            In survival, place green carpet on same color wool to query, red to reset the counters
+            Counters are global and shared between players, 16 channels available
+            Items counted are destroyed, count up to one stack per tick per hopper""")
+    public boolean hopperCounters = false;
+
+    @Comment("""
+            Allows Budding Amethyst blocks to be moved by pistons
+            as well as adds extra drop when mining with silk touch pickaxe""")
+    public boolean movableAmethyst = false;
+
+    @Comment("Guardians turn into Elder Guardian when struck by lightning")
+    public boolean renewableSponges = false;
+
+    // @Comment("Pistons can push block entities, like hoppers, chests etc.")
+    // public boolean movableBlockEntities = false; // TODO
+
+    @Comment("""
+            Chains will stick to each other on the long ends
+            and will stick to other blocks that connect to them directly.
+            With stick_to_all: it will stick even if not visually connected""")
+    public ChainStoneMode chainStone = ChainStoneMode.FALSE;
+
+    @Comment("Saplings turn into dead shrubs in hot climates and no water access")
+    public boolean desertShrubs = false;
+
+    @Comment("Silverfish drop a gravel item when breaking out of a block")
+    public boolean silverFishDropGravel = false;
+
+    @Comment("summoning a lightning bolt has all the side effects of natural lightning")
+    public boolean summonNaturalLightning = false;
+
+    @Comment("Enables /spawn command for spawn tracking")
+    public boolean commandSpawn = true;
+
+    @Comment("Enables /log command to monitor events via chat and overlays")
+    public boolean commandLog = true;
+
+    @Suggestion({"none", "tps", "mobcaps,tps"})
+    @Comment("""
+            sets these loggers in their default configurations for all new players
+            use csv, like 'tps,mobcaps' for multiple loggers, none for nothing""")
+    public String defaultLoggers = "none";
+
+    @Comment("""
+            Enables /distance command to measure in game distance between points
+            Also enables brown carpet placement action if 'carpets' rule is turned on as well""")
+    public boolean commandDistance = true;
+
+    @Comment("""
+            "Enables /info command for blocks
+            Also enables gray carpet placement action if 'carpets' rule is turned on as well""")
+    public boolean commandInfo = true;
+
+    @Comment("""
+            Enables /perimeterinfo command
+            that scans the area around the block for potential spawnable spots""")
+    public boolean commandPerimeterInfo = true;
+
+    @Comment("Enables /player command to control/spawn players")
+    public boolean commandPlayer = true;
+
+    @Comment("Spawn offline players in online mode if online-mode player with specified name does not exist")
+    public boolean allowSpawningOfflinePlayers = true;
+
+    @Comment("Allows listing fake players on the multiplayer screen")
+    public boolean allowListingFakePlayers = false;
+
+    @Comment("""
+            Add a markerName prefix for fake players spawned with /player command
+            Which can prevent summoning fake player with illegal names and make player list look nicer
+            Set it to #none to stop adding a prefix""")
+    public String fakePlayerNamePrefix = "#none";
+
+    @Comment("""
+            Add a markerName suffix for fake players spawned with /player command
+            Which can prevent summoning fake player with illegal names and make player list look nicer
+            Set it to #none to stop adding a suffix""")
+    public String fakePlayerNameSuffix = "#none";
+
+    @Comment("Allows to track mobs AI via /track command")
+    public boolean commandTrackAI = true;
+
+    @Comment("lacing carpets may issue carpet commands for non-op players")
+    public boolean carpets = false;
+
+    @Comment("Glass can be broken faster with pickaxes")
+    public boolean missingTools = false;
+
+    @Comment("fill/clone/setblock and structure blocks cause block updates")
+    public boolean fillUpdates = true;
+
+    @Comment("placing blocks cause block updates")
+    public boolean interactionUpdates = true;
+
+    @Comment("Disables breaking of blocks caused by flowing liquids")
+    public boolean liquidDamageDisabled = false;
+
+    @Validate(PushLimitValidator.class)
+    @Suggestion({"10", "12", "14", "100"})
+    @Comment("Customizable piston push limit")
+    public int pushLimit = PistonStructureResolver.MAX_PUSH_DEPTH;
+
+    @Validate(Zero1024Validator.class)
+    @Suggestion({"9", "15", "30"})
+    @Comment("Customizable powered rail power range")
+    public int railPowerLimit = 9;
+
+    @Validate(ForceloadLimitValidator.class)
+    @Comment("Customizable forceload chunk limit")
+    public int forceloadLimit = 256;
+
+    @Comment("Cactus in dispensers rotates blocks.Rotates block anti-clockwise if possible")
+    public boolean rotatorBlock = false;
+
+    @Comment("""
+            Coral structures will grow with bonemeal from coral plants
+            Expanded also allows growing from coral fans for sustainable farming outside of warm oceans""")
+    public RenewableCoralMode renewableCoral = RenewableCoralMode.FALSE;
+
+    @Comment("Nether basalt generator without soul sand below will convert into blackstone instead")
+    public boolean renewableBlackstone = false;
+
+    @Comment("Lava and water generate deepslate and cobbled deepslate instead below Y0")
+    public boolean renewableDeepslate = false;
+
+    @Comment("fixes block placement rotation issue when player rotates quickly while placing blocks")
+    public boolean placementRotationFix = false;
+
+    @Comment("Increases for testing purposes number of blue skulls shot by the wither")
+    public boolean moreBlueSkulls = false;
+
+    @Comment("""
+            Can allow to phase through walls in creative mode
+            On servers it needs to be set on both client and server to function properly.
+            Needs carpet client. Has no effect when set on the server only.""")
+    public boolean creativeNoClip = false;
+
+    // @Validate(StructureBlockLimitValidator.class)
+    // @Suggestion({"48", "96", "192", "256"})
+    // @Comment("""
+    //         Customizable structure block limit of each axis
+    //         WARNING: Needs to be permanent for correct loading.
+    //         Setting 'structureBlockIgnored' to air is recommended
+    //         when saving massive structures.
+    //         Required on client of player editing the Structure Block.
+    //         'structureBlockOutlineDistance' may be required for
+    //         correct rendering of long structures.""")
+    // public int structureBlockLimit = StructureBlockEntity.MAX_SIZE_PER_AXIS; // TODO
+
+    // @Validate(StructureBlockIgnoredValidator.class)
+    // @Suggestion({"minecraft:structure_void", "minecraft:air"})
+    // @Comment("Changes the block ignored by the Structure Block")
+    // public String structureBlockIgnored = "minecraft:structure_void"; // TODO
+
+    // @Validate(NonNegativeNumberValidator.class)
+    // @Suggestion({"96", "192", "2048"})
+    // @Comment("Customizable Structure Block outline render distance, required on client to work properly")
+    // public int structureBlockOutlineDistance = 96; // TODO
+
+    @Comment("""
+            Lightning kills the items that drop when lightning kills an entity
+            Setting to true will prevent lightning from killing drops
+            Fixes [MC-206922](https://bugs.mojang.com/browse/MC-206922).""")
+    public boolean lightningKillsDropsFix = false;
+
+    @Validate(UpdateSuppressionBlockValidator.class)
+    @Suggestion({"-1", "0", "10", "50"})
+    @Comment("""
+            Placing an activator rail on top of a barrier block will fill the neighbor updater stack when the rail turns off.
+            The integer entered is the amount of updates that should be left in the stack. set to -1 to disable this""")
+    public int updateSuppressionBlock = -1;
+
+    @Comment("""
+            Creative players load chunks, or they don't! Just like spectators!
+            Toggling behaves exactly as if the player is in spectator mode,
+            also toggling the gamerule spectatorsGenerateChunks.""")
+    public boolean creativePlayersLoadChunks = true;
+
+    @Validate(Zero1024Validator.class)
+    @Suggestion({"8", "16", "32"})
+    @Comment("Customizable sculk sensor range")
+    public int sculkSensorRange = 8;
+
+    @Validate(WorldBorderValidator.class)
+    @Comment("""
+            Makes world borders move based on in game time instead of real time
+            This has the effect that when the tick rate changes the world border speed also changes proportional to it""")
+    public boolean tickSyncedWorldBorders = false;
+
+    // refers to "[MC-215169](https://bugs.mojang.com/browse/MC-215169)." - unconfirmed yet that its a java bug
+    @Comment("""
+            Allows to grow nether fungi with 3x3 base with bonemeal
+            Setting to 'all' will make all nether fungi grow into 3x3 trees
+            Setting to 'random' will make 6% of all nether fungi grow into 3x3 trees
+            (this being consistent with worldgen)""")
+    public FungusGrowthMode thickFungusGrowth = FungusGrowthMode.FALSE;
+
+    public static class ShulkerBoxValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue > 0 && newValue <= 64;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 64, but got " + newValue;
+        }
+    }
+
+    public static class TNTRandomRangeValidator extends Validator<Double> {
+        @Override
+        public boolean validate(Double newValue, Double oldValue) {
+            return newValue == -1 || newValue >= 0;
+        }
+
+        @Override
+        public String getErrorMessage(Double newValue) {
+            return "Value can't be negative, or -1, but got " + newValue;
+        }
+    }
+
+    public static class TNTAngleValidator extends Validator<Double> {
+        @Override
+        public boolean validate(Double newValue, Double oldValue) {
+            return (newValue >= 0 && newValue < Math.PI * 2) || newValue == -1;
+        }
+
+        @Override
+        public String getErrorMessage(Double newValue) {
+            return "Value must be a number between 0 and 2Pi(include 0), or -1, but got " + newValue;
+        }
+    }
+
+    public static class QuasiConnectivityValidator extends Validator<Integer> {
+        private int maxRange = 1;
+
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            int minRange = 0;
+            int maxRange = 1;
+
+            if (!MinecraftServer.getServer().isReady()) {
+                maxRange = Integer.MAX_VALUE;
+            } else {
+                for (Level level : MinecraftServer.getServer().getAllLevels()) {
+                    maxRange = Math.max(maxRange, level.getHeight() - 1);
+                }
+            }
+
+            this.maxRange = maxRange;
+
+            return newValue >= minRange && newValue <= maxRange;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 0 to the max level height(now " + maxRange + "), but got " + newValue;
+        }
+    }
+
+
+    public static class PushLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            PistonStructureResolver.MAX_PUSH_DEPTH = newValue;
+            return newValue >= 1 && newValue <= 1024;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 1024, but got " + newValue;
+        }
+    }
+
+    public static class Zero1024Validator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 1 && newValue <= 1024;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 1024, but got " + newValue;
+        }
+    }
+
+    public static class ForceloadLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 0 && newValue <= 20000000;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 0 to 20M, but got " + newValue;
+        }
+    }
+
+    public static class NonNegativeNumberValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 0;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a non-negative number, but got " + newValue;
+        }
+    }
+
+    public static class StructureBlockLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= StructureBlockEntity.MAX_SIZE_PER_AXIS;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "You have to choose a value greater or equal to 48, but got " + newValue;
+        }
+    }
+
+    public static class StructureBlockIgnoredValidator extends Validator<String> {
+        @Override
+        public boolean validate(String newValue, String oldValue) {
+            Optional<Block> ignoredBlock = MinecraftServer.getServer()
+                    .registryAccess()
+                    .registryOrThrow(Registries.BLOCK)
+                    .getOptional(ResourceLocation.tryParse(newValue));
+            if (ignoredBlock.isEmpty()) {
+                return false;
+            }
+            CarpetConfig.INSTANCE.structureBlockIgnoredBlock = ignoredBlock.get();
+            return true;
+        }
+
+        @Override
+        public String getErrorMessage(String newValue) {
+            return "Unknown block: " + newValue;
+        }
+    }
+
+    public static class UpdateSuppressionBlockValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue < -1;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "This value represents the amount of updates required before the logger logs them. Must be -1 or larger, but got " + newValue;
+        }
+    }
+
+    public static class WorldBorderValidator extends Validator<Boolean> {
+        @Override
+        public boolean validate(@NotNull Boolean newValue, @NotNull Boolean oldValue) {
+            if (oldValue.booleanValue() != newValue.booleanValue()) {
+                // Needed for the update
+                CarpetConfig.configModule().tickSyncedWorldBorders = newValue;
+                for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                    WorldBorder worldBorder = level.getWorldBorder();
+                    if (worldBorder.getStatus() != BorderStatus.STATIONARY) {
+                        double from = worldBorder.getSize();
+                        double to = worldBorder.getLerpTarget();
+                        long time = worldBorder.getLerpRemainingTime();
+                        worldBorder.lerpSizeBetween(from, to, time);
+                    }
+                }
+            }
+            return true;
+        }
+    }
+
+    public enum Lang {
+        zh_cn, zh_tw, en_us, fr_fr, pt_br
+    }
+
+    public enum ChainStoneMode {
+        TRUE, FALSE, STICK_TO_ALL;
+
+        public boolean enabled() {
+            return this != FALSE;
+        }
+    }
+
+    public enum RenewableCoralMode {
+        FALSE, EXPANDED, TRUE
+    }
+
+    public enum FungusGrowthMode {
+        FALSE, RANDOM, ALL
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/CarpetCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/CarpetCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..5466d7cc56e2bc116a7bf74e12568438fcc73392
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/CarpetCommand.java
@@ -0,0 +1,22 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.ArgumentSuggestions;
+import dev.jorel.commandapi.arguments.GreedyStringArgument;
+
+public class CarpetCommand {
+    private static final String DEPRECATED_TEXT = """
+                                        command /carpet <rule> <value> is deprecated.
+                                        Please use /lumina carpet config <set/get> <node> [value] (for saved changes)
+                                        and /lumina carpet config temp <set/get> <node> [value] (for temp changes)
+                                        """;
+    public static void register() {
+        new CommandAPICommand("carpet")
+                .withArguments(new GreedyStringArgument("deprecated")
+                        .replaceSuggestions(ArgumentSuggestions.strings(
+                                DEPRECATED_TEXT)))
+                .executes((sender, args) -> {
+                    sender.sendMessage(DEPRECATED_TEXT);
+                }).register("carpet");
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/CounterCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/CounterCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1e20094942abb3879ddd7a726ddb5bca3b22ddb
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/CounterCommand.java
@@ -0,0 +1,94 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import dev.jorel.commandapi.executors.CommandArguments;
+import dev.jorel.commandapi.executors.CommandExecutor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.DyeColor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static net.kyori.adventure.text.Component.*;
+
+public class CounterCommand {
+    public static void register() {
+        createBase()
+                .executes((CommandExecutor) (sender, args) -> listAllCounters(sender, false))
+                .register("carpet");
+        createBase()
+                .withArguments(new LiteralArgument("reset"))
+                .executes((CommandExecutor) (sender, args) -> resetCounters(sender))
+                .register("carpet");
+        createBaseWithColorArgument()
+                .executes((CommandExecutor) (sender, args) -> displayCounter(sender, args, false))
+                .register("carpet");
+        createBaseWithColorArgument()
+                .withArguments(new LiteralArgument("reset"))
+                .executes((CommandExecutor) (sender, args) -> resetCounter(sender, (DyeColor) args.get("color")))
+                .register("carpet");
+        createBaseWithColorArgument()
+                .withArguments(new LiteralArgument("realtime"))
+                .executes((CommandExecutor) (sender, args) -> displayCounter(sender, args, true))
+                .register("carpet");
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("counter")
+                .withPermission("carpet.command.counter");
+    }
+
+    private static CommandAPICommand createBaseWithColorArgument() {
+        return createBase()
+                .withArguments(dyeColorArgument("color"));
+    }
+
+    private static void displayCounter(CommandSender sender, @NotNull CommandArguments args, boolean realtime) {
+        HopperCounter counter = HopperCounter.getCounter((DyeColor) args.get("color"));
+
+        for (net.minecraft.network.chat.Component message : counter.format(MinecraftServer.getServer(), realtime, false)) {
+            sender.sendMessage(ComponentUtils.toAdventure(message));
+        }
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    private static void listAllCounters(CommandSender sender, boolean realtime) {
+        for (net.minecraft.network.chat.Component message : HopperCounter.formatAll(MinecraftServer.getServer(), realtime)) {
+            sender.sendMessage(ComponentUtils.toAdventure(message));
+        }
+    }
+
+    private static void resetCounters(@NotNull CommandSender sender) {
+        HopperCounter.resetAll(MinecraftServer.getServer(), false);
+        sender.sendMessage(text("Reset all counters"));
+    }
+
+    private static void resetCounter(@NotNull CommandSender sender, DyeColor color) {
+        HopperCounter.getCounter(color).reset(MinecraftServer.getServer());
+        sender.sendMessage(text("Reset " + color + " counter"));
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    private static @NotNull Argument<DyeColor> dyeColorArgument(String nodeName) {
+        return new CustomArgument<>(new StringArgument(nodeName), info -> {
+            DyeColor color = DYE_COLORS.getOrDefault(info.currentInput(), null);
+            if (color == null) {
+                throw CustomArgument.CustomArgumentException.fromMessageBuilder(
+                        new CustomArgument.MessageBuilder("Unsupported color: ").appendArgInput());
+            } else {
+                return color;
+            }
+        }).replaceSuggestions(ArgumentSuggestions.strings(DYE_COLORS.keySet()));
+    }
+
+    private static final Map<String, DyeColor> DYE_COLORS = new HashMap<>() {{
+        for (DyeColor dyeColor : DyeColor.values()) {
+            put(dyeColor.getName(), dyeColor);
+        }
+    }};
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/DistanceCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/DistanceCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..536d8ecfc07fe0588de7dffadb6527c79747a820
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/DistanceCommand.java
@@ -0,0 +1,83 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+import dev.jorel.commandapi.arguments.LocationArgument;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.utils.DistanceCalculator;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public class DistanceCommand {
+    public static void register() {
+        createBase("from").executesEntity((sender, args) -> {
+            DistanceCalculator.setStart(sender, getVec(sender));
+        }).register("carpet");
+        createBase("from")
+                .withArguments(new LocationArgument("from"))
+                .executes((sender, args) -> {
+                    Location from = (Location) args.get("from");
+                    if (from == null) {
+                        sender.sendMessage(text("Require start location").color(RED));
+                        return;
+                    }
+                    DistanceCalculator.setStart(sender, getVec(from));
+                }).register("carpet");
+        createBase("from")
+                .withArguments(
+                        new LocationArgument("from"),
+                        new LiteralArgument("to")
+                ).withOptionalArguments(new LocationArgument("to"))
+                .executes((sender, args) -> {
+                    Location from = (Location) args.get("from");
+                    if (from == null) {
+                        sender.sendMessage(text("Require start location").color(RED));
+                        return;
+                    }
+                    Location to = (Location) args.get("to");
+                    if (to == null) {
+                        if (sender instanceof Entity entity) {
+                            to = entity.getLocation();
+                        } else {
+                            sender.sendMessage(text("Require end location").color(RED));
+                            return;
+                        }
+                    }
+                    DistanceCalculator.distance(sender, getVec(from), getVec(to));
+                }).register("carpet");
+        createBase("to").executesEntity((sender, args) -> {
+            DistanceCalculator.setEnd(sender, getVec(sender));
+        }).register("carpet");
+        createBase("to")
+                .withArguments(new LocationArgument("to"))
+                .executes((sender, args) -> {
+                    Location to = (Location) args.get("to");
+                    if (to == null) {
+                        sender.sendMessage(text("Require end location").color(RED));
+                        return;
+                    }
+                    DistanceCalculator.setEnd(sender, getVec(to));
+                }).register("carpet");
+    }
+
+    private static CommandAPICommand createBase(String nodeName) {
+        return new CommandAPICommand("distance")
+                .withPermission("carpet.command.distance")
+                .withArguments(new LiteralArgument(nodeName));
+    }
+
+    @Contract("_ -> new")
+    private static @NotNull Vec3 getVec(@NotNull Entity entity) {
+        return getVec(entity.getLocation());
+    }
+
+    @Contract("_ -> new")
+    private static @NotNull Vec3 getVec(@NotNull Location location) {
+        return new Vec3(location.getX(), location.getY(), location.getZ());
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/InfoCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/InfoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..df59f4c3280ed0f4ef33ad24ca9dee8a556d190c
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/InfoCommand.java
@@ -0,0 +1,81 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.BlockInfo;
+import org.leavesmc.lumina.utils.LocationUtils;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static org.leavesmc.lumina.utils.LocationUtils.getSenderWorldOrDefault;
+
+public class InfoCommand {
+    public static void register() {
+        new CommandAPICommand("info")
+                .withPermission("carpet.command.info")
+                .withArguments(
+                        new LiteralArgument("block"),
+                        new LocationArgument("block", LocationType.BLOCK_POSITION)
+                ).withOptionalArguments(
+                        new LiteralArgument("grep").combineWith(new GreedyStringArgument("regexp"))
+                ).executes((sender, args) -> {
+                    infoBlock(sender, (Location) args.get("block"), (String) args.get("regexp"));
+                })
+                .register("carpet");
+    }
+
+    private static void printBlock(List<Component> messages, @NotNull CommandSender sender, String grep) {
+        sender.sendMessage("");
+        if (grep != null) {
+            Pattern p = Pattern.compile(grep);
+            sender.sendMessage(ComponentUtils.toAdventure(messages.getFirst()));
+            for (Component line : messages.subList(1, messages.size())) {
+                Matcher m = p.matcher(line.getString());
+                if (m.find()) {
+                    sender.sendMessage(ComponentUtils.toAdventure(line));
+                }
+            }
+        } else {
+            for (Component message : messages) {
+                sender.sendMessage(ComponentUtils.toAdventure(message));
+            }
+        }
+    }
+
+    private static void infoBlock(@NotNull CommandSender sender, Location pos, String grep) {
+        World world = getSenderWorldOrDefault(sender);
+        if (!sender.hasPermission("carpet.command.info.unloaded")) {
+            //check id pos is loaded
+            if (!world.isChunkGenerated(pos.blockX(), pos.blockZ())) {
+                sender.sendMessage(text("Chunk is not loaded").color(RED));
+                return;
+            }
+            // verify it is in world bounds
+            if (!world.getWorldBorder().isInside(pos)) {
+                sender.sendMessage(text("Position is outside of world bounds").color(RED));
+                return;
+            }
+        }
+        pos.setWorld(world);
+        ServerLevel finalLevel = ((CraftWorld) world).getHandle();
+        Bukkit.getRegionScheduler().run(CarpetServer.PLUGIN, pos,
+                task -> printBlock(
+                        BlockInfo.blockInfo(LocationUtils.toBlockPos(pos), finalLevel),
+                        sender,
+                        grep));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/LogCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/LogCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d26589b452d76147f4ad61927823fa5be7f28c8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/LogCommand.java
@@ -0,0 +1,167 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.ArgumentSuggestions;
+import dev.jorel.commandapi.arguments.EntitySelectorArgument;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+import dev.jorel.commandapi.arguments.StringArgument;
+import dev.jorel.commandapi.executors.CommandArguments;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+
+import java.util.Arrays;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.*;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+
+public class LogCommand {
+    public static void register() {
+        createBase()
+                .withArguments(new LiteralArgument("clear"))
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    unsubFromAll(sender, target);
+                })
+                .register("carpet");
+        createBaseWithLogName()
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    String logName = getLogName(sender, args);
+                    if (logName == null) {
+                        return;
+                    }
+                    toggleSubscription(sender, target, logName);
+                }).register("carpet");
+        createBaseWithLogName()
+                .withArguments(new StringArgument("option"))
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    String logName = getLogName(sender, args);
+                    if (logName == null) {
+                        return;
+                    }
+                    String option = getOption(sender, args, logName);
+                    if (option == null) {
+                        return;
+                    }
+                    subscribePlayer(sender, target, logName, option);
+                }).register("carpet");
+        createBaseWithLogName()
+                .withArguments(new LiteralArgument("clear"))
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    String logName = getLogName(sender, args);
+                    if (logName == null) {
+                        return;
+                    }
+                    unsubFromLogger(sender, target, logName);
+                }).register("carpet");
+
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("log")
+                .withPermission("carpet.command.log");
+    }
+
+    private static CommandAPICommand createBaseWithLogName() {
+        return createBase()
+                .withArguments(new StringArgument("logName")
+                        .replaceSuggestions(ArgumentSuggestions.stringCollection(
+                                info -> LoggerRegistry.getLoggerNames())));
+    }
+
+    private static void unsubFromAll(CommandSender sender, Player target) {
+        for (String logName : LoggerRegistry.getLoggerNames()) {
+            LoggerRegistry.unsubscribePlayer(target.getName(), logName);
+        }
+        sender.sendMessage(text("Unsubscribed from all logs").color(GRAY).style(style(ITALIC)));
+    }
+
+    private static void unsubFromLogger(CommandSender sender, Player target, String logName) {
+        if (LoggerRegistry.getLogger(logName) == null) {
+            sender.sendMessage(text("Unknown logger: " + logName).color(RED));
+            return;
+        }
+        LoggerRegistry.unsubscribePlayer(target.getName(), logName);
+        sender.sendMessage(text("Unsubscribed from " + logName).color(GRAY).style(style(ITALIC)));
+    }
+
+    private static void toggleSubscription(CommandSender sender, Player target, String logName) {
+        if (LoggerRegistry.getLogger(logName) == null) {
+            sender.sendMessage(text("Unknown logger: " + logName).color(RED));
+            return;
+        }
+        boolean subscribed = LoggerRegistry.togglePlayerSubscription(target.getName(), logName);
+        if (subscribed) {
+            sender.sendMessage(text(target.getName() + " subscribed to " + logName + ".").color(GRAY));
+        } else {
+            sender.sendMessage(text(target.getName() + " unsubscribed from " + logName + ".").color(GRAY));
+        }
+    }
+
+    private static void subscribePlayer(CommandSender sender, Player target, String logName, String option) {
+        if (LoggerRegistry.getLogger(logName) == null) {
+            sender.sendMessage(text("Unknown logger: " + logName).color(RED));
+            return;
+        }
+        if (!LoggerRegistry.getLogger(logName).isOptionValid(option)) {
+            sender.sendMessage(text("Invalid option: " + option).color(RED));
+            return;
+        }
+        LoggerRegistry.subscribePlayer(target.getName(), logName, option);
+        if (option != null) {
+            sender.sendMessage(text("Subscribed to " + logName + "(" + option + ")").color(GRAY).style(style(ITALIC)));
+        } else {
+            sender.sendMessage(text("Subscribed to " + logName).color(GRAY).style(style(ITALIC)));
+        }
+    }
+
+    private static @Nullable Player getTarget(CommandSender sender, @NotNull CommandArguments args) {
+        Player target = (Player) args.get("target");
+        if (sender instanceof Player player) {
+            target = player;
+        }
+        if (target == null) {
+            sender.sendMessage(text("Must specified a player when run this in console").color(RED));
+        }
+        return target;
+    }
+
+    private static @Nullable String getLogName(CommandSender sender, @NotNull CommandArguments args) {
+        String logName = (String) args.get("logName");
+        if (logName == null || !LoggerRegistry.getLoggerNames().contains(logName)) {
+            sender.sendMessage(text("No such logger: " + logName).color(RED));
+        }
+        return logName;
+    }
+
+    private static @Nullable String getOption(CommandSender sender, @NotNull CommandArguments args, @NotNull String logName) {
+        String option = (String) args.get("option");
+        if (option == null || !Arrays.asList(LoggerRegistry.getLogger(logName).getOptions()).contains(option)) {
+            sender.sendMessage(text("No such option: " + option).color(RED));
+        }
+        return option;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f673832378af9529a2eb6fe18c25cda7398a5f61
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
@@ -0,0 +1,78 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.EntityTypeArgument;
+import dev.jorel.commandapi.arguments.LocationArgument;
+import dev.jorel.commandapi.arguments.LocationType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.Mob;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.PerimeterDiagnostics;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.*;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+import static org.leavesmc.lumina.utils.LocationUtils.*;
+
+public class PerimeterInfoCommand {
+    public static void register() {
+        createBase().withOptionalArguments(
+                new LocationArgument("center", LocationType.BLOCK_POSITION),
+                new EntityTypeArgument("mob")
+        ).executes((sender, args) -> {
+            Location location = getLocationWithDefaultWorld(sender, args, "center");
+            Bukkit.getRegionScheduler().run(
+                    CarpetServer.PLUGIN,
+                    location,
+                    task -> perimeterDiagnose(sender, location, (String) args.get("mob")));
+        }).register("carpet");
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("perimeterinfo")
+                .withPermission("lumina.command.perimeterinfo");
+    }
+
+    private static void perimeterDiagnose(CommandSender sender, @NotNull Location pos, String mobId) {
+        CompoundTag nbtTagCompound = new CompoundTag();
+        Mob entityliving = null;
+        ServerLevel level = ((CraftWorld) pos.getWorld()).getHandle();
+        BlockPos blockPos = toBlockPos(pos);
+        if (mobId != null) {
+            nbtTagCompound.putString("id", mobId);
+            net.minecraft.world.entity.Entity baseEntity = EntityType.loadEntityRecursive(nbtTagCompound, level, (entity1x) -> {
+                entity1x.moveTo(new BlockPos(blockPos.getX(), level.getMinBuildHeight() - 10, blockPos.getZ()), entity1x.getYRot(), entity1x.getXRot());
+                return !level.addWithUUID(entity1x) ? null : entity1x;
+            });
+            if (!(baseEntity instanceof Mob)) {
+                sender.sendMessage(text("/perimeterinfo requires a mob entity to test against.").color(RED));
+                if (baseEntity != null) {
+                    baseEntity.discard();
+                }
+                return;
+            }
+            entityliving = (Mob) baseEntity;
+        }
+        PerimeterDiagnostics.Result res = PerimeterDiagnostics.countSpots(level, blockPos, entityliving);
+
+        sender.sendMessage(ComponentUtils.toAdventure(Messenger.c("w Spawning spaces around ", Messenger.tp("c", blockPos), "w :")));
+        sender.sendMessage(text().append(text("potential in-liquid: ", WHITE)).append(text(res.liquid).style(style(BOLD))).build());
+        sender.sendMessage(text().append(text("potential on-ground: ", WHITE)).append(text(res.liquid).style(style(BOLD))).build());
+        if (entityliving != null) {
+            sender.sendMessage(text().append(text(entityliving.getDisplayName() + ": ", WHITE)).append(text(res.specific).style(style(BOLD))).build());
+            res.samples.forEach(bp -> sender.sendMessage(ComponentUtils.toAdventure(Messenger.c("w   ", Messenger.tp("c", bp)))));
+            entityliving.discard(); // discard // remove();
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..daa4c1b959a1724453bebba18239ab42cbaeb824
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java
@@ -0,0 +1,447 @@
+package org.leavesmc.lumina.carpet.command;
+
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.ArgumentSuggestions;
+import dev.jorel.commandapi.arguments.GreedyStringArgument;
+
+public class PlayerCommand {
+    private static final String NOT_IMPLEMENTATION_TEXT = """
+                                        command /carpet <rule> <value> is deprecated.
+                                        Please use /lumina carpet config <set/get> <node> [value] (for saved changes)
+                                        and /lumina carpet config temp <set/get> <node> [value] (for temp changes)
+                                        """;
+
+    public static void register() {
+        new CommandAPICommand("player")
+                .withArguments(new GreedyStringArgument("not-implementation")
+                        .replaceSuggestions(ArgumentSuggestions.strings(
+                                NOT_IMPLEMENTATION_TEXT)))
+                .executes((sender, args) -> {
+                    sender.sendMessage(NOT_IMPLEMENTATION_TEXT);
+                }).register("carpet");
+    }
+
+    // public static void register() {
+    //     SubCommandSpawn.register();
+    //     SubCommandKill.register();
+    //     registerActionCommand("use", USE);
+    //     registerActionCommand("jump", JUMP);
+    //     registerActionCommand("attack", ATTACK);
+    //     registerActionCommand("drop", DROP_ITEM);
+    //     registerDropCommand("drop", false);
+    //     registerActionCommand("dropStack", DROP_STACK);
+    //     registerDropCommand("dropStack", true);
+    //     registerActionCommand("swapHands", SWAP_HANDS);
+    //     registerManipulateCommand("mount", ap -> ap.mount(false));
+    //     registerManipulateCommand("mount", ap -> ap.mount(true), "anything");
+    //     registerManipulateCommand("dismount", EntityPlayerActionPack::dismount);
+    //     registerManipulateCommand("sneak", ap -> ap.setSneaking(true));
+    //     registerManipulateCommand("unsneak", ap -> ap.setSneaking(false));
+    //     registerManipulateCommand("sprint", ap -> ap.setSprinting(true));
+    //     registerManipulateCommand("unsprint", ap -> ap.setSprinting(false));
+    //     registerManipulateCommand("stop", EntityPlayerActionPack::stopAll);
+    //     registerSubCommandLook();
+    //     registerSubCommandTurn();
+    //     registerSubCommandMove();
+    //     createBase("shadow")
+    //             .executes((sender, args) -> {
+    //                 if (!canManipulate(sender, args, "shadow")) {
+    //                     return;
+    //                 }
+    //
+    //                 ServerPlayer player = getOnlineServerPlayer(args);
+    //                 if (player instanceof EntityPlayerMPFake) {
+    //                     sender.sendMessage(text("Cannot shadow fake players").color(RED));
+    //                     return;
+    //                 }
+    //                 if (MinecraftServer.getServer().isSingleplayerOwner(player.getGameProfile())) {
+    //                     sender.sendMessage(text("Cannot shadow single-player server owner").color(RED));
+    //                     return;
+    //                 }
+    //
+    //                 EntityPlayerMPFake.createShadow(player.server, player);
+    //             }).register("carpet");
+    //     // noinspection DataFlowIssue
+    //     createBase("hotbar")
+    //             .withArguments(new IntegerArgument("slot", 0, 8))
+    //             .executes((CommandExecutor) (sender, args) ->
+    //                     manipulate(sender, args, "hotbar",
+    //                             ap -> ap.setSlot((Integer) args.get("slot"))))
+    //             .register("carpet");
+    //     registerPermissions();
+    // }
+    //
+    // private static void registerPermissions() {
+    //     PermissionUtils.addPermissionAndBind(
+    //             "carpet.command.player",
+    //             "Player command",
+    //             List.of(
+    //                     "&.spawn",
+    //                     "&.kill",
+    //                     "&.shadow",
+    //                     "&.use",
+    //                     "&.jump",
+    //                     "&.attack",
+    //                     "&.drop",
+    //                     "&.dropStack",
+    //                     "&.swapHands",
+    //                     "&.hotbar",
+    //                     "&.mount",
+    //                     "&.dismount",
+    //                     "&.sneak",
+    //                     "&.unsneak",
+    //                     "&.sprint",
+    //                     "&.unsprint",
+    //                     "&.look",
+    //                     "&.turn",
+    //                     "&.move",
+    //                     "&.stop",
+    //                     "&.manipulate-real"
+    //             )
+    //     );
+    //     PermissionUtils.addPermissionAndBind(
+    //             createPlayerCommandPermission("look"),
+    //             "Look to a direction",
+    //             List.of(
+    //                     "&.north",
+    //                     "&.south",
+    //                     "&.east",
+    //                     "&.west",
+    //                     "&.up",
+    //                     "&.down",
+    //                     "&.at",
+    //                     "&.direction"
+    //             )
+    //     );
+    //     PermissionUtils.addPermissionAndBind(
+    //             createPlayerCommandPermission("turn"),
+    //             "Turn to a direction",
+    //             List.of(
+    //                     "&.left",
+    //                     "&.right",
+    //                     "&.back",
+    //                     "&.rotation"
+    //             )
+    //     );
+    //     PermissionUtils.addPermissionAndBind(
+    //             createPlayerCommandPermission("move"),
+    //             "Move to a direction",
+    //             List.of(
+    //                     "&.forward",
+    //                     "&.backward",
+    //                     "&.left",
+    //                     "&.right"
+    //             )
+    //     );
+    // }
+    //
+    // private static class SubCommandSpawn {
+    //     public static void register() {
+    //         createBase("spawn")
+    //                 .withOptionalArguments(
+    //                         new LiteralArgument("at").combineWith(new LocationArgument("position")),
+    //                         new LiteralArgument("facing").combineWith(new RotationArgument("direction")),
+    //                         new LiteralArgument("in").combineWith(new WorldArgument("dimension")),
+    //                         new LiteralArgument("in")
+    //                                 .withRequirement(ServerOperator::isOp)
+    //                                 .combineWith(new MultiLiteralArgument("gamemode", Arrays
+    //                                         .stream(GameType.values())
+    //                                         .map(GameType::name)
+    //                                         .toArray(String[]::new)))
+    //                 ).executes(SubCommandSpawn::spawn).register("carpet");
+    //     }
+    //
+    //     private static void spawn(CommandSender sender, CommandArguments args) {
+    //         if (!canSpawn(sender, args)) {
+    //             return;
+    //         }
+    //         Location pos = null;
+    //         Rotation facing = new Rotation(0, 0);
+    //         World world = Bukkit.getWorlds().getFirst();
+    //         GameType mode = GameType.CREATIVE;
+    //         boolean flying = false;
+    //         if (sender instanceof Player player) {
+    //             ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+    //             pos = player.getLocation();
+    //             facing = new Rotation(player.getLocation().getYaw(), player.getLocation().getPitch());
+    //             world = player.getWorld();
+    //             mode = serverPlayer.gameMode.getGameModeForPlayer();
+    //             flying = serverPlayer.getAbilities().flying;
+    //         }
+    //         pos = (Location) args.getOrDefault("position", pos);
+    //         facing = (Rotation) args.getOrDefault("direction", facing);
+    //         world = (World) args.getOrDefault("dimension", world);
+    //         if (pos == null) {
+    //             sender.sendMessage(text("Need position to spawn player in console").color(RED));
+    //             return;
+    //         }
+    //         pos.setWorld(world);
+    //         GameMode nullableGameMode = (GameMode) args.get("gamemode");
+    //         if (nullableGameMode != null) {
+    //             mode = GameType.byId(nullableGameMode.getValue());
+    //         }
+    //
+    //         if (mode == GameType.SPECTATOR) {
+    //             // Force override flying to true for spectator players, or they will fell out of the world.
+    //             flying = true;
+    //         } else if (mode.isSurvival()) {
+    //             // Force override flying to false for survival-like players, or they will fly too
+    //             flying = false;
+    //         }
+    //         String playerName = getPlayerName(args);
+    //         if (playerName.length() > SharedConstants.MAX_PLAYER_NAME_LENGTH) {
+    //             sender.sendMessage(text("Player name: " + playerName + " is too long").color(RED));
+    //             return;
+    //         }
+    //
+    //         if (!Level.isInSpawnableBounds(BlockPos.containing(pos.getX(), pos.getY(), pos.getZ()))) {
+    //             sender.sendMessage(text("Player " + playerName + " cannot be placed outside of the world").color(RED));
+    //             return;
+    //         }
+    //         boolean success = EntityPlayerMPFake.createFake(playerName, MinecraftServer.getServer(), pos, facing.getPitch(), facing.getYaw(), world, mode, flying);
+    //         if (!success) {
+    //             sender.sendMessage(text("Player " + playerName + " doesn't exist and cannot spawn in online mode. Turn the server offline or the allowSpawningOfflinePlayers on to spawn non-existing players").color(RED));
+    //         }
+    //     }
+    //
+    //     private static boolean canSpawn(CommandSender sender, CommandArguments args) {
+    //         String playerName = getPlayerName(args);
+    //         MinecraftServer server = MinecraftServer.getServer();
+    //         PlayerList manager = server.getPlayerList();
+    //
+    //         if (manager.getPlayerByName(playerName) != null) {
+    //             sender.sendMessage(text("Player " + playerName + " is already logged on").color(RED));
+    //             return false;
+    //         }
+    //         @SuppressWarnings("DataFlowIssue") GameProfile profile = server.getProfileCache().get(playerName).orElse(null);
+    //         if (profile == null) {
+    //             // if (!CarpetConfig.configModule().allowSpawningOfflinePlayers) {
+    //                 sender.sendMessage(text("Player " + playerName + " is either banned by Mojang, or auth servers are down. Banned players can only be summoned in Singleplayer and in servers in off-line mode.").color(RED));
+    //                 return false;
+    //             // } else {
+    //             //     profile = new GameProfile(UUIDUtil.createOfflinePlayerUUID(playerName), playerName);
+    //             // }
+    //         }
+    //         if (manager.getBans().isBanned(profile)) {
+    //             sender.sendMessage(text("Player" + playerName + "is banned on this server").color(RED));
+    //             return false;
+    //         }
+    //         if (manager.isUsingWhitelist() && manager.isWhiteListed(profile) && !sender.isOp()) {
+    //             sender.sendMessage(text("Whitelisted players can only be spawned by operators").color(RED));
+    //             return false;
+    //         }
+    //         return true;
+    //     }
+    // }
+    //
+    // private static class SubCommandKill {
+    //     public static void register() {
+    //         createBase("kill")
+    //                 .executes(SubCommandKill::kill)
+    //                 .register("carpet");
+    //     }
+    //
+    //     private static void kill(CommandSender sender, CommandArguments args) {
+    //         if (!canKill(sender, args)) {
+    //             return;
+    //         }
+    //         Player player = getOnlinePlayer(args);
+    //         ((CraftPlayer) player).getHandle().kill();
+    //         sender.sendMessage(text("Player " + player.getName() + " has been killed").color(GREEN));
+    //     }
+    //
+    //     private static boolean canKill(CommandSender sender, CommandArguments args) {
+    //         ServerPlayer player = getOnlineServerPlayer(args);
+    //         if (player instanceof EntityPlayerMPFake) {
+    //             return canManipulate(sender, args, "kill");
+    //         }
+    //         sender.sendMessage(text("Only fake players can be killed by this command").color(RED));
+    //         return false;
+    //     }
+    // }
+    //
+    // private static void registerSubCommandLook() {
+    //     registerManipulateCommand("look", ap -> ap.look(Direction.NORTH), "north");
+    //     registerManipulateCommand("look", ap -> ap.look(Direction.SOUTH), "south");
+    //     registerManipulateCommand("look", ap -> ap.look(Direction.EAST), "east");
+    //     registerManipulateCommand("look", ap -> ap.look(Direction.WEST), "west");
+    //     registerManipulateCommand("look", ap -> ap.look(Direction.UP), "up");
+    //     registerManipulateCommand("look", ap -> ap.look(Direction.DOWN), "down");
+    //     createBase("look")
+    //             .withArguments(
+    //                     new LiteralArgument("direction"),
+    //                     new RotationArgument("direction")
+    //             ).executes((CommandExecutor) (sender, args) ->
+    //                     manipulate(sender, args, "look",
+    //                             ap -> {
+    //                                 Rotation rotation = (Rotation) args.get("direction");
+    //                                 if (rotation == null) {
+    //                                     sender.sendMessage(text("Invalid rotation").color(RED));
+    //                                     return;
+    //                                 }
+    //                                 ap.look(new Vec2(rotation.getYaw(), rotation.getPitch()));
+    //                             })
+    //             ).register("carpet");
+    //     createBase("look")
+    //             .withArguments(
+    //                     new LiteralArgument("at"),
+    //                     new LocationArgument("position")
+    //             ).executes((CommandExecutor) (sender, args) ->
+    //                     manipulate(sender, args, "look",
+    //                             ap -> {
+    //                                 Location location = getLocationWithDefaultWorld(sender, args, "position");
+    //                                 ap.lookAt(new Vec3(location.getX(), location.getY(), location.getZ()));
+    //                             })
+    //             ).register("carpet");
+    // }
+    //
+    // private static void registerSubCommandTurn() {
+    //     registerManipulateCommand("turn", ap -> ap.turn(-90, 0), "left");
+    //     registerManipulateCommand("turn", ap -> ap.turn(90, 0), "right");
+    //     registerManipulateCommand("turn", ap -> ap.turn(180, 0), "back");
+    //     createBase("turn")
+    //             .withArguments(new RotationArgument("rotation"))
+    //             .executes((CommandExecutor) (sender, args) ->
+    //                     manipulate(sender, args, "turn",
+    //                             ap -> {
+    //                                 Rotation rotation = (Rotation) args.get("rotation");
+    //                                 if (rotation == null) {
+    //                                     sender.sendMessage(text("Invalid rotation").color(RED));
+    //                                     return;
+    //                                 }
+    //                                 ap.turn(rotation.getYaw(), rotation.getPitch());
+    //                             })
+    //             ).register("carpet");
+    // }
+    //
+    // private static void registerSubCommandMove() {
+    //     registerManipulateCommand("move", EntityPlayerActionPack::stopMovement);
+    //     registerManipulateCommand("move", EntityPlayerActionPack::stopMovement, "stop");
+    //     registerManipulateCommand("move", ap -> ap.setForward(1), "forward");
+    //     registerManipulateCommand("move", ap -> ap.setForward(-1), "backward");
+    //     registerManipulateCommand("move", ap -> ap.setStrafing(-1), "right");
+    //     registerManipulateCommand("move", ap -> ap.setStrafing(1), "left");
+    // }
+    //
+    // private static void registerManipulateCommand(String name, Consumer<EntityPlayerActionPack> action, String literal) {
+    //     createBase(name)
+    //             .withArguments(new MultiLiteralArgument("_literals", literal))
+    //             .executes((CommandExecutor) (sender, args2) -> manipulate(sender, args2, name, action))
+    //             .register("carpet");
+    // }
+    //
+    // private static void registerManipulateCommand(String name, Consumer<EntityPlayerActionPack> action) {
+    //     createBase(name)
+    //             .executes((CommandExecutor) (sender, args2) -> manipulate(sender, args2, name, action))
+    //             .register("carpet");
+    // }
+    //
+    // private static void registerActionCommand(String name, ActionType type) {
+    //     registerManipulateCommand(name, ap -> ap.start(type, Action.once()));
+    //     registerManipulateCommand(name, ap -> ap.start(type, Action.once()), "once");
+    //     registerManipulateCommand(name, ap -> ap.start(type, Action.continuous()), "continuous");
+    //     // noinspection DataFlowIssue
+    //     createBase(name)
+    //             .withArguments(
+    //                     new LiteralArgument("interval"),
+    //                     new IntegerArgument("ticks", 1)
+    //             ).executes((CommandExecutor) (sender, args) ->
+    //                     manipulate(sender, args, name,
+    //                             ap -> ap.start(type, Action.interval((Integer) args.get("ticks"))))
+    //             ).register("carpet");
+    // }
+    //
+    // private static void registerDropCommand(String name, boolean dropAll) {
+    //     registerManipulateCommand(name, ap -> ap.drop(-2, dropAll), "all");
+    //     registerManipulateCommand(name, ap -> ap.drop(-1, dropAll), "mainhand");
+    //     registerManipulateCommand(name, ap -> ap.drop(40, dropAll), "offhand");
+    //     // noinspection DataFlowIssue
+    //     createBase(name)
+    //             .withArguments(new IntegerArgument("slot", 0, 40))
+    //             .executes((CommandExecutor) (sender, args) ->
+    //                     manipulate(sender, args, name,
+    //                             ap -> ap.drop((Integer) args.get("slot"), dropAll))
+    //             ).register("carpet");
+    //
+    // }
+    //
+    // private static void manipulate(CommandSender sender, CommandArguments args, String name, Consumer<EntityPlayerActionPack> action) {
+    //     if (!canManipulate(sender, args, name)) {
+    //         return;
+    //     }
+    //     action.accept(getOnlineServerPlayer(args).getActionPack());
+    // }
+    //
+    // private static CommandAPICommand createBase(String literal) {
+    //     return new CommandAPICommand("player")
+    //             .withPermission("carpet.command.player")
+    //             .withArguments(
+    //                     new StringArgument("player").replaceSuggestions(ArgumentSuggestions.strings(info ->
+    //                             MinecraftServer
+    //                                     .getServer()
+    //                                     .getPlayerList()
+    //                                     .getPlayers()
+    //                                     .stream().map(ServerPlayer::getScoreboardName)
+    //                                     .toArray(String[]::new))),
+    //                     new LiteralArgument(literal)
+    //             ).withPermission(createPlayerCommandPermission(literal));
+    // }
+    //
+    // private static boolean canManipulate(@NotNull CommandSender sender, CommandArguments args, String name) {
+    //     String permission = createPlayerCommandPermission(name);
+    //     if (sender.hasPermission(permission)) {
+    //         Player player = getOnlinePlayer(args);
+    //         if (sender == player || player instanceof EntityPlayerMPFake) {
+    //             return true;
+    //         }
+    //         String manipulateRealPermission = createPlayerCommandPermission("manipulate-real");
+    //         if (sender.hasPermission(manipulateRealPermission)) {
+    //             return true;
+    //         }
+    //         permission = permission + " and " + manipulateRealPermission;
+    //     }
+    //     sender.sendMessage(text("Require permission: " + permission).color(RED));
+    //     return false;
+    // }
+    //
+    // private static @NotNull Player getOnlinePlayer(CommandArguments args) {
+    //     String playerName = getPlayerName(args);
+    //     Player player = Bukkit.getPlayer(playerName);
+    //     if (player == null) {
+    //         throw CommandAPIBukkit.failWithAdventureComponent(text("No such player").color(RED));
+    //     }
+    //     return player;
+    // }
+    //
+    // private static @NotNull ServerPlayer getOnlineServerPlayer(CommandArguments args) {
+    //     String playerName = getPlayerName(args);
+    //     ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayerByName(playerName);
+    //     if (player == null) {
+    //         throw CommandAPIBukkit.failWithAdventureComponent(text("No such player").color(RED));
+    //     }
+    //     return player;
+    // }
+    //
+    // private static @NotNull String getPlayerName(@NotNull CommandArguments args) {
+    //     String playerName = (String) args.get("player");
+    //     if (playerName == null) {
+    //         throw CommandAPIBukkit.failWithAdventureComponent(text("Require player name").color(RED));
+    //     }
+    //     String prefix = CarpetConfig.configModule().fakePlayerNamePrefix;
+    //     String suffix = CarpetConfig.configModule().fakePlayerNameSuffix;
+    //     if ("#none".equals(prefix)) {
+    //         prefix = "";
+    //     }
+    //     if ("#none".equals(suffix)) {
+    //         suffix = "";
+    //     }
+    //     return prefix + playerName + suffix;
+    // }
+    //
+    // @Contract(pure = true)
+    // private static @NotNull String createPlayerCommandPermission(String sub) {
+    //     return "carpet.command.player." + sub;
+    // }
+
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/SpawnCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/SpawnCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f43eadcff973f176275d87610b2fed1262a820f6
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/SpawnCommand.java
@@ -0,0 +1,82 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+import dev.jorel.commandapi.arguments.LocationArgument;
+import dev.jorel.commandapi.arguments.LocationType;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.SpawnReporter;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.*;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+import static org.leavesmc.lumina.utils.ComponentUtils.toAdventure;
+import static org.leavesmc.lumina.utils.LocationUtils.*;
+
+public class SpawnCommand {
+    public static void register() {
+        createBase("list")
+                .withArguments(new LocationArgument("pos", LocationType.BLOCK_POSITION))
+                .executes((sender, args) -> {
+                    listSpawns(sender, ((Location) args.get("pos")));
+                })
+                .register("carpet");
+        if(true) return; // TODO: Implement this
+        createBase("tracking")
+                .withArguments(new LiteralArgument("start"))
+                .withOptionalArguments(
+                        new LocationArgument("from", LocationType.BLOCK_POSITION)
+                                .combineWith(new LocationArgument("to", LocationType.BLOCK_POSITION))
+                ).executes((sender, args) -> {
+                    if (SpawnReporter.trackingSpawns()) {
+                        sender.sendMessage(text("Spawning tracking already started.").color(RED));
+                        return;
+                    }
+                    Location from = (Location) args.get("from");
+                    Location to = (Location) args.get("to");
+                    if (from == null && to == null) {
+                        SpawnReporter.startTracking(MinecraftServer.getServer(), null);
+                        sender.sendMessage(text("Spawning tracking started.").color(GRAY).style(style(ITALIC)));
+                        return;
+                    }
+                    if (from == null || to == null) {
+                        sender.sendMessage(text("Please specify the area to track an area or call `/spawn tracking start` to track all area)").color(RED));
+                        return;
+                    }
+                    SpawnReporter.startTracking(
+                            MinecraftServer.getServer(),
+                            BoundingBox.fromCorners(toBlockPos(from), toBlockPos(to)));
+                    sender.sendMessage(text("Spawning tracking started.").color(GRAY).style(style(ITALIC)));
+                })
+                .register("carpet");
+        createBase("tracking")
+                .withArguments(new LiteralArgument("stop"))
+                .executes(((sender, args) -> {
+                    for (Component component : SpawnReporter.makeTrackingReport(getLevel(getSenderWorldOrDefault(sender)))) {
+                        sender.sendMessage(toAdventure(component));
+                    }
+                    SpawnReporter.stopTracking(MinecraftServer.getServer());
+                    sender.sendMessage(text("Spawning tracking stopped.").color(GRAY).style(style(ITALIC)));
+                }))
+                .register("carpet");
+    }
+
+    private static CommandAPICommand createBase(String literal) {
+        return new CommandAPICommand("spawn")
+                .withPermission("carpet.command.spawn")
+                .withArguments(new LiteralArgument(literal));
+    }
+
+    private static void listSpawns(CommandSender sender, Location pos) {
+
+        for (Component component : SpawnReporter.report(toBlockPos(pos), getLevel(pos))) {
+            sender.sendMessage(toAdventure(component));
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/TrackCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/TrackCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ae1870a9e6b19cfc750b93feb189c1854e35565
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/TrackCommand.java
@@ -0,0 +1,74 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import org.leavesmc.lumina.carpet.utils.MobAI;
+import org.leavesmc.lumina.carpet.utils.MobAI.TrackingType;
+
+import java.util.Map;
+import java.util.Set;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static org.leavesmc.lumina.carpet.utils.MobAI.TrackingType.*;
+
+public class TrackCommand {
+    public static void register() {
+        createBase()
+                .withArguments(new LiteralArgument("clear"))
+                .executes((sender, args) -> {
+                    System.out.println(args.get("type"));
+                    MobAI.clearTracking(MinecraftServer.getServer(), (EntityType<? extends Entity>) args.get("type"));
+                    return 1;
+                }).register("carpet");
+        createBase()
+                .withArguments(new StringArgument("aspect").replaceSuggestions(
+                        ArgumentSuggestions.strings(info ->
+                                ASPECTS.get((EntityType<?>) info.previousArgs().get("type")).toArray(new String[0])))
+                ).executes((sender, args) -> {
+                    String aspectStr = (String) args.get("aspect");
+                    if (aspectStr == null) {
+                        sender.sendMessage(text("Aspect is required").color(RED));
+                        return;
+                    }
+                    try {
+                        TrackingType aspect = valueOf(aspectStr.toUpperCase());
+                        MobAI.startTracking((EntityType<?>) args.get("type"), aspect);
+                    } catch (IllegalArgumentException ignored) {
+                        sender.sendMessage(text("Invalid aspect: ").append(text(aspectStr).color(RED)));
+                    }
+
+                }).register("carpet");
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("track")
+                .withPermission("lumina.command.track")
+                .withArguments(trackTypeArgument("type"));
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    public static Argument<EntityType<? extends Entity>> trackTypeArgument(String nodeName) {
+        return new CustomArgument<EntityType<? extends Entity>, String>(new StringArgument(nodeName), info -> {
+            EntityType<? extends Entity> type = ENTITY_TYPES.getOrDefault(info.currentInput(), null);
+            if (type == null) {
+                throw CustomArgument.CustomArgumentException.fromMessageBuilder(
+                        new CustomArgument.MessageBuilder("Unsupported entity type: ").appendArgInput());
+            } else {
+                return type;
+            }
+        }).replaceSuggestions(ArgumentSuggestions.strings("villager"));
+    }
+
+    private static final Map<String, EntityType<? extends Entity>> ENTITY_TYPES = Map.of(
+            "villager", EntityType.VILLAGER
+    );
+
+    @SuppressWarnings("MapOrSetKeyShouldOverrideHashCodeEquals")
+    private static final Map<EntityType<? extends Entity>, Set<String>> ASPECTS = Map.of(
+            EntityType.VILLAGER, Set.of("breeding", "iron_golem_spawning")
+    );
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/AbstractConfig.java b/src/main/java/org/leavesmc/lumina/config/AbstractConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..adc447520bd6f77147dfd980eff5180a63c6e264
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/AbstractConfig.java
@@ -0,0 +1,317 @@
+package org.leavesmc.lumina.config;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.ArgumentSuggestions;
+import dev.jorel.commandapi.arguments.GreedyStringArgument;
+import dev.jorel.commandapi.arguments.StringArgument;
+import dev.jorel.commandapi.executors.CommandArguments;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.utils.ConfigUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.loader.ConfigurationLoader;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.DARK_GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public abstract class AbstractConfig<M, N extends ConfigurationNode> {
+    private final Logger logger;
+    protected volatile M configModule, fileModule, tempModule;
+    public Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+    private N node;
+    private final ConfigurationLoader<@NotNull N> loader;
+    private final Class<M> moduleClass;
+    private final String name, permissionParent;
+
+    protected AbstractConfig() {
+        this.moduleClass = getConfigModuleClass();
+        this.loader = getConfigLoader();
+        this.name = getName();
+        this.permissionParent = getPermissionParent();
+        this.logger = LoggerFactory.getLogger(name + "Config");
+        init();
+    }
+
+    protected void init() {
+        loadConfig();
+        saveConfig();
+    }
+
+    protected abstract ConfigurationLoader<@NotNull N> getConfigLoader();
+
+    protected abstract Class<M> getConfigModuleClass();
+
+    protected abstract String getName();
+
+    protected abstract String getPermissionParent();
+
+    public CommandAPICommand generateConfigCommand() {
+        String[] configNodes = nodeInfos.keySet().toArray(new String[0]);
+        return new CommandAPICommand("config")
+                .withSubcommand(generateSetSubCommand(false, configNodes))
+                .withSubcommand(new CommandAPICommand("get")
+                        .withPermission(permissionParent + ".config.get")
+                        .withArguments(new StringArgument("node")
+                                .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                        ).executes((sender, args) -> {
+                            String node = (String) args.get("node");
+                            ConfigNodeInfo nodeInfo = nodeInfos.getOrDefault(node, null);
+                            if (node == null || nodeInfo == null) {
+                                sender.sendMessage(text("No config node specified.").color(RED));
+                                return;
+                            }
+                            try {
+                                sender.sendMessage(text("The value of " + node + " is " + nodeInfo.field().get(nodeInfo.parent())));
+                            } catch (IllegalAccessException e) {
+                                throw new RuntimeException("Please report this to Lumina developers: " + e);
+                            }
+                        })
+                ).withSubcommand(new CommandAPICommand("reload")
+                        .withPermission(permissionParent + ".config.reload")
+                        .executes((sender, args) -> {
+                            sender.sendMessage(text("Reloading " + name + " config...").color(DARK_GREEN));
+                            if (!(sender instanceof ConsoleCommandSender)) {
+                                logger.info("Reloading {} config...", name);
+                            }
+                            loadConfigAsync().thenApply((Void ignored) -> {
+                                sender.sendMessage(text(name + " config reloaded.").color(DARK_GREEN));
+                                if (!(sender instanceof ConsoleCommandSender)) {
+                                    logger.info("{} config reloaded.", name);
+                                }
+                                return null;
+                            });
+                        })
+                ).withSubcommand(new CommandAPICommand("save")
+                        .withPermission(permissionParent + ".config.set") // Cause `set` also called save, so use the same permission node
+                        .executes((sender, args) -> {
+                            sender.sendMessage(text("Saving " + name + " config...").color(DARK_GREEN));
+                            if (!(sender instanceof ConsoleCommandSender)) {
+                                logger.info("Saving {} config...", name);
+                            }
+                            saveConfigAsync().thenApply((Void ignored) -> {
+                                sender.sendMessage(text(name + " config saved.").color(DARK_GREEN));
+                                if (!(sender instanceof ConsoleCommandSender)) {
+                                    logger.info("{} config saved.", name);
+                                }
+                                return null;
+                            });
+                        })
+                ).withSubcommand(new CommandAPICommand("temp")
+                        .withSubcommand(generateSetSubCommand(true, configNodes))
+                        .withSubcommand(new CommandAPICommand("clear")
+                                .withPermission(permissionParent + ".config.set")
+                        )
+                );
+    }
+
+    private CommandAPICommand generateSetSubCommand(boolean temp, String[] configNodes) {
+        return new CommandAPICommand("set")
+                .withPermission(permissionParent + ".config.set")
+                .withArguments(new StringArgument("node")
+                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                ).withArguments(new GreedyStringArgument("value")
+                        .replaceSuggestions(ArgumentSuggestions.strings(info -> {
+                            String node = (String) info.previousArgs().get("node");
+                            ConfigNodeInfo nodeInfo = nodeInfos.getOrDefault(node, null);
+                            if (node == null || node.isEmpty() || nodeInfo == null) {
+                                return new String[]{};
+                            }
+                            return nodeInfo.suggestions();
+                        }))
+                ).executes((sender, args) -> {
+                    String node = (String) args.get("node");
+                    ConfigNodeInfo nodeInfo = nodeInfos.getOrDefault(node, null);
+                    setValueInternal(node, nodeInfo, sender, args, temp);
+                });
+    }
+
+    protected void generateNodeInfos() {
+        try {
+            ConfigUtils.generateNodeInfos(nodeInfos, moduleClass, null, configModule, fileModule, tempModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public M getConfigModule() {
+        return configModule;
+    }
+
+    public M getFileModule() {
+        return fileModule;
+    }
+
+    public M getTempModule() {
+        return tempModule;
+    }
+
+    public void mergeConfig() {
+        try {
+            node.set(fileModule);
+            node.from(loader.createNode().set(moduleClass, tempModule));
+            configModule = node.get(moduleClass);
+            generateNodeInfos();
+        } catch (SerializationException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void loadConfig() {
+        try {
+            node = loader.load();
+            configModule = node.get(moduleClass);
+            fileModule = node.get(moduleClass);
+            tempModule = loader.createNode().get(moduleClass);
+            generateNodeInfos();
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void saveConfig() {
+        try {
+            node.set(moduleClass, fileModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public @NotNull CompletableFuture<Void> loadConfigAsync() {
+        return ConfigUtils.runAsync(this::loadConfig);
+    }
+
+    @Contract(" -> new")
+    public @NotNull CompletableFuture<Void> saveConfigAsync() {
+        return ConfigUtils.runAsync(this::saveConfig);
+    }
+
+    private void setValueInternal(String node, ConfigNodeInfo nodeInfo, CommandSender sender, CommandArguments args, boolean temp) {
+        if (node == null || nodeInfo == null) {
+            sender.sendMessage(text("No config node specified.").color(RED));
+            return;
+        }
+        String value = (String) args.get("value");
+        Class<?> type = nodeInfo.type();
+        Object fileParent = nodeInfo.fileParent();
+        Object tempParent = nodeInfo.tempParent();
+        if (value == null || value.isEmpty()) {
+            sender.sendMessage(text("No value specified, expected: " + type.getSimpleName()).color(RED));
+            return;
+        }
+        try {
+            if (type.isEnum()) {
+                @SuppressWarnings({"unchecked", "rawtypes"})
+                Class<? extends Enum> enumType = (Class<? extends Enum>) type;
+                try {
+                    @SuppressWarnings("unchecked")
+                    Object enumValue = Enum.valueOf(enumType, value);
+                    nodeInfo.field().set(tempParent, enumValue);
+                    if (!temp) nodeInfo.field().set(fileParent, enumValue);
+                } catch (IllegalArgumentException ignored) {
+                    sender.sendMessage(text("Expected enum " + Arrays.toString(nodeInfo.suggestions()) + ", but entered: " + value).color(RED));
+                    return;
+                }
+            } else {
+                switch (type.getSimpleName()) {
+                    case "boolean" -> {
+                        boolean newValue;
+                        if ("true".equals(value)) {
+                            newValue = true;
+                        } else if ("false".equals(value)) {
+                            newValue = false;
+                        } else {
+                            sender.sendMessage(text("Expected boolean, but entered: " + value).color(RED));
+                            return;
+                        }
+                        Validator.ValidationResult result = Validator.validateBoolean(nodeInfo, newValue);
+                        if (result.type() != Validator.ValidationResultType.PASS) {
+                            sender.sendMessage(text(result.message()).color(RED));
+                            return;
+                        }
+                        nodeInfo.field().setBoolean(tempParent, newValue);
+                        if (!temp) nodeInfo.field().setBoolean(fileParent, newValue);
+                    }
+                    case "int" -> {
+                        try {
+                            int newValue = Integer.parseInt(value);
+                            Validator.ValidationResult result = Validator.validateInteger(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setInt(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setInt(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected int, but entered: " + value).color(RED));
+                            return;
+                        }
+                    }
+                    case "long" -> {
+                        try {
+                            long newValue = Long.parseLong(value);
+                            Validator.ValidationResult result = Validator.validateLong(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setLong(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setLong(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected long, but entered: " + value).color(RED));
+                            return;
+                        }
+                    }
+                    case "double" -> {
+                        try {
+                            double newValue = Double.parseDouble(value);
+                            Validator.ValidationResult result = Validator.validateDouble(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setDouble(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setDouble(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected double, but entered: " + value).color(RED));
+                            return;
+                        }
+                    }
+                    case "String" -> {
+                        Validator.ValidationResult result = Validator.validateString(nodeInfo, value);
+                        if (result.type() != Validator.ValidationResultType.PASS) {
+                            sender.sendMessage(text(result.message()).color(RED));
+                            return;
+                        }
+                        nodeInfo.field().set(tempParent, value);
+                        if (!temp) nodeInfo.field().set(fileParent, value);
+                    }
+                    default -> throw new IllegalStateException("Please report this to Lumina developers: unexpected config field type " + type.getName());
+                }
+            }
+            mergeConfig();
+            sender.sendMessage(text("Set " + node + " to " + value + (temp ? " temporary" : "")).color(DARK_GREEN));
+            if (!temp && LuminaConfig.configModule().misc.saveConfigAfterSet) {
+                saveConfigAsync().thenApply((Void ignored) -> {
+                    logger.info("Saved {} config after setting {} to {}", name, node, value);
+                    return null;
+                });
+            }
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Please report this to Lumina developers: " + e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..82aaa736e5e502b18d6cc758a9be4369493db295
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config;
+
+import java.lang.reflect.Field;
+
+public record ConfigNodeInfo(
+        String[] suggestions,
+        Class<?> type,
+        Field field,
+        Object parent, Object fileParent, Object tempParent,
+        Validator<?> validator) {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1fe628ebb2c71c84a0fe5a385f98f7a214426b9
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
@@ -0,0 +1,55 @@
+package org.leavesmc.lumina.config;
+
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+import org.spongepowered.configurate.loader.ConfigurationLoader;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public class LuminaConfig extends AbstractConfig<LuminaConfigModule, CommentedConfigurationNode> {
+    public static final LuminaConfig INSTANCE = new LuminaConfig();
+
+    public static LuminaConfigModule configModule() {
+        return INSTANCE.getConfigModule();
+    }
+
+    @Override
+    protected ConfigurationLoader<@NotNull CommentedConfigurationNode> getConfigLoader() {
+        Path hoconConfigPath = Path.of("lumina.conf");
+        boolean useHocon = Boolean.getBoolean("lumina.config.style.hocon") || Files.exists(hoconConfigPath);
+        boolean jsonStyle = Boolean.getBoolean("lumina.config.style.json");
+        if (useHocon || jsonStyle) {
+            return HoconConfigurationLoader.builder()
+                    .emitComments(true)
+                    .emitJsonCompatible(jsonStyle)
+                    .prettyPrinting(true)
+                    .path(hoconConfigPath)
+                    .build();
+        } else {
+            return YamlConfigurationLoader.builder()
+                    .nodeStyle(NodeStyle.BLOCK)
+                    .indent(2)
+                    .path(Path.of("lumina.yml"))
+                    .build();
+        }
+    }
+
+    @Override
+    protected Class<LuminaConfigModule> getConfigModuleClass() {
+        return LuminaConfigModule.class;
+    }
+
+    @Override
+    protected String getName() {
+        return "Lumina";
+    }
+
+    @Override
+    protected String getPermissionParent() {
+        return "lumina";
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c2bf30ef6035575e56c8743f1abee8ac8b8d558
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config;
+
+import org.leavesmc.lumina.config.modules.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LuminaConfigModule {
+    public String configVersion = "1";
+    public Fix fix = new Fix();
+    public Protocol protocol = new Protocol();
+    public Performance performance = new Performance();
+    public Modify modify = new Modify();
+    public Misc misc = new Misc();
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/Validator.java b/src/main/java/org/leavesmc/lumina/config/Validator.java
new file mode 100644
index 0000000000000000000000000000000000000000..18cc13bccf468ae730402449be0bd5303a39ee39
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/Validator.java
@@ -0,0 +1,121 @@
+package org.leavesmc.lumina.config;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+public class Validator<T> {
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public boolean validate(T newValue, T oldValue) {
+        return true;
+    }
+
+    public String getErrorMessage(T newValue) {
+        return "Invalid value: " + newValue;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateString(@NotNull ConfigNodeInfo nodeInfo, String newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<String> validator = (Validator<String>) nodeInfo.validator();
+                if (!validator.validate(newValue, (String) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateBoolean(@NotNull ConfigNodeInfo nodeInfo, Boolean newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Boolean> validator = (Validator<Boolean>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Boolean) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateInteger(@NotNull ConfigNodeInfo nodeInfo, Integer newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Integer> validator = (Validator<Integer>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Integer) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateLong(@NotNull ConfigNodeInfo nodeInfo, Long newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Long> validator = (Validator<Long>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Long) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateDouble(@NotNull ConfigNodeInfo nodeInfo, Double newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Double> validator = (Validator<Double>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Double) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <E> ValidationResult validate(@NotNull ConfigNodeInfo nodeInfo, E newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<E> validator = (Validator<E>) nodeInfo.validator();
+                if (!validator.validate(newValue, (E) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    public enum ValidationResultType {
+        PASS, FAILED
+    }
+
+    public record ValidationResult(ValidationResultType type, String message) {
+        @Contract(" -> new")
+        public static @NotNull ValidationResult pass() {
+            return new ValidationResult(ValidationResultType.PASS, null);
+        }
+
+        @Contract("_ -> new")
+        public static @NotNull ValidationResult failed(String message) {
+            return new ValidationResult(ValidationResultType.FAILED, message);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7a2e319e7dbc733b9ec9f9b67ec4ddf182dc6df
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
@@ -0,0 +1,15 @@
+package org.leavesmc.lumina.config.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * 在用户使用命令修改Config时提供常量字符串列表建议
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Suggestion {
+    String[] value() default {};
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fff13fd26a134118dac8949ee061c92055fdbde
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.annotations;
+
+import org.leavesmc.lumina.config.Validator;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Validate {
+    Class<? extends Validator> value() default Validator.class;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Fix.java b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
new file mode 100644
index 0000000000000000000000000000000000000000..4df98b3dd4a42068c43a98c399b8ebbfe3157119
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.fix.FixFoliaEntityMovingFixConfig;
+import org.leavesmc.lumina.config.modules.fix.FixFoliaTeleportAsyncConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Fix {
+    public FixFoliaEntityMovingFixConfig fixFoliaEntityMoving = new FixFoliaEntityMovingFixConfig();
+    public FixFoliaTeleportAsyncConfig fixFoliaTeleportAsync = new FixFoliaTeleportAsyncConfig();
+    public boolean fixFoliaSpectorTeleport = true;
+    public boolean allowUnsafeTeleportation = true;
+    public boolean fixVoidTrading = true;
+    public boolean useVanillaRandomSourceForPlayers = true;
+    public boolean fixFoliaPoiAccessOffRegion = true;
+    public boolean mc2025 = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Misc.java b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6f41a391d597655d799249a17445dda22c83f03
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
@@ -0,0 +1,20 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.misc.RegionFormatConfig;
+import org.leavesmc.lumina.config.modules.misc.WatchdogConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Misc {
+    public boolean mojangChatSign = true;
+    public boolean allowInorderChat = true;
+    public boolean offlineModeWarning = true;
+    public String serverModName = "Lumina";
+    public boolean fakeVanilla = false;
+    public boolean checkUsername = true;
+    public boolean alternativeKeepAlive = true;
+    public boolean saveConfigAfterSet = true;
+    public boolean verifyPublicKeyOnlyInOnlineMode = false;
+    public WatchdogConfig watchdog = new WatchdogConfig();
+    public RegionFormatConfig regionFormat = new RegionFormatConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Modify.java b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
new file mode 100644
index 0000000000000000000000000000000000000000..a035eb761bead7fe9f873660af0dda8f609bde15
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.modify.FakePlayerConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Modify {
+    public FakePlayerConfig fakeplayer = new FakePlayerConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
new file mode 100644
index 0000000000000000000000000000000000000000..4739bdb828be18d9bec7ae2d6c6b332de879acee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.performance.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Performance {
+    public PetalReduceSensorWorkConfig petalReduceSensorWork = new PetalReduceSensorWorkConfig();
+    public ProjectileChunkReduceConfig projectileChunkReduce = new ProjectileChunkReduceConfig();
+    public DynamicEntityActivationRangeConfig dynamicEntityActivationRange = new DynamicEntityActivationRangeConfig();
+    public boolean entityGoalSelectorInactiveTick = false;
+    public boolean allowLoadChunksToActiveClimbingEntities = false;
+    public boolean optimizeSuffocation = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d91f7ea07e768c6e2c60386e143242fc20e9152
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.protocol.LeavesBladerenProtocolConfig;
+import org.leavesmc.lumina.config.modules.protocol.PcaSyncProtocolConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Protocol {
+    public boolean carpetProtocol = false;
+    public boolean jadeProtocol = false;
+    public boolean bborProtocol = false;
+    public PcaSyncProtocolConfig pcaSyncProtocol = new PcaSyncProtocolConfig();
+    public LeavesBladerenProtocolConfig leavesBladerenProtocol = new LeavesBladerenProtocolConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abda15610a48676d145ef26bae7a7340b88b0ee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaEntityMovingFixConfig {
+    public boolean enabled = false;
+    public boolean warnOnDetected = true;
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..b043bf36de0604028cb7bdd166d000d2dec76360
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaTeleportAsyncConfig {
+    public boolean enabled = false;
+    public boolean throwOnDetected = true;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..35aed045ceb1f7647de4b0efbf7c609f62c402d8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.stupidcraft.linearpaper.region.EnumRegionFileExtension;
+
+@ConfigSerializable
+public class RegionFormatConfig {
+    public EnumRegionFileExtension format = EnumRegionFileExtension.MCA;
+    public int linearCompressionLevel = 1;
+    public int linearFlushFrequency = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e79b3e1dfa56896c20e3b7e9c9d0cc37257af05
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class WatchdogConfig {
+    public boolean enabled = false;
+    public long warnPeriodTicks = 5 * 20;
+    public long timeOutTicks = 30 * 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/modify/FakePlayerConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/modify/FakePlayerConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..a2a9e4d87bd2863131ab772cfe6f7182ecca7970
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/modify/FakePlayerConfig.java
@@ -0,0 +1,39 @@
+package org.leavesmc.lumina.config.modules.modify;
+
+import net.minecraft.server.MinecraftServer;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.bot.agent.Actions;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Validate;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FakePlayerConfig {
+    @Validate(FakePlayerEnableValidator.class)
+    public boolean enable = true;
+    public String prefix = "";
+    public String suffix = "";
+    public double regenAmount = 0.0;
+    public boolean residentFakeplayer = false;
+    public boolean alwaysSendData = false;
+    public boolean skipSleepCheck = false;
+    public boolean spawnPhantom = false;
+    public boolean cacheSkin = false;
+
+    public static class FakePlayerEnableValidator extends Validator<Boolean> {
+        @Override
+        public boolean validate(@NotNull Boolean newValue, Boolean oldValue) {
+            if (newValue) {
+                MinecraftServer.getServer().server.getCommandMap().register("bot", "leaves", new org.leavesmc.leaves.bot.BotCommand("bot"));
+                MinecraftServer.getServer().server.syncCommands();
+                Actions.registerAll();
+            }
+            if (oldValue && !newValue) {
+                MinecraftServer.getServer().server.getCommandMap().getKnownCommands().remove("bot");
+                MinecraftServer.getServer().server.getCommandMap().getKnownCommands().remove("leaves:bot");
+                MinecraftServer.getServer().server.syncCommands();
+            }
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..92334d8b7617616f3991fd58949e3714d159eeed
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+
+@ConfigSerializable
+public class DynamicEntityActivationRangeConfig {
+    public boolean enabled = false;
+    public int startDistanceSquared = 144;
+    public int maximumActivationPriority = 20;
+    public int activationDistanceMod = 8;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..db160578fa0d35a275f953e88f04340c20d08942
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
@@ -0,0 +1,8 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LoadChunksToActiveClimbingEntitiesConfig {
+    public boolean allow = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..eed3fe3a9a7d5aa6eeeb3c2c3a40d73eafdd3f3f
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PetalReduceSensorWorkConfig {
+    public boolean enabled = true;
+    public int delayTicks = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb64dd4c224c9246fa8d999c8217096f7bebe89b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class ProjectileChunkReduceConfig {
+    public int maxProjectileLoadsPerTick;
+    public int maxProjectileLoadsPerProjectile;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..75352347781b590ddef6680bd8816bdc06631640
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LeavesBladerenProtocolConfig {
+    public boolean enableBaseProtocol = false;
+    public boolean msptSyncProtocol = false;
+    public int msptSyncTickInterval = 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..119b50c12f08c548e7a56dd983805324526fc35e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PcaSyncProtocolConfig {
+    public boolean enabled = false;
+    public SyncOption sync = SyncOption.OPS;
+
+    public enum SyncOption {
+        NOBODY,
+        BOT,
+        OPS,
+        OPS_AND_SELF,
+        EVERYONE
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ComponentUtils.java b/src/main/java/org/leavesmc/lumina/utils/ComponentUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..028e817aa724f643f730d4edb91f5e6e7e5f0363
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ComponentUtils.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.utils;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.server.MinecraftServer;
+import org.jetbrains.annotations.NotNull;
+
+public class ComponentUtils {
+    public static @NotNull Component toAdventure(net.minecraft.network.chat.Component from) {
+        return GsonComponentSerializer.gson().deserialize(
+                net.minecraft.network.chat.Component.Serializer
+                        .toJson(from, MinecraftServer.getServer().registryAccess()));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java b/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..93686ee85bfd508a80c119050ab04d8c09179fe6
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java
@@ -0,0 +1,104 @@
+package org.leavesmc.lumina.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.InternalJavaPluginFactory;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+
+public class ConfigUtils {
+    static final Set<Class<?>> CONFIG_FIELD_TYPES = new HashSet<>(Arrays.asList(
+            String.class,
+            boolean.class,
+            int.class,
+            long.class,
+            double.class));
+    static final Plugin INTERNAL_PLUGIN = InternalJavaPluginFactory.create("LuminaConfigSystem");
+
+    @Contract("_ -> new")
+    public static @NotNull CompletableFuture<Void> runAsync(Runnable runnable) {
+        return CompletableFuture.runAsync(runnable, task -> Bukkit.getGlobalRegionScheduler().run(ConfigUtils.INTERNAL_PLUGIN, scheduled -> task.run()));
+    }
+
+    public static void generateNodeInfos(Map<String, ConfigNodeInfo> nodeInfoMap, @NotNull Class<?> clazz, String parentKey, @NotNull Object parent, @NotNull Object fileParent, @NotNull Object tempParent) throws IllegalAccessException {
+        for (Field field : clazz.getFields()) {
+            String fieldName = field.getName();
+            Class<?> fieldType = field.getType();
+            String key = parentKey == null ? toHyphen(fieldName) : parentKey + "." + toHyphen(fieldName);
+            boolean haveSuggestions = false;
+            String[] suggestions = null;
+            Validator<?> validator = new Validator<>();
+            for (Annotation annotation : field.getAnnotations()) {
+                if (annotation instanceof Suggestion value) {
+                    haveSuggestions = true;
+                    suggestions = value.value();
+                } else if (annotation instanceof Validate value) {
+                    try {
+                        validator = value.value().getDeclaredConstructor().newInstance();
+                    } catch (InstantiationException | InvocationTargetException | NoSuchMethodException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+            if (!haveSuggestions) {
+                if ("boolean".equals(fieldType.getSimpleName())) {
+                    suggestions = new String[]{"true", "false"};
+                    haveSuggestions = true;
+                } else if (ConfigUtils.CONFIG_FIELD_TYPES.contains(fieldType)) {
+                    suggestions = new String[]{field.get(parent).toString()};
+                    haveSuggestions = true;
+                } else if (fieldType.isEnum()) {
+                    suggestions = Arrays.stream(fieldType.getEnumConstants()).map(Object::toString).toArray(String[]::new);
+                    haveSuggestions = true;
+                }
+            }
+            if (haveSuggestions) {
+                nodeInfoMap.put(key, new ConfigNodeInfo(suggestions, fieldType, field, parent, fileParent, tempParent, validator));
+            } else {
+                generateNodeInfos(nodeInfoMap, fieldType, key, field.get(parent), field.get(fileParent), field.get(tempParent));
+            }
+        }
+    }
+
+    private static @NotNull String toHyphen(String input) {
+        if (input == null || input.isEmpty()) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < input.length(); i++) {
+            char ch = input.charAt(i);
+            if (Character.isUpperCase(ch) && i > 0) {
+                sb.append('-');
+            }
+            sb.append(Character.toLowerCase(ch));
+        }
+        return sb.toString();
+    }
+
+    public static @NotNull String toCamelCase(@NotNull String input) {
+        String[] words = input.split("-");
+        StringBuilder camelCaseString = new StringBuilder();
+
+        for (String word : words) {
+            if (!word.isEmpty()) {
+                camelCaseString.append(Character.toUpperCase(word.charAt(0)))
+                        .append(word.substring(1).toLowerCase());
+            }
+        }
+
+        return camelCaseString.toString();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/DividedPlayerList.java b/src/main/java/org/leavesmc/lumina/utils/DividedPlayerList.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2c1343643dc9b69fd68fbd685d1bcb44bd345bd
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/DividedPlayerList.java
@@ -0,0 +1,84 @@
+package org.leavesmc.lumina.utils;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.bot.ServerBot;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import static org.leavesmc.lumina.utils.PlayerType.*;
+
+public class DividedPlayerList extends CopyOnWriteArrayList<ServerPlayer> {
+    public final Map<PlayerType, CopyOnWriteArrayList<ServerPlayer>> divided = new HashMap<>() {{
+        put(REAL, new CopyOnWriteArrayList<>());
+        put(FAKE, new CopyOnWriteArrayList<>());
+        put(GHOST, new CopyOnWriteArrayList<>());
+    }};
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> c) {
+        c.forEach(o -> divided.get(getType((ServerPlayer) o)).remove(o));
+        return super.removeAll(c);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        divided.get(getType((ServerPlayer) o)).remove(o);
+        return super.remove(o);
+    }
+
+    @Override
+    public ServerPlayer remove(int index) {
+        ServerPlayer player = super.remove(index);
+        divided.get(getType(player)).remove(player);
+        return player;
+    }
+
+    @Override
+    public int addAllAbsent(@NotNull Collection<? extends ServerPlayer> c) {
+        c.forEach(serverPlayer -> divided.get(getType(serverPlayer)).add(serverPlayer));
+        return super.addAllAbsent(c);
+    }
+
+    @Override
+    public boolean addIfAbsent(ServerPlayer serverPlayer) {
+        divided.get(getType(serverPlayer)).add(serverPlayer);
+        return super.addIfAbsent(serverPlayer);
+    }
+
+    @Override
+    public void add(int index, ServerPlayer serverPlayer) {
+        divided.get(getType(serverPlayer)).add(serverPlayer);
+        super.add(index, serverPlayer);
+    }
+
+    @Override
+    public boolean add(ServerPlayer serverPlayer) {
+        divided.get(getType(serverPlayer)).add(serverPlayer);
+        return super.add(serverPlayer);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends ServerPlayer> c) {
+        c.forEach(serverPlayer -> divided.get(getType(serverPlayer)).add(serverPlayer));
+        return super.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, @NotNull Collection<? extends ServerPlayer> c) {
+        c.forEach(serverPlayer -> divided.get(getType(serverPlayer)).add(serverPlayer));
+        return super.addAll(index, c);
+    }
+
+    public PlayerType getType(ServerPlayer player) {
+        // TODO Ghost player check
+        if (false) {
+            return GHOST;
+        } else if (player instanceof ServerBot) {
+            return FAKE;
+        } else {
+            return REAL;
+        }
diff --git a/src/main/java/org/leavesmc/lumina/utils/LocationUtils.java b/src/main/java/org/leavesmc/lumina/utils/LocationUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9d0f247f3834626767688c9298ad0b03557000e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/LocationUtils.java
@@ -0,0 +1,62 @@
+package org.leavesmc.lumina.utils;
+
+import dev.jorel.commandapi.CommandAPIBukkit;
+import dev.jorel.commandapi.exceptions.WrapperCommandSyntaxException;
+import dev.jorel.commandapi.executors.CommandArguments;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public class LocationUtils {
+    @Contract("_ -> new")
+    public static @NotNull BlockPos toBlockPos(@NotNull Location location) {
+        return new BlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+    }
+
+    public static @NotNull Location toLocation(@NotNull BlockPos blockPos, World world) {
+        return new Location(world, blockPos.getX(), blockPos.getY(), blockPos.getZ());
+    }
+
+    public static ServerLevel getLevel(@NotNull Location location) {
+        return getLevel(location.getWorld());
+    }
+
+    public static ServerLevel getLevel(@NotNull World world) {
+        return ((CraftWorld) world).getHandle();
+    }
+
+    public static ServerLevel getLevel(@NotNull Entity entity) {
+        return getLevel(entity.getWorld());
+    }
+
+    public static @NotNull Location getLocationWithDefaultWorld(@NotNull CommandSender sender, @NotNull CommandArguments args, String key) throws WrapperCommandSyntaxException {
+        Location location = (Location) args.get(key);
+        if (location == null) {
+            throw CommandAPIBukkit.failWithAdventureComponent(text("Must specify " + key + " location.").color(RED));
+        }
+        World world = getSenderWorldOrDefault(sender);
+        if (location.getWorld() == null) {
+            location.setWorld(world);
+        }
+        return location;
+    }
+
+    public static World getSenderWorldOrDefault(@NotNull CommandSender sender) {
+        World world = Bukkit.getWorlds().getFirst();
+        if (sender instanceof Entity entity) {
+            world = entity.getWorld();
+        }
+        return world;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/PermissionUtils.java b/src/main/java/org/leavesmc/lumina/utils/PermissionUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..6399ccb0a549b24e8bb66254bb7e1fd18e76cf95
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/PermissionUtils.java
@@ -0,0 +1,25 @@
+package org.leavesmc.lumina.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permission;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+public class PermissionUtils {
+    private static void addPermission(Permission permission) {
+        Bukkit.getPluginManager().addPermission(permission);
+    }
+
+    public static void addPermissionAndBind(String name, String description, @NotNull List<String> enabledChildren) {
+        addPermission(new Permission(
+                name,
+                description,
+                Permission.DEFAULT_PERMISSION,
+                enabledChildren.stream().collect(Collectors.toMap(
+                        child -> child.replaceFirst("&", name),
+                        child -> true)
+                )));
+    }
+}
