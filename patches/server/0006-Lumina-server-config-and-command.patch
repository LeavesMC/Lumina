From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7studio@foxmail.com>
Date: Thu, 11 Apr 2024 22:58:15 +0800
Subject: [PATCH] Lumina server config and command


diff --git a/src/main/java/org/leavesmc/lumina/LuminaCommand.java b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa829f4b6233f656584c7971db34ef20cbd58814
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
@@ -0,0 +1,225 @@
+package org.leavesmc.lumina;
+
+import com.mojang.logging.LogUtils;
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import dev.jorel.commandapi.executors.CommandArguments;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.leavesmc.lumina.config.Validator;
+import org.slf4j.Logger;
+
+import java.util.Arrays;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+
+public class LuminaCommand {
+    private LuminaCommand() {
+    }
+
+    public static LuminaCommand INSTANCE = new LuminaCommand();
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public void registerCommands() {
+        registerLuminaCommand();
+    }
+
+    private void registerLuminaCommand() {
+        String[] configNodes = LuminaConfig.nodeInfos.keySet().toArray(new String[0]);
+        new CommandAPICommand("lumina")
+                .withSubcommand(new CommandAPICommand("config")
+                        .withSubcommand(generateSetSubCommand(false, configNodes))
+                        .withSubcommand(new CommandAPICommand("get")
+                                .withPermission("lumina.config.get")
+                                .withArguments(new StringArgument("node")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                                ).executes((sender, args) -> {
+                                    String node = (String) args.get("node");
+                                    ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                    if (node == null || nodeInfo == null) {
+                                        sender.sendMessage(text("No config node specified.").color(RED));
+                                        return;
+                                    }
+                                    try {
+                                        sender.sendMessage(text("The value of " + node + " is " + nodeInfo.field().get(nodeInfo.parent())));
+                                    } catch (IllegalAccessException e) {
+                                        throw new RuntimeException("Please report this to Lumina developers: " + e);
+                                    }
+                                })
+                        ).withSubcommand(new CommandAPICommand("reload")
+                                .withPermission("lumina.config.reload")
+                                .executes((sender, args) -> {
+                                    sender.sendMessage(text("Reloading Lumina config...").color(DARK_GREEN));
+                                    if (!(sender instanceof ConsoleCommandSender)) {
+                                        LOGGER.info("Reloading Lumina config...");
+                                    }
+                                    LuminaConfig.reloadAsync().thenApply((Void ignored) -> {
+                                        sender.sendMessage(text("Lumina config reloaded.").color(DARK_GREEN));
+                                        if (!(sender instanceof ConsoleCommandSender)) {
+                                            LOGGER.info("Lumina config reloaded.");
+                                        }
+                                        return null;
+                                    });
+                                })
+                        ).withSubcommand(new CommandAPICommand("save")
+                                .withPermission("lumina.config.set") // Cause `set` also called save, so use the same permission node
+                                .executes((sender, args) -> {
+                                    sender.sendMessage(text("Saving Lumina config...").color(DARK_GREEN));
+                                    if (!(sender instanceof ConsoleCommandSender)) {
+                                        LOGGER.info("Saving Lumina config...");
+                                    }
+                                    LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                                        sender.sendMessage(text("Lumina config saved.").color(DARK_GREEN));
+                                        if (!(sender instanceof ConsoleCommandSender)) {
+                                            LOGGER.info("Lumina config saved.");
+                                        }
+                                        return null;
+                                    });
+                                })
+                        ).withSubcommand(new CommandAPICommand("temp")
+                                .withSubcommand(generateSetSubCommand(true, configNodes))
+                                .withSubcommand(new CommandAPICommand("clear")
+                                        .withPermission("lumina.config.set")
+                                )
+                        )
+                ).register();
+    }
+
+    private CommandAPICommand generateSetSubCommand(boolean temp, String[] configNodes) {
+        return new CommandAPICommand("set")
+                .withPermission("lumina.config.set")
+                .withArguments(new StringArgument("node")
+                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                ).withArguments(new GreedyStringArgument("value")
+                        .replaceSuggestions(ArgumentSuggestions.strings(info -> {
+                            String node = (String) info.previousArgs().get("node");
+                            ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                            if (node == null || node.isEmpty() || nodeInfo == null) {
+                                return new String[]{};
+                            }
+                            return nodeInfo.suggestions();
+                        }))
+                ).executes((sender, args) -> {
+                    String node = (String) args.get("node");
+                    ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                    setValueInternal(node, nodeInfo, sender, args, temp);
+                });
+    }
+
+    private void setValueInternal(String node, ConfigNodeInfo nodeInfo, CommandSender sender, CommandArguments args, boolean temp) {
+        if (node == null || nodeInfo == null) {
+            sender.sendMessage(text("No config node specified.").color(RED));
+            return;
+        }
+        String value = (String) args.get("value");
+        Class<?> type = nodeInfo.type();
+        Object fileParent = nodeInfo.fileParent();
+        Object tempParent = nodeInfo.tempParent();
+        if (value == null || value.isEmpty()) {
+            sender.sendMessage(text("No value specified, expected: " + type.getSimpleName()).color(RED));
+            return;
+        }
+        try {
+            if (type.isEnum()) {
+                @SuppressWarnings({"unchecked", "rawtypes"})
+                Class<? extends Enum> enumType = (Class<? extends Enum>) type;
+                try {
+                    @SuppressWarnings("unchecked")
+                    Object enumValue = Enum.valueOf(enumType, value);
+                    nodeInfo.field().set(tempParent, enumValue);
+                    if (!temp) nodeInfo.field().set(fileParent, enumValue);
+                } catch (IllegalArgumentException ignored) {
+                    sender.sendMessage(text("Expected enum " + Arrays.toString(nodeInfo.suggestions()) + ", but entered: " + value).color(RED));
+                }
+            } else {
+                switch (type.getSimpleName()) {
+                    case "boolean" -> {
+                        boolean newValue;
+                        if ("true".equals(value)) {
+                            newValue = true;
+                        } else if ("false".equals(value)) {
+                            newValue = false;
+                        } else {
+                            sender.sendMessage(text("Expected boolean, but entered: " + value).color(RED));
+                            return;
+                        }
+                        Validator.ValidationResult result = Validator.validateBoolean(nodeInfo, newValue);
+                        if (result.type() != Validator.ValidationResultType.PASS) {
+                            sender.sendMessage(text(result.message()).color(RED));
+                            return;
+                        }
+                        nodeInfo.field().setBoolean(tempParent, newValue);
+                        if (!temp) nodeInfo.field().setBoolean(fileParent, newValue);
+                    }
+                    case "int" -> {
+                        try {
+                            int newValue = Integer.parseInt(value);
+                            Validator.ValidationResult result = Validator.validateInteger(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setInt(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setInt(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected int, but entered: " + value).color(RED));
+                        }
+                    }
+                    case "long" -> {
+                        try {
+                            long newValue = Long.parseLong(value);
+                            Validator.ValidationResult result = Validator.validateLong(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setLong(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setLong(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected long, but entered: " + value).color(RED));
+                        }
+                    }
+                    case "double" -> {
+                        try {
+                            double newValue = Double.parseDouble(value);
+                            Validator.ValidationResult result = Validator.validateDouble(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setDouble(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setDouble(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected double, but entered: " + value).color(RED));
+                        }
+                    }
+                    case "String" -> {
+                        Validator.ValidationResult result = Validator.validateString(nodeInfo, value);
+                        if (result.type() != Validator.ValidationResultType.PASS) {
+                            sender.sendMessage(text(result.message()).color(RED));
+                            return;
+                        }
+                        nodeInfo.field().set(tempParent, value);
+                        if (!temp) nodeInfo.field().set(fileParent, value);
+                    }
+                    default ->
+                            throw new IllegalStateException("Please report this to Lumina developers: unexpected config field type " + type.getName());
+                }
+            }
+            LuminaConfig.mergeConfig();
+            sender.sendMessage(text("Set " + node + " to " + value + (temp ? " temporary" : "")).color(DARK_GREEN));
+            if (!temp && LuminaConfig.configModule.misc.saveConfigAfterSet) {
+                LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                    LOGGER.info("Saved Lumina config after setting {} to {}", node, value);
+                    return null;
+                });
+            }
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Please report this to Lumina developers: " + e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..804839b994c708b6cc37371b879e2d2261cdfa77
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java
@@ -0,0 +1,154 @@
+package org.leavesmc.lumina.carpet;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import net.minecraft.world.level.block.Block;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.protocol.CarpetServerProtocol;
+import org.leavesmc.lumina.carpet.utils.ConfigIdentifier;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.LuminaConfigModule;
+import org.leavesmc.lumina.utils.ConfigUtils;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.NodePath;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.objectmapping.meta.Comment;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.Annotation;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public class CarpetConfig {
+    public static final ThreadLocal<Boolean> IMPENDING_FILL_SKIP_UPDATES = ThreadLocal.withInitial(() -> false);
+    public static final ThreadLocal<Boolean> SKIP_GENERATION_CHECKS = ThreadLocal.withInitial(() -> false);
+    public static CarpetConfigModule configModule, fileModule, tempModule;
+    public static Block structureBlockIgnoredBlock;
+    private static HoconConfigurationLoader loader;
+    private static CommentedConfigurationNode node;
+    public static Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+    private static final ConcurrentMap<String, Rule> RULE_CACHE = new ConcurrentHashMap<>();
+
+    public static void setup() {
+        final ObjectMapper.Factory customFactory = ObjectMapper.factoryBuilder()
+                .addProcessor(Comment.class, (data, fieldType) -> (value, destination) -> setRuleCache(destination, value, data))
+                .addProcessor(ConfigIdentifier.class, (data, fieldType) -> (value, destination) -> setRuleCache(destination, value, data))
+                .build();
+        loader = HoconConfigurationLoader.builder()
+                .emitComments(true)
+                .prettyPrinting(true)
+                .defaultOptions(opts -> opts.serializers(build -> build.registerAnnotatedObjects(customFactory)))
+                .path(Paths.get("carpet.conf"))
+                .build();
+
+        loadConfig();
+        saveConfig();
+    }
+
+    private static void generateNodeInfos() {
+        try {
+            ConfigUtils.generateNodeInfos(nodeInfos, CarpetConfigModule.class, null, configModule, fileModule, tempModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void mergeConfig() {
+        try {
+            node.set(fileModule);
+            if (tempModule == null) {
+                tempModule = loader.createNode().get(CarpetConfigModule.class);
+            }
+            node.from(loader.createNode().set(LuminaConfigModule.class, tempModule));
+            configModule = node.get(CarpetConfigModule.class);
+            generateNodeInfos();
+        } catch (SerializationException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static void setRuleCache(ConfigurationNode node, Object value, Annotation annotation) {
+        if (value != null) {
+            String v;
+            if (value instanceof Enum<?> e) {
+                v = e.name().toLowerCase(Locale.ROOT);
+            } else if (value instanceof Boolean b) {
+                v = Boolean.toString(b);
+            } else {
+                v = value.toString();
+            }
+            NodePath path = node.path();
+            String name = ConfigUtils.toCamel(path.get(path.size() - 1).toString());
+            Rule rule = RULE_CACHE.computeIfAbsent(name, k -> new Rule());
+            rule.name = name;
+            rule.value = v;
+            if (annotation instanceof ConfigIdentifier identifier) {
+                rule.identifier = identifier.value();
+            }
+        }
+    }
+
+    public static void reload() {
+        RegionizedServer.ensureGlobalTickThread("Reload carpet config off global region thread!");
+        loadConfig();
+    }
+
+    private static void loadConfig() {
+        try {
+            node = loader.load();
+            configModule = node.get(CarpetConfigModule.class);
+            fileModule = node.get(CarpetConfigModule.class);
+            tempModule = loader.createNode().get(CarpetConfigModule.class);
+            generateNodeInfos();
+            RULE_CACHE.forEach((name, rule) -> rule.register());
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void save() {
+        RegionizedServer.ensureGlobalTickThread("Reload carpet config off global region thread!");
+        saveConfig();
+    }
+
+    private static void saveConfig() {
+        try {
+            node.set(CarpetConfigModule.class, fileModule);
+            loader.save(node);
+            RULE_CACHE.forEach((name, rule) -> rule.register());
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> reloadAsync() {
+        return ConfigUtils.runAsync(CarpetConfig::reload);
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> saveAsync() {
+        return ConfigUtils.runAsync(CarpetConfig::save);
+    }
+
+    private static class Rule {
+        public String identifier;
+        public String name;
+        public String value;
+
+        public void register() {
+            if (identifier == null) {
+                identifier = "carpet";
+            }
+            CarpetServerProtocol.CarpetRules.register(new CarpetServerProtocol.CarpetRule(identifier, name, value));
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d5758fd377dc834e3824a1e6dfcbc1f917673be
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
@@ -0,0 +1,493 @@
+package org.leavesmc.lumina.carpet;
+
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.StructureBlockEntity;
+import net.minecraft.world.level.block.piston.PistonStructureResolver;
+import net.minecraft.world.level.border.BorderStatus;
+import net.minecraft.world.level.border.WorldBorder;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.Comment;
+
+import java.util.Optional;
+
+@ConfigSerializable
+public class CarpetConfigModule {
+    @Comment("Sets the language for Carpet")
+    public Lang language = Lang.zh_cn;
+
+    @Comment("Dropping entire stacks works also from on the crafting UI result slot")
+    public boolean ctrlQCraftingFix = false;
+
+    @Comment("""
+            Parrots don't get of your shoulders until you receive proper damage
+            It is not exactly the same as paper's `entities.behavior.parrots-are-unaffected-by-player-movement`
+            configuration in paper-world.yml""")
+    public boolean persistentParrots = false;
+
+    @Comment("Players absorb XP instantly, without delay")
+    public boolean xpNoCooldown = false;
+
+    @Validate(ShulkerBoxValidator.class)
+    @Comment("""
+            When set more than 1, empty shulker boxes can stack when thrown on the ground,
+            or when manipulated inside the inventories""")
+    public int shulkerBoxStackSize = 1;
+
+    @Comment("Explosions won't destroy blocks")
+    public boolean explosionNoBlockDamage = false;
+
+    @Comment("Experience will drop from all experience barring blocks with any explosion type")
+    public boolean xpFromExplosions = false;
+
+    @Comment("Removes random TNT momentum when primed")
+    public boolean tntPrimerMomentumRemoved = false;
+
+    // @Validate(TNTRandomRangeValidator.class)
+    // @Comment("Sets the tnt random explosion range to a fixed value, set to -1 for default behavior")
+    // public double tntRandomRange = -1; // TODO
+
+    @Validate(TNTAngleValidator.class)
+    @Comment("Sets the horizontal random angle on TNT for debugging of TNT contraptions, set to -1 for default behavior")
+    public double hardcodeTNTangle = -1.0D;
+
+    @Comment("Merges stationary primed TNT entities")
+    public boolean mergeTNT = false;
+
+    @Comment("Only husks spawn in desert temples")
+    public boolean huskSpawningInTemples = false;
+
+    @Comment("Shulkers will respawn in end cities")
+    public boolean shulkerSpawningInEndCities = false;
+
+    @Comment("""
+            Piglins will respawn in bastion remnants
+            Includes piglins, brutes, and a few hoglins""")
+    public boolean piglinsSpawningInBastions = false;
+
+    @Comment("TNT doesn't update when placed against a power source")
+    public boolean tntDoNotUpdate = false;
+
+    @Comment("""
+            Prevents players from rubberbanding when moving too fast or being kicked out for 'flying'
+            Puts more trust in clients positioning, increases player allowed mining distance to 32 blocks""")
+    public boolean antiCheatDisabled = false;
+
+    @Validate(QuasiConnectivityValidator.class)
+    @Comment("""
+            Pistons, droppers, and dispensers check for power to the block(s) above them.
+            Defines the range at which pistons, droppers, and dispensers check for quasi power""")
+    public int quasiConnectivity = 1;
+
+    @Comment("""
+            Players can flip and rotate blocks when holding cactus
+            Doesn't cause block updates when rotated/flipped
+            Applies to pistons, observers, droppers, repeaters, stairs, glazed terracotta etc...""")
+    public boolean flippinCactus = false;
+
+    @Comment("""
+            hoppers pointing to wool will count items passing through them
+            Enables /counter command, and actions while placing red and green carpets on wool blocks
+            Use /counter <color?> reset to reset the counter, and /counter <color?> to query
+            In survival, place green carpet on same color wool to query, red to reset the counters
+            Counters are global and shared between players, 16 channels available
+            Items counted are destroyed, count up to one stack per tick per hopper""")
+    public boolean hopperCounters = false;
+
+    @Comment("""
+            Allows Budding Amethyst blocks to be moved by pistons
+            as well as adds extra drop when mining with silk touch pickaxe""")
+    public boolean movableAmethyst = false;
+
+    @Comment("Guardians turn into Elder Guardian when struck by lightning")
+    public boolean renewableSponges = false;
+
+    // @Comment("Pistons can push block entities, like hoppers, chests etc.")
+    // public boolean movableBlockEntities = false; // TODO
+
+    @Comment("""
+            Chains will stick to each other on the long ends
+            and will stick to other blocks that connect to them directly.
+            With stick_to_all: it will stick even if not visually connected""")
+    public ChainStoneMode chainStone = ChainStoneMode.FALSE;
+
+    @Comment("Saplings turn into dead shrubs in hot climates and no water access")
+    public boolean desertShrubs = false;
+
+    @Comment("Silverfish drop a gravel item when breaking out of a block")
+    public boolean silverFishDropGravel = false;
+
+    @Comment("summoning a lightning bolt has all the side effects of natural lightning")
+    public boolean summonNaturalLightning = false;
+
+    @Comment("Enables /spawn command for spawn tracking")
+    public boolean commandSpawn = true;
+
+    @Comment("Enables /log command to monitor events via chat and overlays")
+    public boolean commandLog = true;
+
+    @Suggestion({"none", "tps", "mobcaps,tps"})
+    @Comment("""
+            sets these loggers in their default configurations for all new players
+            use csv, like 'tps,mobcaps' for multiple loggers, none for nothing""")
+    public String defaultLoggers = "none";
+
+    @Comment("""
+            Enables /distance command to measure in game distance between points
+            Also enables brown carpet placement action if 'carpets' rule is turned on as well""")
+    public boolean commandDistance = true;
+
+    @Comment("""
+            "Enables /info command for blocks
+            Also enables gray carpet placement action if 'carpets' rule is turned on as well""")
+    public boolean commandInfo = true;
+
+    @Comment("""
+            Enables /perimeterinfo command
+            that scans the area around the block for potential spawnable spots""")
+    public boolean commandPerimeterInfo = true;
+
+    @Comment("Enables /player command to control/spawn players")
+    public boolean commandPlayer = true;
+
+    @Comment("Spawn offline players in online mode if online-mode player with specified name does not exist")
+    public boolean allowSpawningOfflinePlayers = true;
+
+    @Comment("Allows listing fake players on the multiplayer screen")
+    public boolean allowListingFakePlayers = false;
+
+    @Comment("""
+            Add a markerName prefix for fake players spawned with /player command
+            Which can prevent summoning fake player with illegal names and make player list look nicer
+            Set it to #none to stop adding a prefix""")
+    public String fakePlayerNamePrefix = "#none";
+
+    @Comment("""
+            Add a markerName suffix for fake players spawned with /player command
+            Which can prevent summoning fake player with illegal names and make player list look nicer
+            Set it to #none to stop adding a suffix""")
+    public String fakePlayerNameSuffix = "#none";
+
+    @Comment("Allows to track mobs AI via /track command")
+    public boolean commandTrackAI = true;
+
+    @Comment("lacing carpets may issue carpet commands for non-op players")
+    public boolean carpets = false;
+
+    @Comment("Glass can be broken faster with pickaxes")
+    public boolean missingTools = false;
+
+    @Comment("fill/clone/setblock and structure blocks cause block updates")
+    public boolean fillUpdates = true;
+
+    @Comment("placing blocks cause block updates")
+    public boolean interactionUpdates = true;
+
+    @Comment("Disables breaking of blocks caused by flowing liquids")
+    public boolean liquidDamageDisabled = false;
+
+    @Validate(PushLimitValidator.class)
+    @Suggestion({"10", "12", "14", "100"})
+    @Comment("Customizable piston push limit")
+    public int pushLimit = PistonStructureResolver.MAX_PUSH_DEPTH;
+
+    @Validate(Zero1024Validator.class)
+    @Suggestion({"9", "15", "30"})
+    @Comment("Customizable powered rail power range")
+    public int railPowerLimit = 9;
+
+    @Validate(ForceloadLimitValidator.class)
+    @Comment("Customizable forceload chunk limit")
+    public int forceloadLimit = 256;
+
+    @Comment("Cactus in dispensers rotates blocks.Rotates block anti-clockwise if possible")
+    public boolean rotatorBlock = false;
+
+    @Comment("""
+            Coral structures will grow with bonemeal from coral plants
+            Expanded also allows growing from coral fans for sustainable farming outside of warm oceans""")
+    public RenewableCoralMode renewableCoral = RenewableCoralMode.FALSE;
+
+    @Comment("Nether basalt generator without soul sand below will convert into blackstone instead")
+    public boolean renewableBlackstone = false;
+
+    @Comment("Lava and water generate deepslate and cobbled deepslate instead below Y0")
+    public boolean renewableDeepslate = false;
+
+    @Comment("fixes block placement rotation issue when player rotates quickly while placing blocks")
+    public boolean placementRotationFix = false;
+
+    @Comment("Increases for testing purposes number of blue skulls shot by the wither")
+    public boolean moreBlueSkulls = false;
+
+    @Comment("""
+            Can allow to phase through walls in creative mode
+            On servers it needs to be set on both client and server to function properly.
+            Needs carpet client. Has no effect when set on the server only.""")
+    public boolean creativeNoClip = false;
+
+    // @Validate(StructureBlockLimitValidator.class)
+    // @Suggestion({"48", "96", "192", "256"})
+    // @Comment("""
+    //         Customizable structure block limit of each axis
+    //         WARNING: Needs to be permanent for correct loading.
+    //         Setting 'structureBlockIgnored' to air is recommended
+    //         when saving massive structures.
+    //         Required on client of player editing the Structure Block.
+    //         'structureBlockOutlineDistance' may be required for
+    //         correct rendering of long structures.""")
+    // public int structureBlockLimit = StructureBlockEntity.MAX_SIZE_PER_AXIS; // TODO
+
+    // @Validate(StructureBlockIgnoredValidator.class)
+    // @Suggestion({"minecraft:structure_void", "minecraft:air"})
+    // @Comment("Changes the block ignored by the Structure Block")
+    // public String structureBlockIgnored = "minecraft:structure_void"; // TODO
+
+    // @Validate(NonNegativeNumberValidator.class)
+    // @Suggestion({"96", "192", "2048"})
+    // @Comment("Customizable Structure Block outline render distance, required on client to work properly")
+    // public int structureBlockOutlineDistance = 96; // TODO
+
+    @Comment("""
+            Lightning kills the items that drop when lightning kills an entity
+            Setting to true will prevent lightning from killing drops
+            Fixes [MC-206922](https://bugs.mojang.com/browse/MC-206922).""")
+    public boolean lightningKillsDropsFix = false;
+
+    @Validate(UpdateSuppressionBlockValidator.class)
+    @Suggestion({"-1", "0", "10", "50"})
+    @Comment("""
+            Placing an activator rail on top of a barrier block will fill the neighbor updater stack when the rail turns off.
+            The integer entered is the amount of updates that should be left in the stack. set to -1 to disable this""")
+    public int updateSuppressionBlock = -1;
+
+    @Comment("""
+            Creative players load chunks, or they don't! Just like spectators!
+            Toggling behaves exactly as if the player is in spectator mode,
+            also toggling the gamerule spectatorsGenerateChunks.""")
+    public boolean creativePlayersLoadChunks = true;
+
+    @Validate(Zero1024Validator.class)
+    @Suggestion({"8", "16", "32"})
+    @Comment("Customizable sculk sensor range")
+    public int sculkSensorRange = 8;
+
+    @Validate(WorldBorderValidator.class)
+    @Comment("""
+            Makes world borders move based on in game time instead of real time
+            This has the effect that when the tick rate changes the world border speed also changes proportional to it""")
+    public boolean tickSyncedWorldBorders = false;
+
+    // refers to "[MC-215169](https://bugs.mojang.com/browse/MC-215169)." - unconfirmed yet that its a java bug
+    @Comment("""
+            Allows to grow nether fungi with 3x3 base with bonemeal
+            Setting to 'all' will make all nether fungi grow into 3x3 trees
+            Setting to 'random' will make 6% of all nether fungi grow into 3x3 trees
+            (this being consistent with worldgen)""")
+    public FungusGrowthMode thickFungusGrowth = FungusGrowthMode.FALSE;
+
+    public static class ShulkerBoxValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue > 0 && newValue <= 64;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 64, but got " + newValue;
+        }
+    }
+
+    public static class TNTRandomRangeValidator extends Validator<Double> {
+        @Override
+        public boolean validate(Double newValue, Double oldValue) {
+            return newValue == -1 || newValue >= 0;
+        }
+
+        @Override
+        public String getErrorMessage(Double newValue) {
+            return "Value can't be negative, or -1, but got " + newValue;
+        }
+    }
+
+    public static class TNTAngleValidator extends Validator<Double> {
+        @Override
+        public boolean validate(Double newValue, Double oldValue) {
+            return (newValue >= 0 && newValue < Math.PI * 2) || newValue == -1;
+        }
+
+        @Override
+        public String getErrorMessage(Double newValue) {
+            return "Value must be a number between 0 and 2Pi(include 0), or -1, but got " + newValue;
+        }
+    }
+
+    public static class QuasiConnectivityValidator extends Validator<Integer> {
+        private int maxRange = 1;
+
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            int minRange = 0;
+            int maxRange = 1;
+
+            if (!MinecraftServer.getServer().isReady()) {
+                maxRange = Integer.MAX_VALUE;
+            } else {
+                for (Level level : MinecraftServer.getServer().getAllLevels()) {
+                    maxRange = Math.max(maxRange, level.getHeight() - 1);
+                }
+            }
+
+            this.maxRange = maxRange;
+
+            return newValue >= minRange && newValue <= maxRange;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 0 to the max level height(now " + maxRange + "), but got " + newValue;
+        }
+    }
+
+
+    public static class PushLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            PistonStructureResolver.MAX_PUSH_DEPTH = newValue;
+            return newValue >= 1 && newValue <= 1024;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 1024, but got " + newValue;
+        }
+    }
+
+    public static class Zero1024Validator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 1 && newValue <= 1024;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 1024, but got " + newValue;
+        }
+    }
+
+    public static class ForceloadLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 0 && newValue <= 20000000;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 0 to 20M, but got " + newValue;
+        }
+    }
+
+    public static class NonNegativeNumberValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 0;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a non-negative number, but got " + newValue;
+        }
+    }
+
+    public static class StructureBlockLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= StructureBlockEntity.MAX_SIZE_PER_AXIS;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "You have to choose a value greater or equal to 48, but got " + newValue;
+        }
+    }
+
+    public static class StructureBlockIgnoredValidator extends Validator<String> {
+        @Override
+        public boolean validate(String newValue, String oldValue) {
+            Optional<Block> ignoredBlock = MinecraftServer.getServer()
+                    .registryAccess()
+                    .registryOrThrow(Registries.BLOCK)
+                    .getOptional(ResourceLocation.tryParse(newValue));
+            if (ignoredBlock.isEmpty()) {
+                return false;
+            }
+            CarpetConfig.structureBlockIgnoredBlock = ignoredBlock.get();
+            return true;
+        }
+
+        @Override
+        public String getErrorMessage(String newValue) {
+            return "Unknown block: " + newValue;
+        }
+    }
+
+    public static class UpdateSuppressionBlockValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue < -1;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "This value represents the amount of updates required before the logger logs them. Must be -1 or larger, but got " + newValue;
+        }
+    }
+
+    public static class WorldBorderValidator extends Validator<Boolean> {
+        @Override
+        public boolean validate(@NotNull Boolean newValue, @NotNull Boolean oldValue) {
+            if (oldValue.booleanValue() != newValue.booleanValue()) {
+                // Needed for the update
+                CarpetConfig.configModule.tickSyncedWorldBorders = newValue;
+                for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                    WorldBorder worldBorder = level.getWorldBorder();
+                    if (worldBorder.getStatus() != BorderStatus.STATIONARY) {
+                        double from = worldBorder.getSize();
+                        double to = worldBorder.getLerpTarget();
+                        long time = worldBorder.getLerpRemainingTime();
+                        worldBorder.lerpSizeBetween(from, to, time);
+                    }
+                }
+            }
+            return true;
+        }
+    }
+
+    public enum Lang {
+        zh_cn, zh_tw, en_us, fr_fr, pt_br
+    }
+
+    public enum ChainStoneMode {
+        TRUE, FALSE, STICK_TO_ALL;
+
+        public boolean enabled() {
+            return this != FALSE;
+        }
+    }
+
+    public enum RenewableCoralMode {
+        FALSE, EXPANDED, TRUE
+    }
+
+    public enum FungusGrowthMode {
+        FALSE, RANDOM, ALL
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/CarpetCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/CarpetCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b2372ef995267600f81e0a05c4a3a5bf9e7dd05
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/CarpetCommand.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+
+public class CarpetCommand {
+    public static void register() {
+        new CommandAPICommand("carpet").withArguments(new LiteralArgument("""
+                command /carpet <rule> <value> is deprecated.
+                Please use /lumina carpet config <set/get> <node> [value] (for saved changes)
+                and /lumina carpet config temp <set/get> <node> [value] (for temp changes)
+                """));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/CounterCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/CounterCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1e20094942abb3879ddd7a726ddb5bca3b22ddb
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/CounterCommand.java
@@ -0,0 +1,94 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import dev.jorel.commandapi.executors.CommandArguments;
+import dev.jorel.commandapi.executors.CommandExecutor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.DyeColor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static net.kyori.adventure.text.Component.*;
+
+public class CounterCommand {
+    public static void register() {
+        createBase()
+                .executes((CommandExecutor) (sender, args) -> listAllCounters(sender, false))
+                .register("carpet");
+        createBase()
+                .withArguments(new LiteralArgument("reset"))
+                .executes((CommandExecutor) (sender, args) -> resetCounters(sender))
+                .register("carpet");
+        createBaseWithColorArgument()
+                .executes((CommandExecutor) (sender, args) -> displayCounter(sender, args, false))
+                .register("carpet");
+        createBaseWithColorArgument()
+                .withArguments(new LiteralArgument("reset"))
+                .executes((CommandExecutor) (sender, args) -> resetCounter(sender, (DyeColor) args.get("color")))
+                .register("carpet");
+        createBaseWithColorArgument()
+                .withArguments(new LiteralArgument("realtime"))
+                .executes((CommandExecutor) (sender, args) -> displayCounter(sender, args, true))
+                .register("carpet");
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("counter")
+                .withPermission("carpet.command.counter");
+    }
+
+    private static CommandAPICommand createBaseWithColorArgument() {
+        return createBase()
+                .withArguments(dyeColorArgument("color"));
+    }
+
+    private static void displayCounter(CommandSender sender, @NotNull CommandArguments args, boolean realtime) {
+        HopperCounter counter = HopperCounter.getCounter((DyeColor) args.get("color"));
+
+        for (net.minecraft.network.chat.Component message : counter.format(MinecraftServer.getServer(), realtime, false)) {
+            sender.sendMessage(ComponentUtils.toAdventure(message));
+        }
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    private static void listAllCounters(CommandSender sender, boolean realtime) {
+        for (net.minecraft.network.chat.Component message : HopperCounter.formatAll(MinecraftServer.getServer(), realtime)) {
+            sender.sendMessage(ComponentUtils.toAdventure(message));
+        }
+    }
+
+    private static void resetCounters(@NotNull CommandSender sender) {
+        HopperCounter.resetAll(MinecraftServer.getServer(), false);
+        sender.sendMessage(text("Reset all counters"));
+    }
+
+    private static void resetCounter(@NotNull CommandSender sender, DyeColor color) {
+        HopperCounter.getCounter(color).reset(MinecraftServer.getServer());
+        sender.sendMessage(text("Reset " + color + " counter"));
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    private static @NotNull Argument<DyeColor> dyeColorArgument(String nodeName) {
+        return new CustomArgument<>(new StringArgument(nodeName), info -> {
+            DyeColor color = DYE_COLORS.getOrDefault(info.currentInput(), null);
+            if (color == null) {
+                throw CustomArgument.CustomArgumentException.fromMessageBuilder(
+                        new CustomArgument.MessageBuilder("Unsupported color: ").appendArgInput());
+            } else {
+                return color;
+            }
+        }).replaceSuggestions(ArgumentSuggestions.strings(DYE_COLORS.keySet()));
+    }
+
+    private static final Map<String, DyeColor> DYE_COLORS = new HashMap<>() {{
+        for (DyeColor dyeColor : DyeColor.values()) {
+            put(dyeColor.getName(), dyeColor);
+        }
+    }};
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/DistanceCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/DistanceCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..536d8ecfc07fe0588de7dffadb6527c79747a820
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/DistanceCommand.java
@@ -0,0 +1,83 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+import dev.jorel.commandapi.arguments.LocationArgument;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.utils.DistanceCalculator;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public class DistanceCommand {
+    public static void register() {
+        createBase("from").executesEntity((sender, args) -> {
+            DistanceCalculator.setStart(sender, getVec(sender));
+        }).register("carpet");
+        createBase("from")
+                .withArguments(new LocationArgument("from"))
+                .executes((sender, args) -> {
+                    Location from = (Location) args.get("from");
+                    if (from == null) {
+                        sender.sendMessage(text("Require start location").color(RED));
+                        return;
+                    }
+                    DistanceCalculator.setStart(sender, getVec(from));
+                }).register("carpet");
+        createBase("from")
+                .withArguments(
+                        new LocationArgument("from"),
+                        new LiteralArgument("to")
+                ).withOptionalArguments(new LocationArgument("to"))
+                .executes((sender, args) -> {
+                    Location from = (Location) args.get("from");
+                    if (from == null) {
+                        sender.sendMessage(text("Require start location").color(RED));
+                        return;
+                    }
+                    Location to = (Location) args.get("to");
+                    if (to == null) {
+                        if (sender instanceof Entity entity) {
+                            to = entity.getLocation();
+                        } else {
+                            sender.sendMessage(text("Require end location").color(RED));
+                            return;
+                        }
+                    }
+                    DistanceCalculator.distance(sender, getVec(from), getVec(to));
+                }).register("carpet");
+        createBase("to").executesEntity((sender, args) -> {
+            DistanceCalculator.setEnd(sender, getVec(sender));
+        }).register("carpet");
+        createBase("to")
+                .withArguments(new LocationArgument("to"))
+                .executes((sender, args) -> {
+                    Location to = (Location) args.get("to");
+                    if (to == null) {
+                        sender.sendMessage(text("Require end location").color(RED));
+                        return;
+                    }
+                    DistanceCalculator.setEnd(sender, getVec(to));
+                }).register("carpet");
+    }
+
+    private static CommandAPICommand createBase(String nodeName) {
+        return new CommandAPICommand("distance")
+                .withPermission("carpet.command.distance")
+                .withArguments(new LiteralArgument(nodeName));
+    }
+
+    @Contract("_ -> new")
+    private static @NotNull Vec3 getVec(@NotNull Entity entity) {
+        return getVec(entity.getLocation());
+    }
+
+    @Contract("_ -> new")
+    private static @NotNull Vec3 getVec(@NotNull Location location) {
+        return new Vec3(location.getX(), location.getY(), location.getZ());
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/InfoCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/InfoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..df59f4c3280ed0f4ef33ad24ca9dee8a556d190c
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/InfoCommand.java
@@ -0,0 +1,81 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.BlockInfo;
+import org.leavesmc.lumina.utils.LocationUtils;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static org.leavesmc.lumina.utils.LocationUtils.getSenderWorldOrDefault;
+
+public class InfoCommand {
+    public static void register() {
+        new CommandAPICommand("info")
+                .withPermission("carpet.command.info")
+                .withArguments(
+                        new LiteralArgument("block"),
+                        new LocationArgument("block", LocationType.BLOCK_POSITION)
+                ).withOptionalArguments(
+                        new LiteralArgument("grep").combineWith(new GreedyStringArgument("regexp"))
+                ).executes((sender, args) -> {
+                    infoBlock(sender, (Location) args.get("block"), (String) args.get("regexp"));
+                })
+                .register("carpet");
+    }
+
+    private static void printBlock(List<Component> messages, @NotNull CommandSender sender, String grep) {
+        sender.sendMessage("");
+        if (grep != null) {
+            Pattern p = Pattern.compile(grep);
+            sender.sendMessage(ComponentUtils.toAdventure(messages.getFirst()));
+            for (Component line : messages.subList(1, messages.size())) {
+                Matcher m = p.matcher(line.getString());
+                if (m.find()) {
+                    sender.sendMessage(ComponentUtils.toAdventure(line));
+                }
+            }
+        } else {
+            for (Component message : messages) {
+                sender.sendMessage(ComponentUtils.toAdventure(message));
+            }
+        }
+    }
+
+    private static void infoBlock(@NotNull CommandSender sender, Location pos, String grep) {
+        World world = getSenderWorldOrDefault(sender);
+        if (!sender.hasPermission("carpet.command.info.unloaded")) {
+            //check id pos is loaded
+            if (!world.isChunkGenerated(pos.blockX(), pos.blockZ())) {
+                sender.sendMessage(text("Chunk is not loaded").color(RED));
+                return;
+            }
+            // verify it is in world bounds
+            if (!world.getWorldBorder().isInside(pos)) {
+                sender.sendMessage(text("Position is outside of world bounds").color(RED));
+                return;
+            }
+        }
+        pos.setWorld(world);
+        ServerLevel finalLevel = ((CraftWorld) world).getHandle();
+        Bukkit.getRegionScheduler().run(CarpetServer.PLUGIN, pos,
+                task -> printBlock(
+                        BlockInfo.blockInfo(LocationUtils.toBlockPos(pos), finalLevel),
+                        sender,
+                        grep));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/LogCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/LogCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d26589b452d76147f4ad61927823fa5be7f28c8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/LogCommand.java
@@ -0,0 +1,167 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.ArgumentSuggestions;
+import dev.jorel.commandapi.arguments.EntitySelectorArgument;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+import dev.jorel.commandapi.arguments.StringArgument;
+import dev.jorel.commandapi.executors.CommandArguments;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+
+import java.util.Arrays;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.*;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+
+public class LogCommand {
+    public static void register() {
+        createBase()
+                .withArguments(new LiteralArgument("clear"))
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    unsubFromAll(sender, target);
+                })
+                .register("carpet");
+        createBaseWithLogName()
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    String logName = getLogName(sender, args);
+                    if (logName == null) {
+                        return;
+                    }
+                    toggleSubscription(sender, target, logName);
+                }).register("carpet");
+        createBaseWithLogName()
+                .withArguments(new StringArgument("option"))
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    String logName = getLogName(sender, args);
+                    if (logName == null) {
+                        return;
+                    }
+                    String option = getOption(sender, args, logName);
+                    if (option == null) {
+                        return;
+                    }
+                    subscribePlayer(sender, target, logName, option);
+                }).register("carpet");
+        createBaseWithLogName()
+                .withArguments(new LiteralArgument("clear"))
+                .withOptionalArguments(new EntitySelectorArgument.OnePlayer("target"))
+                .executes((sender, args) -> {
+                    Player target = getTarget(sender, args);
+                    if (target == null) {
+                        return;
+                    }
+                    String logName = getLogName(sender, args);
+                    if (logName == null) {
+                        return;
+                    }
+                    unsubFromLogger(sender, target, logName);
+                }).register("carpet");
+
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("log")
+                .withPermission("carpet.command.log");
+    }
+
+    private static CommandAPICommand createBaseWithLogName() {
+        return createBase()
+                .withArguments(new StringArgument("logName")
+                        .replaceSuggestions(ArgumentSuggestions.stringCollection(
+                                info -> LoggerRegistry.getLoggerNames())));
+    }
+
+    private static void unsubFromAll(CommandSender sender, Player target) {
+        for (String logName : LoggerRegistry.getLoggerNames()) {
+            LoggerRegistry.unsubscribePlayer(target.getName(), logName);
+        }
+        sender.sendMessage(text("Unsubscribed from all logs").color(GRAY).style(style(ITALIC)));
+    }
+
+    private static void unsubFromLogger(CommandSender sender, Player target, String logName) {
+        if (LoggerRegistry.getLogger(logName) == null) {
+            sender.sendMessage(text("Unknown logger: " + logName).color(RED));
+            return;
+        }
+        LoggerRegistry.unsubscribePlayer(target.getName(), logName);
+        sender.sendMessage(text("Unsubscribed from " + logName).color(GRAY).style(style(ITALIC)));
+    }
+
+    private static void toggleSubscription(CommandSender sender, Player target, String logName) {
+        if (LoggerRegistry.getLogger(logName) == null) {
+            sender.sendMessage(text("Unknown logger: " + logName).color(RED));
+            return;
+        }
+        boolean subscribed = LoggerRegistry.togglePlayerSubscription(target.getName(), logName);
+        if (subscribed) {
+            sender.sendMessage(text(target.getName() + " subscribed to " + logName + ".").color(GRAY));
+        } else {
+            sender.sendMessage(text(target.getName() + " unsubscribed from " + logName + ".").color(GRAY));
+        }
+    }
+
+    private static void subscribePlayer(CommandSender sender, Player target, String logName, String option) {
+        if (LoggerRegistry.getLogger(logName) == null) {
+            sender.sendMessage(text("Unknown logger: " + logName).color(RED));
+            return;
+        }
+        if (!LoggerRegistry.getLogger(logName).isOptionValid(option)) {
+            sender.sendMessage(text("Invalid option: " + option).color(RED));
+            return;
+        }
+        LoggerRegistry.subscribePlayer(target.getName(), logName, option);
+        if (option != null) {
+            sender.sendMessage(text("Subscribed to " + logName + "(" + option + ")").color(GRAY).style(style(ITALIC)));
+        } else {
+            sender.sendMessage(text("Subscribed to " + logName).color(GRAY).style(style(ITALIC)));
+        }
+    }
+
+    private static @Nullable Player getTarget(CommandSender sender, @NotNull CommandArguments args) {
+        Player target = (Player) args.get("target");
+        if (sender instanceof Player player) {
+            target = player;
+        }
+        if (target == null) {
+            sender.sendMessage(text("Must specified a player when run this in console").color(RED));
+        }
+        return target;
+    }
+
+    private static @Nullable String getLogName(CommandSender sender, @NotNull CommandArguments args) {
+        String logName = (String) args.get("logName");
+        if (logName == null || !LoggerRegistry.getLoggerNames().contains(logName)) {
+            sender.sendMessage(text("No such logger: " + logName).color(RED));
+        }
+        return logName;
+    }
+
+    private static @Nullable String getOption(CommandSender sender, @NotNull CommandArguments args, @NotNull String logName) {
+        String option = (String) args.get("option");
+        if (option == null || !Arrays.asList(LoggerRegistry.getLogger(logName).getOptions()).contains(option)) {
+            sender.sendMessage(text("No such option: " + option).color(RED));
+        }
+        return option;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f673832378af9529a2eb6fe18c25cda7398a5f61
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
@@ -0,0 +1,78 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.EntityTypeArgument;
+import dev.jorel.commandapi.arguments.LocationArgument;
+import dev.jorel.commandapi.arguments.LocationType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.Mob;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.PerimeterDiagnostics;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.*;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+import static org.leavesmc.lumina.utils.LocationUtils.*;
+
+public class PerimeterInfoCommand {
+    public static void register() {
+        createBase().withOptionalArguments(
+                new LocationArgument("center", LocationType.BLOCK_POSITION),
+                new EntityTypeArgument("mob")
+        ).executes((sender, args) -> {
+            Location location = getLocationWithDefaultWorld(sender, args, "center");
+            Bukkit.getRegionScheduler().run(
+                    CarpetServer.PLUGIN,
+                    location,
+                    task -> perimeterDiagnose(sender, location, (String) args.get("mob")));
+        }).register("carpet");
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("perimeterinfo")
+                .withPermission("lumina.command.perimeterinfo");
+    }
+
+    private static void perimeterDiagnose(CommandSender sender, @NotNull Location pos, String mobId) {
+        CompoundTag nbtTagCompound = new CompoundTag();
+        Mob entityliving = null;
+        ServerLevel level = ((CraftWorld) pos.getWorld()).getHandle();
+        BlockPos blockPos = toBlockPos(pos);
+        if (mobId != null) {
+            nbtTagCompound.putString("id", mobId);
+            net.minecraft.world.entity.Entity baseEntity = EntityType.loadEntityRecursive(nbtTagCompound, level, (entity1x) -> {
+                entity1x.moveTo(new BlockPos(blockPos.getX(), level.getMinBuildHeight() - 10, blockPos.getZ()), entity1x.getYRot(), entity1x.getXRot());
+                return !level.addWithUUID(entity1x) ? null : entity1x;
+            });
+            if (!(baseEntity instanceof Mob)) {
+                sender.sendMessage(text("/perimeterinfo requires a mob entity to test against.").color(RED));
+                if (baseEntity != null) {
+                    baseEntity.discard();
+                }
+                return;
+            }
+            entityliving = (Mob) baseEntity;
+        }
+        PerimeterDiagnostics.Result res = PerimeterDiagnostics.countSpots(level, blockPos, entityliving);
+
+        sender.sendMessage(ComponentUtils.toAdventure(Messenger.c("w Spawning spaces around ", Messenger.tp("c", blockPos), "w :")));
+        sender.sendMessage(text().append(text("potential in-liquid: ", WHITE)).append(text(res.liquid).style(style(BOLD))).build());
+        sender.sendMessage(text().append(text("potential on-ground: ", WHITE)).append(text(res.liquid).style(style(BOLD))).build());
+        if (entityliving != null) {
+            sender.sendMessage(text().append(text(entityliving.getDisplayName() + ": ", WHITE)).append(text(res.specific).style(style(BOLD))).build());
+            res.samples.forEach(bp -> sender.sendMessage(ComponentUtils.toAdventure(Messenger.c("w   ", Messenger.tp("c", bp)))));
+            entityliving.discard(); // discard // remove();
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b947732094ffccad603ad1dcc066766e72ed12b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java
@@ -0,0 +1,466 @@
+package org.leavesmc.lumina.carpet.command;
+
+import com.mojang.authlib.GameProfile;
+import dev.jorel.commandapi.CommandAPIBukkit;
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import dev.jorel.commandapi.executors.CommandArguments;
+import dev.jorel.commandapi.executors.CommandExecutor;
+import dev.jorel.commandapi.wrappers.Rotation;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.*;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.permissions.ServerOperator;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.helpers.EntityPlayerActionPack;
+import org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake;
+import org.leavesmc.lumina.utils.PermissionUtils;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Consumer;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static org.leavesmc.lumina.carpet.helpers.EntityPlayerActionPack.*;
+import static org.leavesmc.lumina.carpet.helpers.EntityPlayerActionPack.ActionType.*;
+import static org.leavesmc.lumina.utils.LocationUtils.getLocationWithDefaultWorld;
+
+public class PlayerCommand {
+    public static void register() {
+        SubCommandSpawn.register();
+        SubCommandKill.register();
+        registerActionCommand("use", USE);
+        registerActionCommand("jump", JUMP);
+        registerActionCommand("attack", ATTACK);
+        registerActionCommand("drop", DROP_ITEM);
+        registerDropCommand("drop", false);
+        registerActionCommand("dropStack", DROP_STACK);
+        registerDropCommand("dropStack", true);
+        registerActionCommand("swapHands", SWAP_HANDS);
+        registerManipulateCommand("mount", ap -> ap.mount(false));
+        registerManipulateCommand("mount", ap -> ap.mount(true), "anything");
+        registerManipulateCommand("dismount", EntityPlayerActionPack::dismount);
+        registerManipulateCommand("sneak", ap -> ap.setSneaking(true));
+        registerManipulateCommand("unsneak", ap -> ap.setSneaking(false));
+        registerManipulateCommand("sprint", ap -> ap.setSprinting(true));
+        registerManipulateCommand("unsprint", ap -> ap.setSprinting(false));
+        registerManipulateCommand("stop", EntityPlayerActionPack::stopAll);
+        registerSubCommandLook();
+        registerSubCommandTurn();
+        registerSubCommandMove();
+        createBase("shadow")
+                .executes((sender, args) -> {
+                    if (!canManipulate(sender, args, "shadow")) {
+                        return;
+                    }
+
+                    ServerPlayer player = getOnlineServerPlayer(args);
+                    if (player instanceof EntityPlayerMPFake) {
+                        sender.sendMessage(text("Cannot shadow fake players").color(RED));
+                        return;
+                    }
+                    if (MinecraftServer.getServer().isSingleplayerOwner(player.getGameProfile())) {
+                        sender.sendMessage(text("Cannot shadow single-player server owner").color(RED));
+                        return;
+                    }
+
+                    EntityPlayerMPFake.createShadow(player.server, player);
+                }).register("carpet");
+        // noinspection DataFlowIssue
+        createBase("hotbar")
+                .withArguments(new IntegerArgument("slot", 0, 8))
+                .executes((CommandExecutor) (sender, args) ->
+                        manipulate(sender, args, "hotbar",
+                                ap -> ap.setSlot((Integer) args.get("slot"))))
+                .register("carpet");
+        registerPermissions();
+    }
+
+    private static void registerPermissions() {
+        PermissionUtils.addPermissionAndBind(
+                "carpet.command.player",
+                "Player command",
+                List.of(
+                        "&.spawn",
+                        "&.kill",
+                        "&.shadow",
+                        "&.use",
+                        "&.jump",
+                        "&.attack",
+                        "&.drop",
+                        "&.dropStack",
+                        "&.swapHands",
+                        "&.hotbar",
+                        "&.mount",
+                        "&.dismount",
+                        "&.sneak",
+                        "&.unsneak",
+                        "&.sprint",
+                        "&.unsprint",
+                        "&.look",
+                        "&.turn",
+                        "&.move",
+                        "&.stop",
+                        "&.manipulate-real"
+                )
+        );
+        PermissionUtils.addPermissionAndBind(
+                createPlayerCommandPermission("look"),
+                "Look to a direction",
+                List.of(
+                        "&.north",
+                        "&.south",
+                        "&.east",
+                        "&.west",
+                        "&.up",
+                        "&.down",
+                        "&.at",
+                        "&.direction"
+                )
+        );
+        PermissionUtils.addPermissionAndBind(
+                createPlayerCommandPermission("turn"),
+                "Turn to a direction",
+                List.of(
+                        "&.left",
+                        "&.right",
+                        "&.back",
+                        "&.rotation"
+                )
+        );
+        PermissionUtils.addPermissionAndBind(
+                createPlayerCommandPermission("move"),
+                "Move to a direction",
+                List.of(
+                        "&.forward",
+                        "&.backward",
+                        "&.left",
+                        "&.right"
+                )
+        );
+    }
+
+    private static class SubCommandSpawn {
+        public static void register() {
+            createBase("spawn")
+                    .withOptionalArguments(
+                            new LiteralArgument("at").combineWith(new LocationArgument("position")),
+                            new LiteralArgument("facing").combineWith(new RotationArgument("direction")),
+                            new LiteralArgument("in").combineWith(new WorldArgument("dimension")),
+                            new LiteralArgument("in")
+                                    .withRequirement(ServerOperator::isOp)
+                                    .combineWith(new MultiLiteralArgument("gamemode", Arrays
+                                            .stream(GameType.values())
+                                            .map(GameType::name)
+                                            .toArray(String[]::new)))
+                    ).executes(SubCommandSpawn::spawn).register("carpet");
+        }
+
+        private static void spawn(CommandSender sender, CommandArguments args) {
+            if (!canSpawn(sender, args)) {
+                return;
+            }
+            Location pos = null;
+            Rotation facing = new Rotation(0, 0);
+            World world = Bukkit.getWorlds().getFirst();
+            GameType mode = GameType.CREATIVE;
+            boolean flying = false;
+            if (sender instanceof Player player) {
+                ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+                pos = player.getLocation();
+                facing = new Rotation(player.getLocation().getYaw(), player.getLocation().getPitch());
+                world = player.getWorld();
+                mode = serverPlayer.gameMode.getGameModeForPlayer();
+                flying = serverPlayer.getAbilities().flying;
+            }
+            pos = (Location) args.getOrDefault("position", pos);
+            facing = (Rotation) args.getOrDefault("direction", facing);
+            world = (World) args.getOrDefault("dimension", world);
+            if (pos == null) {
+                sender.sendMessage(text("Need position to spawn player in console").color(RED));
+                return;
+            }
+            pos.setWorld(world);
+            GameMode nullableGameMode = (GameMode) args.get("gamemode");
+            if (nullableGameMode != null) {
+                mode = GameType.byId(nullableGameMode.getValue());
+            }
+
+            if (mode == GameType.SPECTATOR) {
+                // Force override flying to true for spectator players, or they will fell out of the world.
+                flying = true;
+            } else if (mode.isSurvival()) {
+                // Force override flying to false for survival-like players, or they will fly too
+                flying = false;
+            }
+            String playerName = getPlayerName(args);
+            if (playerName.length() > SharedConstants.MAX_PLAYER_NAME_LENGTH) {
+                sender.sendMessage(text("Player name: " + playerName + " is too long").color(RED));
+                return;
+            }
+
+            if (!Level.isInSpawnableBounds(BlockPos.containing(pos.getX(), pos.getY(), pos.getZ()))) {
+                sender.sendMessage(text("Player " + playerName + " cannot be placed outside of the world").color(RED));
+                return;
+            }
+            boolean success = EntityPlayerMPFake.createFake(playerName, MinecraftServer.getServer(), pos, facing.getPitch(), facing.getYaw(), world, mode, flying);
+            if (!success) {
+                sender.sendMessage(text("Player " + playerName + " doesn't exist and cannot spawn in online mode. Turn the server offline or the allowSpawningOfflinePlayers on to spawn non-existing players").color(RED));
+            }
+        }
+
+        private static boolean canSpawn(CommandSender sender, CommandArguments args) {
+            String playerName = getPlayerName(args);
+            MinecraftServer server = MinecraftServer.getServer();
+            PlayerList manager = server.getPlayerList();
+
+            if (manager.getPlayerByName(playerName) != null) {
+                sender.sendMessage(text("Player " + playerName + " is already logged on").color(RED));
+                return false;
+            }
+            @SuppressWarnings("DataFlowIssue") GameProfile profile = server.getProfileCache().get(playerName).orElse(null);
+            if (profile == null) {
+                if (!CarpetConfig.configModule.allowSpawningOfflinePlayers) {
+                    sender.sendMessage(text("Player " + playerName + " is either banned by Mojang, or auth servers are down. Banned players can only be summoned in Singleplayer and in servers in off-line mode.").color(RED));
+                    return false;
+                } else {
+                    profile = new GameProfile(UUIDUtil.createOfflinePlayerUUID(playerName), playerName);
+                }
+            }
+            if (manager.getBans().isBanned(profile)) {
+                sender.sendMessage(text("Player" + playerName + "is banned on this server").color(RED));
+                return false;
+            }
+            if (manager.isUsingWhitelist() && manager.isWhiteListed(profile) && !sender.isOp()) {
+                sender.sendMessage(text("Whitelisted players can only be spawned by operators").color(RED));
+                return false;
+            }
+            return true;
+        }
+    }
+
+    private static class SubCommandKill {
+        public static void register() {
+            createBase("kill")
+                    .executes(SubCommandKill::kill)
+                    .register("carpet");
+        }
+
+        private static void kill(CommandSender sender, CommandArguments args) {
+            if (!canKill(sender, args)) {
+                return;
+            }
+            Player player = getOnlinePlayer(args);
+            ((CraftPlayer) player).getHandle().kill();
+            sender.sendMessage(text("Player " + player.getName() + " has been killed").color(GREEN));
+        }
+
+        private static boolean canKill(CommandSender sender, CommandArguments args) {
+            ServerPlayer player = getOnlineServerPlayer(args);
+            if (player instanceof EntityPlayerMPFake) {
+                return canManipulate(sender, args, "kill");
+            }
+            sender.sendMessage(text("Only fake players can be killed by this command").color(RED));
+            return false;
+        }
+    }
+
+    private static void registerSubCommandLook() {
+        registerManipulateCommand("look", ap -> ap.look(Direction.NORTH), "north");
+        registerManipulateCommand("look", ap -> ap.look(Direction.SOUTH), "south");
+        registerManipulateCommand("look", ap -> ap.look(Direction.EAST), "east");
+        registerManipulateCommand("look", ap -> ap.look(Direction.WEST), "west");
+        registerManipulateCommand("look", ap -> ap.look(Direction.UP), "up");
+        registerManipulateCommand("look", ap -> ap.look(Direction.DOWN), "down");
+        createBase("look")
+                .withArguments(
+                        new LiteralArgument("direction"),
+                        new RotationArgument("direction")
+                ).executes((CommandExecutor) (sender, args) ->
+                        manipulate(sender, args, "look",
+                                ap -> {
+                                    Rotation rotation = (Rotation) args.get("direction");
+                                    if (rotation == null) {
+                                        sender.sendMessage(text("Invalid rotation").color(RED));
+                                        return;
+                                    }
+                                    ap.look(new Vec2(rotation.getYaw(), rotation.getPitch()));
+                                })
+                ).register("carpet");
+        createBase("look")
+                .withArguments(
+                        new LiteralArgument("at"),
+                        new LocationArgument("position")
+                ).executes((CommandExecutor) (sender, args) ->
+                        manipulate(sender, args, "look",
+                                ap -> {
+                                    Location location = getLocationWithDefaultWorld(sender, args, "position");
+                                    ap.lookAt(new Vec3(location.getX(), location.getY(), location.getZ()));
+                                })
+                ).register("carpet");
+    }
+
+    private static void registerSubCommandTurn() {
+        registerManipulateCommand("turn", ap -> ap.turn(-90, 0), "left");
+        registerManipulateCommand("turn", ap -> ap.turn(90, 0), "right");
+        registerManipulateCommand("turn", ap -> ap.turn(180, 0), "back");
+        createBase("turn")
+                .withArguments(new RotationArgument("rotation"))
+                .executes((CommandExecutor) (sender, args) ->
+                        manipulate(sender, args, "turn",
+                                ap -> {
+                                    Rotation rotation = (Rotation) args.get("rotation");
+                                    if (rotation == null) {
+                                        sender.sendMessage(text("Invalid rotation").color(RED));
+                                        return;
+                                    }
+                                    ap.turn(rotation.getYaw(), rotation.getPitch());
+                                })
+                ).register("carpet");
+    }
+
+    private static void registerSubCommandMove() {
+        registerManipulateCommand("move", EntityPlayerActionPack::stopMovement);
+        registerManipulateCommand("move", EntityPlayerActionPack::stopMovement, "stop");
+        registerManipulateCommand("move", ap -> ap.setForward(1), "forward");
+        registerManipulateCommand("move", ap -> ap.setForward(-1), "backward");
+        registerManipulateCommand("move", ap -> ap.setStrafing(-1), "right");
+        registerManipulateCommand("move", ap -> ap.setStrafing(1), "left");
+    }
+
+    private static void registerManipulateCommand(String name, Consumer<EntityPlayerActionPack> action, String literal) {
+        createBase(name)
+                .withArguments(new MultiLiteralArgument("_literals", literal))
+                .executes((CommandExecutor) (sender, args2) -> manipulate(sender, args2, name, action))
+                .register("carpet");
+    }
+
+    private static void registerManipulateCommand(String name, Consumer<EntityPlayerActionPack> action) {
+        createBase(name)
+                .executes((CommandExecutor) (sender, args2) -> manipulate(sender, args2, name, action))
+                .register("carpet");
+    }
+
+    private static void registerActionCommand(String name, ActionType type) {
+        registerManipulateCommand(name, ap -> ap.start(type, Action.once()));
+        registerManipulateCommand(name, ap -> ap.start(type, Action.once()), "once");
+        registerManipulateCommand(name, ap -> ap.start(type, Action.continuous()), "continuous");
+        // noinspection DataFlowIssue
+        createBase(name)
+                .withArguments(
+                        new LiteralArgument("interval"),
+                        new IntegerArgument("ticks", 1)
+                ).executes((CommandExecutor) (sender, args) ->
+                        manipulate(sender, args, name,
+                                ap -> ap.start(type, Action.interval((Integer) args.get("ticks"))))
+                ).register("carpet");
+    }
+
+    private static void registerDropCommand(String name, boolean dropAll) {
+        registerManipulateCommand(name, ap -> ap.drop(-2, dropAll), "all");
+        registerManipulateCommand(name, ap -> ap.drop(-1, dropAll), "mainhand");
+        registerManipulateCommand(name, ap -> ap.drop(40, dropAll), "offhand");
+        // noinspection DataFlowIssue
+        createBase(name)
+                .withArguments(new IntegerArgument("slot", 0, 40))
+                .executes((CommandExecutor) (sender, args) ->
+                        manipulate(sender, args, name,
+                                ap -> ap.drop((Integer) args.get("slot"), dropAll))
+                ).register("carpet");
+
+    }
+
+    private static void manipulate(CommandSender sender, CommandArguments args, String name, Consumer<EntityPlayerActionPack> action) {
+        if (!canManipulate(sender, args, name)) {
+            return;
+        }
+        action.accept(getOnlineServerPlayer(args).getActionPack());
+    }
+
+    private static CommandAPICommand createBase(String literal) {
+        return new CommandAPICommand("player")
+                .withPermission("carpet.command.player")
+                .withArguments(
+                        new StringArgument("player").replaceSuggestions(ArgumentSuggestions.strings(info ->
+                                MinecraftServer
+                                        .getServer()
+                                        .getPlayerList()
+                                        .getPlayers()
+                                        .stream().map(ServerPlayer::getScoreboardName)
+                                        .toArray(String[]::new))),
+                        new LiteralArgument(literal)
+                ).withPermission(createPlayerCommandPermission(literal));
+    }
+
+    private static boolean canManipulate(@NotNull CommandSender sender, CommandArguments args, String name) {
+        String permission = createPlayerCommandPermission(name);
+        if (sender.hasPermission(permission)) {
+            Player player = getOnlinePlayer(args);
+            if (sender == player || player instanceof EntityPlayerMPFake) {
+                return true;
+            }
+            String manipulateRealPermission = createPlayerCommandPermission("manipulate-real");
+            if (sender.hasPermission(manipulateRealPermission)) {
+                return true;
+            }
+            permission = permission + " and " + manipulateRealPermission;
+        }
+        sender.sendMessage(text("Require permission: " + permission).color(RED));
+        return false;
+    }
+
+    private static @NotNull Player getOnlinePlayer(CommandArguments args) {
+        String playerName = getPlayerName(args);
+        Player player = Bukkit.getPlayer(playerName);
+        if (player == null) {
+            throw CommandAPIBukkit.failWithAdventureComponent(text("No such player").color(RED));
+        }
+        return player;
+    }
+
+    private static @NotNull ServerPlayer getOnlineServerPlayer(CommandArguments args) {
+        String playerName = getPlayerName(args);
+        ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayerByName(playerName);
+        if (player == null) {
+            throw CommandAPIBukkit.failWithAdventureComponent(text("No such player").color(RED));
+        }
+        return player;
+    }
+
+    private static @NotNull String getPlayerName(@NotNull CommandArguments args) {
+        String playerName = (String) args.get("player");
+        if (playerName == null) {
+            throw CommandAPIBukkit.failWithAdventureComponent(text("Require player name").color(RED));
+        }
+        String prefix = CarpetConfig.configModule.fakePlayerNamePrefix;
+        String suffix = CarpetConfig.configModule.fakePlayerNameSuffix;
+        if ("#none".equals(prefix)) {
+            prefix = "";
+        }
+        if ("#none".equals(suffix)) {
+            suffix = "";
+        }
+        return prefix + playerName + suffix;
+    }
+
+    @Contract(pure = true)
+    private static @NotNull String createPlayerCommandPermission(String sub) {
+        return "carpet.command.player." + sub;
+    }
+
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/SpawnCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/SpawnCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f43eadcff973f176275d87610b2fed1262a820f6
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/SpawnCommand.java
@@ -0,0 +1,82 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.LiteralArgument;
+import dev.jorel.commandapi.arguments.LocationArgument;
+import dev.jorel.commandapi.arguments.LocationType;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.SpawnReporter;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.*;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+import static org.leavesmc.lumina.utils.ComponentUtils.toAdventure;
+import static org.leavesmc.lumina.utils.LocationUtils.*;
+
+public class SpawnCommand {
+    public static void register() {
+        createBase("list")
+                .withArguments(new LocationArgument("pos", LocationType.BLOCK_POSITION))
+                .executes((sender, args) -> {
+                    listSpawns(sender, ((Location) args.get("pos")));
+                })
+                .register("carpet");
+        if(true) return; // TODO: Implement this
+        createBase("tracking")
+                .withArguments(new LiteralArgument("start"))
+                .withOptionalArguments(
+                        new LocationArgument("from", LocationType.BLOCK_POSITION)
+                                .combineWith(new LocationArgument("to", LocationType.BLOCK_POSITION))
+                ).executes((sender, args) -> {
+                    if (SpawnReporter.trackingSpawns()) {
+                        sender.sendMessage(text("Spawning tracking already started.").color(RED));
+                        return;
+                    }
+                    Location from = (Location) args.get("from");
+                    Location to = (Location) args.get("to");
+                    if (from == null && to == null) {
+                        SpawnReporter.startTracking(MinecraftServer.getServer(), null);
+                        sender.sendMessage(text("Spawning tracking started.").color(GRAY).style(style(ITALIC)));
+                        return;
+                    }
+                    if (from == null || to == null) {
+                        sender.sendMessage(text("Please specify the area to track an area or call `/spawn tracking start` to track all area)").color(RED));
+                        return;
+                    }
+                    SpawnReporter.startTracking(
+                            MinecraftServer.getServer(),
+                            BoundingBox.fromCorners(toBlockPos(from), toBlockPos(to)));
+                    sender.sendMessage(text("Spawning tracking started.").color(GRAY).style(style(ITALIC)));
+                })
+                .register("carpet");
+        createBase("tracking")
+                .withArguments(new LiteralArgument("stop"))
+                .executes(((sender, args) -> {
+                    for (Component component : SpawnReporter.makeTrackingReport(getLevel(getSenderWorldOrDefault(sender)))) {
+                        sender.sendMessage(toAdventure(component));
+                    }
+                    SpawnReporter.stopTracking(MinecraftServer.getServer());
+                    sender.sendMessage(text("Spawning tracking stopped.").color(GRAY).style(style(ITALIC)));
+                }))
+                .register("carpet");
+    }
+
+    private static CommandAPICommand createBase(String literal) {
+        return new CommandAPICommand("spawn")
+                .withPermission("carpet.command.spawn")
+                .withArguments(new LiteralArgument(literal));
+    }
+
+    private static void listSpawns(CommandSender sender, Location pos) {
+
+        for (Component component : SpawnReporter.report(toBlockPos(pos), getLevel(pos))) {
+            sender.sendMessage(toAdventure(component));
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/TrackCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/TrackCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ae1870a9e6b19cfc750b93feb189c1854e35565
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/TrackCommand.java
@@ -0,0 +1,74 @@
+package org.leavesmc.lumina.carpet.command;
+
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import org.leavesmc.lumina.carpet.utils.MobAI;
+import org.leavesmc.lumina.carpet.utils.MobAI.TrackingType;
+
+import java.util.Map;
+import java.util.Set;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static org.leavesmc.lumina.carpet.utils.MobAI.TrackingType.*;
+
+public class TrackCommand {
+    public static void register() {
+        createBase()
+                .withArguments(new LiteralArgument("clear"))
+                .executes((sender, args) -> {
+                    System.out.println(args.get("type"));
+                    MobAI.clearTracking(MinecraftServer.getServer(), (EntityType<? extends Entity>) args.get("type"));
+                    return 1;
+                }).register("carpet");
+        createBase()
+                .withArguments(new StringArgument("aspect").replaceSuggestions(
+                        ArgumentSuggestions.strings(info ->
+                                ASPECTS.get((EntityType<?>) info.previousArgs().get("type")).toArray(new String[0])))
+                ).executes((sender, args) -> {
+                    String aspectStr = (String) args.get("aspect");
+                    if (aspectStr == null) {
+                        sender.sendMessage(text("Aspect is required").color(RED));
+                        return;
+                    }
+                    try {
+                        TrackingType aspect = valueOf(aspectStr.toUpperCase());
+                        MobAI.startTracking((EntityType<?>) args.get("type"), aspect);
+                    } catch (IllegalArgumentException ignored) {
+                        sender.sendMessage(text("Invalid aspect: ").append(text(aspectStr).color(RED)));
+                    }
+
+                }).register("carpet");
+    }
+
+    private static CommandAPICommand createBase() {
+        return new CommandAPICommand("track")
+                .withPermission("lumina.command.track")
+                .withArguments(trackTypeArgument("type"));
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    public static Argument<EntityType<? extends Entity>> trackTypeArgument(String nodeName) {
+        return new CustomArgument<EntityType<? extends Entity>, String>(new StringArgument(nodeName), info -> {
+            EntityType<? extends Entity> type = ENTITY_TYPES.getOrDefault(info.currentInput(), null);
+            if (type == null) {
+                throw CustomArgument.CustomArgumentException.fromMessageBuilder(
+                        new CustomArgument.MessageBuilder("Unsupported entity type: ").appendArgInput());
+            } else {
+                return type;
+            }
+        }).replaceSuggestions(ArgumentSuggestions.strings("villager"));
+    }
+
+    private static final Map<String, EntityType<? extends Entity>> ENTITY_TYPES = Map.of(
+            "villager", EntityType.VILLAGER
+    );
+
+    @SuppressWarnings("MapOrSetKeyShouldOverrideHashCodeEquals")
+    private static final Map<EntityType<? extends Entity>, Set<String>> ASPECTS = Map.of(
+            EntityType.VILLAGER, Set.of("breeding", "iron_golem_spawning")
+    );
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..82aaa736e5e502b18d6cc758a9be4369493db295
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config;
+
+import java.lang.reflect.Field;
+
+public record ConfigNodeInfo(
+        String[] suggestions,
+        Class<?> type,
+        Field field,
+        Object parent, Object fileParent, Object tempParent,
+        Validator<?> validator) {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd8a160950415d50d3865794c34cfe27eb1c5450
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
@@ -0,0 +1,112 @@
+package org.leavesmc.lumina.config;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfigModule;
+import org.leavesmc.lumina.utils.ConfigUtils;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+import org.spongepowered.configurate.loader.ConfigurationLoader;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+
+public class LuminaConfig {
+    public static LuminaConfigModule configModule, fileModule, tempModule;
+    private static ConfigurationLoader<CommentedConfigurationNode> loader;
+    private static CommentedConfigurationNode node;
+    public static Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+
+    public static void setup() {
+        Path hoconConfigPath = Path.of("lumina.conf");
+        boolean useHocon = Boolean.getBoolean("lumina.config.style.hocon") || Files.exists(hoconConfigPath);
+        boolean jsonStyle = Boolean.getBoolean("lumina.config.style.json");
+        if (useHocon || jsonStyle) {
+            loader = HoconConfigurationLoader.builder()
+                    .emitComments(true)
+                    .emitJsonCompatible(jsonStyle)
+                    .prettyPrinting(true)
+                    .path(hoconConfigPath)
+                    .build();
+        } else {
+            loader = YamlConfigurationLoader.builder()
+                    .nodeStyle(NodeStyle.BLOCK)
+                    .indent(2)
+                    .path(Path.of("lumina.yml"))
+                    .build();
+        }
+
+        loadConfig();
+        saveConfig();
+    }
+
+    private static void generateNodeInfos() {
+        try {
+            ConfigUtils.generateNodeInfos(nodeInfos, LuminaConfigModule.class, null, configModule, fileModule, tempModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void mergeConfig() {
+        try {
+            node.set(fileModule);
+            if (tempModule == null) {
+                tempModule = loader.createNode().get(LuminaConfigModule.class);
+            }
+            node.from(loader.createNode().set(LuminaConfigModule.class, tempModule));
+            configModule = node.get(LuminaConfigModule.class);
+            generateNodeInfos();
+        } catch (SerializationException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void reload() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        loadConfig();
+    }
+
+    private static void loadConfig() {
+        try {
+            node = loader.load();
+            configModule = node.get(LuminaConfigModule.class);
+            fileModule = node.get(LuminaConfigModule.class);
+            tempModule = loader.createNode().get(LuminaConfigModule.class);
+            generateNodeInfos();
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void save() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        saveConfig();
+    }
+
+    private static void saveConfig() {
+        try {
+            node.set(LuminaConfigModule.class, fileModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> reloadAsync() {
+        return ConfigUtils.runAsync(LuminaConfig::reload);
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> saveAsync() {
+        return ConfigUtils.runAsync(LuminaConfig::save);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c2bf30ef6035575e56c8743f1abee8ac8b8d558
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config;
+
+import org.leavesmc.lumina.config.modules.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LuminaConfigModule {
+    public String configVersion = "1";
+    public Fix fix = new Fix();
+    public Protocol protocol = new Protocol();
+    public Performance performance = new Performance();
+    public Modify modify = new Modify();
+    public Misc misc = new Misc();
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/Validator.java b/src/main/java/org/leavesmc/lumina/config/Validator.java
new file mode 100644
index 0000000000000000000000000000000000000000..18cc13bccf468ae730402449be0bd5303a39ee39
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/Validator.java
@@ -0,0 +1,121 @@
+package org.leavesmc.lumina.config;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+public class Validator<T> {
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public boolean validate(T newValue, T oldValue) {
+        return true;
+    }
+
+    public String getErrorMessage(T newValue) {
+        return "Invalid value: " + newValue;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateString(@NotNull ConfigNodeInfo nodeInfo, String newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<String> validator = (Validator<String>) nodeInfo.validator();
+                if (!validator.validate(newValue, (String) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateBoolean(@NotNull ConfigNodeInfo nodeInfo, Boolean newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Boolean> validator = (Validator<Boolean>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Boolean) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateInteger(@NotNull ConfigNodeInfo nodeInfo, Integer newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Integer> validator = (Validator<Integer>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Integer) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateLong(@NotNull ConfigNodeInfo nodeInfo, Long newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Long> validator = (Validator<Long>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Long) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateDouble(@NotNull ConfigNodeInfo nodeInfo, Double newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Double> validator = (Validator<Double>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Double) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <E> ValidationResult validate(@NotNull ConfigNodeInfo nodeInfo, E newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<E> validator = (Validator<E>) nodeInfo.validator();
+                if (!validator.validate(newValue, (E) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    public enum ValidationResultType {
+        PASS, FAILED
+    }
+
+    public record ValidationResult(ValidationResultType type, String message) {
+        @Contract(" -> new")
+        public static @NotNull ValidationResult pass() {
+            return new ValidationResult(ValidationResultType.PASS, null);
+        }
+
+        @Contract("_ -> new")
+        public static @NotNull ValidationResult failed(String message) {
+            return new ValidationResult(ValidationResultType.FAILED, message);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7a2e319e7dbc733b9ec9f9b67ec4ddf182dc6df
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
@@ -0,0 +1,15 @@
+package org.leavesmc.lumina.config.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * 在用户使用命令修改Config时提供常量字符串列表建议
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Suggestion {
+    String[] value() default {};
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fff13fd26a134118dac8949ee061c92055fdbde
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.annotations;
+
+import org.leavesmc.lumina.config.Validator;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Validate {
+    Class<? extends Validator> value() default Validator.class;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Fix.java b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
new file mode 100644
index 0000000000000000000000000000000000000000..4df98b3dd4a42068c43a98c399b8ebbfe3157119
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.fix.FixFoliaEntityMovingFixConfig;
+import org.leavesmc.lumina.config.modules.fix.FixFoliaTeleportAsyncConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Fix {
+    public FixFoliaEntityMovingFixConfig fixFoliaEntityMoving = new FixFoliaEntityMovingFixConfig();
+    public FixFoliaTeleportAsyncConfig fixFoliaTeleportAsync = new FixFoliaTeleportAsyncConfig();
+    public boolean fixFoliaSpectorTeleport = true;
+    public boolean allowUnsafeTeleportation = true;
+    public boolean fixVoidTrading = true;
+    public boolean useVanillaRandomSourceForPlayers = true;
+    public boolean fixFoliaPoiAccessOffRegion = true;
+    public boolean mc2025 = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Misc.java b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6f41a391d597655d799249a17445dda22c83f03
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
@@ -0,0 +1,20 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.misc.RegionFormatConfig;
+import org.leavesmc.lumina.config.modules.misc.WatchdogConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Misc {
+    public boolean mojangChatSign = true;
+    public boolean allowInorderChat = true;
+    public boolean offlineModeWarning = true;
+    public String serverModName = "Lumina";
+    public boolean fakeVanilla = false;
+    public boolean checkUsername = true;
+    public boolean alternativeKeepAlive = true;
+    public boolean saveConfigAfterSet = true;
+    public boolean verifyPublicKeyOnlyInOnlineMode = false;
+    public WatchdogConfig watchdog = new WatchdogConfig();
+    public RegionFormatConfig regionFormat = new RegionFormatConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Modify.java b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
new file mode 100644
index 0000000000000000000000000000000000000000..b22fa9a59a6a26788a26ba217ac6e8847c71d9f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
@@ -0,0 +1,7 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Modify {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
new file mode 100644
index 0000000000000000000000000000000000000000..4739bdb828be18d9bec7ae2d6c6b332de879acee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.performance.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Performance {
+    public PetalReduceSensorWorkConfig petalReduceSensorWork = new PetalReduceSensorWorkConfig();
+    public ProjectileChunkReduceConfig projectileChunkReduce = new ProjectileChunkReduceConfig();
+    public DynamicEntityActivationRangeConfig dynamicEntityActivationRange = new DynamicEntityActivationRangeConfig();
+    public boolean entityGoalSelectorInactiveTick = false;
+    public boolean allowLoadChunksToActiveClimbingEntities = false;
+    public boolean optimizeSuffocation = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d91f7ea07e768c6e2c60386e143242fc20e9152
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.protocol.LeavesBladerenProtocolConfig;
+import org.leavesmc.lumina.config.modules.protocol.PcaSyncProtocolConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Protocol {
+    public boolean carpetProtocol = false;
+    public boolean jadeProtocol = false;
+    public boolean bborProtocol = false;
+    public PcaSyncProtocolConfig pcaSyncProtocol = new PcaSyncProtocolConfig();
+    public LeavesBladerenProtocolConfig leavesBladerenProtocol = new LeavesBladerenProtocolConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abda15610a48676d145ef26bae7a7340b88b0ee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaEntityMovingFixConfig {
+    public boolean enabled = false;
+    public boolean warnOnDetected = true;
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..b043bf36de0604028cb7bdd166d000d2dec76360
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaTeleportAsyncConfig {
+    public boolean enabled = false;
+    public boolean throwOnDetected = true;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..35aed045ceb1f7647de4b0efbf7c609f62c402d8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.stupidcraft.linearpaper.region.EnumRegionFileExtension;
+
+@ConfigSerializable
+public class RegionFormatConfig {
+    public EnumRegionFileExtension format = EnumRegionFileExtension.MCA;
+    public int linearCompressionLevel = 1;
+    public int linearFlushFrequency = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e79b3e1dfa56896c20e3b7e9c9d0cc37257af05
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class WatchdogConfig {
+    public boolean enabled = false;
+    public long warnPeriodTicks = 5 * 20;
+    public long timeOutTicks = 30 * 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..92334d8b7617616f3991fd58949e3714d159eeed
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+
+@ConfigSerializable
+public class DynamicEntityActivationRangeConfig {
+    public boolean enabled = false;
+    public int startDistanceSquared = 144;
+    public int maximumActivationPriority = 20;
+    public int activationDistanceMod = 8;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..db160578fa0d35a275f953e88f04340c20d08942
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
@@ -0,0 +1,8 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LoadChunksToActiveClimbingEntitiesConfig {
+    public boolean allow = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..eed3fe3a9a7d5aa6eeeb3c2c3a40d73eafdd3f3f
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PetalReduceSensorWorkConfig {
+    public boolean enabled = true;
+    public int delayTicks = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb64dd4c224c9246fa8d999c8217096f7bebe89b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class ProjectileChunkReduceConfig {
+    public int maxProjectileLoadsPerTick;
+    public int maxProjectileLoadsPerProjectile;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..75352347781b590ddef6680bd8816bdc06631640
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LeavesBladerenProtocolConfig {
+    public boolean enableBaseProtocol = false;
+    public boolean msptSyncProtocol = false;
+    public int msptSyncTickInterval = 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..119b50c12f08c548e7a56dd983805324526fc35e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PcaSyncProtocolConfig {
+    public boolean enabled = false;
+    public SyncOption sync = SyncOption.OPS;
+
+    public enum SyncOption {
+        NOBODY,
+        BOT,
+        OPS,
+        OPS_AND_SELF,
+        EVERYONE
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ComponentUtils.java b/src/main/java/org/leavesmc/lumina/utils/ComponentUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..028e817aa724f643f730d4edb91f5e6e7e5f0363
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ComponentUtils.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.utils;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.server.MinecraftServer;
+import org.jetbrains.annotations.NotNull;
+
+public class ComponentUtils {
+    public static @NotNull Component toAdventure(net.minecraft.network.chat.Component from) {
+        return GsonComponentSerializer.gson().deserialize(
+                net.minecraft.network.chat.Component.Serializer
+                        .toJson(from, MinecraftServer.getServer().registryAccess()));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java b/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..43f8e44ce868f98cb6c7efa1484878691b09140b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java
@@ -0,0 +1,107 @@
+package org.leavesmc.lumina.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.InternalJavaPluginFactory;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfigModule;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+import org.spongepowered.configurate.loader.AbstractConfigurationLoader;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+
+public class ConfigUtils {
+    static final Set<Class<?>> CONFIG_FIELD_TYPES = new HashSet<>(Arrays.asList(
+            String.class,
+            boolean.class,
+            int.class,
+            long.class,
+            double.class));
+    static final Plugin INTERNAL_PLUGIN = InternalJavaPluginFactory.create("LuminaConfigSystem");
+
+    @Contract("_ -> new")
+    public static @NotNull CompletableFuture<Void> runAsync(Runnable runnable) {
+        return CompletableFuture.runAsync(runnable, task -> Bukkit.getGlobalRegionScheduler().run(ConfigUtils.INTERNAL_PLUGIN, scheduled -> task.run()));
+    }
+
+    public static void generateNodeInfos(Map<String, ConfigNodeInfo> nodeInfoMap, @NotNull Class<?> clazz, String parentKey, @NotNull Object parent, @NotNull Object fileParent, @NotNull Object tempParent) throws IllegalAccessException {
+        for (Field field : clazz.getFields()) {
+            String fieldName = field.getName();
+            Class<?> fieldType = field.getType();
+            String key = parentKey == null ? toHyphen(fieldName) : parentKey + "." + toHyphen(fieldName);
+            boolean haveSuggestions = false;
+            String[] suggestions = null;
+            Validator<?> validator = new Validator<>();
+            for (Annotation annotation : field.getAnnotations()) {
+                if (annotation instanceof Suggestion value) {
+                    haveSuggestions = true;
+                    suggestions = value.value();
+                } else if (annotation instanceof Validate value) {
+                    try {
+                        validator = value.value().getDeclaredConstructor().newInstance();
+                    } catch (InstantiationException | InvocationTargetException | NoSuchMethodException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+            if (!haveSuggestions) {
+                if ("boolean".equals(fieldType.getSimpleName())) {
+                    suggestions = new String[]{"true", "false"};
+                    haveSuggestions = true;
+                } else if (ConfigUtils.CONFIG_FIELD_TYPES.contains(fieldType)) {
+                    suggestions = new String[]{field.get(parent).toString()};
+                    haveSuggestions = true;
+                } else if (fieldType.isEnum()) {
+                    suggestions = Arrays.stream(fieldType.getEnumConstants()).map(Object::toString).toArray(String[]::new);
+                    haveSuggestions = true;
+                }
+            }
+            if (haveSuggestions) {
+                nodeInfoMap.put(key, new ConfigNodeInfo(suggestions, fieldType, field, parent, fileParent, tempParent, validator));
+            } else {
+                generateNodeInfos(nodeInfoMap, fieldType, key, field.get(parent), field.get(fileParent), field.get(tempParent));
+            }
+        }
+    }
+
+    private static @NotNull String toHyphen(String input) {
+        if (input == null || input.isEmpty()) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < input.length(); i++) {
+            char ch = input.charAt(i);
+            if (Character.isUpperCase(ch) && i > 0) {
+                sb.append('-');
+            }
+            sb.append(Character.toLowerCase(ch));
+        }
+        return sb.toString();
+    }
+
+    public static @NotNull String toCamel(@NotNull String input) {
+        String[] words = input.split("-");
+        StringBuilder camelCaseString = new StringBuilder();
+
+        for (String word : words) {
+            if (!word.isEmpty()) {
+                camelCaseString.append(Character.toUpperCase(word.charAt(0)))
+                        .append(word.substring(1).toLowerCase());
+            }
+        }
+
+        return camelCaseString.toString();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/DividedPlayerList.java b/src/main/java/org/leavesmc/lumina/utils/DividedPlayerList.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c320400105d4433d83e1d06fc9d19dcf42284f8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/DividedPlayerList.java
@@ -0,0 +1,84 @@
+package org.leavesmc.lumina.utils;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import static org.leavesmc.lumina.utils.PlayerType.*;
+
+public class DividedPlayerList extends CopyOnWriteArrayList<ServerPlayer> {
+    public final Map<PlayerType, CopyOnWriteArrayList<ServerPlayer>> divided = new HashMap<>() {{
+        put(REAL, new CopyOnWriteArrayList<>());
+        put(FAKE, new CopyOnWriteArrayList<>());
+        put(GHOST, new CopyOnWriteArrayList<>());
+    }};
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> c) {
+        c.forEach(o -> divided.get(getType((ServerPlayer) o)).remove(o));
+        return super.removeAll(c);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        divided.get(getType((ServerPlayer) o)).remove(o);
+        return super.remove(o);
+    }
+
+    @Override
+    public ServerPlayer remove(int index) {
+        ServerPlayer player = super.remove(index);
+        divided.get(getType(player)).remove(player);
+        return player;
+    }
+
+    @Override
+    public int addAllAbsent(@NotNull Collection<? extends ServerPlayer> c) {
+        c.forEach(serverPlayer -> divided.get(getType(serverPlayer)).add(serverPlayer));
+        return super.addAllAbsent(c);
+    }
+
+    @Override
+    public boolean addIfAbsent(ServerPlayer serverPlayer) {
+        divided.get(getType(serverPlayer)).add(serverPlayer);
+        return super.addIfAbsent(serverPlayer);
+    }
+
+    @Override
+    public void add(int index, ServerPlayer serverPlayer) {
+        divided.get(getType(serverPlayer)).add(serverPlayer);
+        super.add(index, serverPlayer);
+    }
+
+    @Override
+    public boolean add(ServerPlayer serverPlayer) {
+        divided.get(getType(serverPlayer)).add(serverPlayer);
+        return super.add(serverPlayer);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends ServerPlayer> c) {
+        c.forEach(serverPlayer -> divided.get(getType(serverPlayer)).add(serverPlayer));
+        return super.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, @NotNull Collection<? extends ServerPlayer> c) {
+        c.forEach(serverPlayer -> divided.get(getType(serverPlayer)).add(serverPlayer));
+        return super.addAll(index, c);
+    }
+
+    public PlayerType getType(ServerPlayer player) {
+        // TODO Ghost player check
+        if (player instanceof EntityPlayerMPFake) {
+            return FAKE;
+        } else {
+            return REAL;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/LocationUtils.java b/src/main/java/org/leavesmc/lumina/utils/LocationUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9d0f247f3834626767688c9298ad0b03557000e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/LocationUtils.java
@@ -0,0 +1,62 @@
+package org.leavesmc.lumina.utils;
+
+import dev.jorel.commandapi.CommandAPIBukkit;
+import dev.jorel.commandapi.exceptions.WrapperCommandSyntaxException;
+import dev.jorel.commandapi.executors.CommandArguments;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+public class LocationUtils {
+    @Contract("_ -> new")
+    public static @NotNull BlockPos toBlockPos(@NotNull Location location) {
+        return new BlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+    }
+
+    public static @NotNull Location toLocation(@NotNull BlockPos blockPos, World world) {
+        return new Location(world, blockPos.getX(), blockPos.getY(), blockPos.getZ());
+    }
+
+    public static ServerLevel getLevel(@NotNull Location location) {
+        return getLevel(location.getWorld());
+    }
+
+    public static ServerLevel getLevel(@NotNull World world) {
+        return ((CraftWorld) world).getHandle();
+    }
+
+    public static ServerLevel getLevel(@NotNull Entity entity) {
+        return getLevel(entity.getWorld());
+    }
+
+    public static @NotNull Location getLocationWithDefaultWorld(@NotNull CommandSender sender, @NotNull CommandArguments args, String key) throws WrapperCommandSyntaxException {
+        Location location = (Location) args.get(key);
+        if (location == null) {
+            throw CommandAPIBukkit.failWithAdventureComponent(text("Must specify " + key + " location.").color(RED));
+        }
+        World world = getSenderWorldOrDefault(sender);
+        if (location.getWorld() == null) {
+            location.setWorld(world);
+        }
+        return location;
+    }
+
+    public static World getSenderWorldOrDefault(@NotNull CommandSender sender) {
+        World world = Bukkit.getWorlds().getFirst();
+        if (sender instanceof Entity entity) {
+            world = entity.getWorld();
+        }
+        return world;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/PermissionUtils.java b/src/main/java/org/leavesmc/lumina/utils/PermissionUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..6399ccb0a549b24e8bb66254bb7e1fd18e76cf95
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/PermissionUtils.java
@@ -0,0 +1,25 @@
+package org.leavesmc.lumina.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permission;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+public class PermissionUtils {
+    private static void addPermission(Permission permission) {
+        Bukkit.getPluginManager().addPermission(permission);
+    }
+
+    public static void addPermissionAndBind(String name, String description, @NotNull List<String> enabledChildren) {
+        addPermission(new Permission(
+                name,
+                description,
+                Permission.DEFAULT_PERMISSION,
+                enabledChildren.stream().collect(Collectors.toMap(
+                        child -> child.replaceFirst("&", name),
+                        child -> true)
+                )));
+    }
+}
