From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7studio@foxmail.com>
Date: Thu, 11 Apr 2024 22:58:15 +0800
Subject: [PATCH] Lumina server config and command


diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index a96e3bfc7f937debf285755652dc17acef3ea977..4a1a542cadde702253a9fccefc31fc7457df266c 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -222,6 +222,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.paperConfigurations.initializeGlobalConfiguration(this.registryAccess());
         this.paperConfigurations.initializeWorldDefaultsConfiguration(this.registryAccess());
         // Paper end - initialize global and world-defaults configuration
+        org.leavesmc.lumina.config.LuminaConfig.setup(); //Lumina - load config file
         // Paper start - fix converting txt to json file; convert old users earlier after PlayerList creation but before file load/save
         if (this.convertOldUsers()) {
             this.getProfileCache().save(false); // Paper
@@ -290,6 +291,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         );
         dev.jorel.commandapi.CommandAPI.onEnable();
         // Lumina end - enable CommandAPI
+        org.leavesmc.lumina.LuminaCommand.INSTANCE.registerCommands(); // Lumina - register commands
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // Spigot - moved up
         this.server.loadPlugins();
diff --git a/src/main/java/org/leavesmc/lumina/LuminaCommand.java b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa829f4b6233f656584c7971db34ef20cbd58814
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
@@ -0,0 +1,225 @@
+package org.leavesmc.lumina;
+
+import com.mojang.logging.LogUtils;
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import dev.jorel.commandapi.executors.CommandArguments;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.leavesmc.lumina.config.Validator;
+import org.slf4j.Logger;
+
+import java.util.Arrays;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+
+public class LuminaCommand {
+    private LuminaCommand() {
+    }
+
+    public static LuminaCommand INSTANCE = new LuminaCommand();
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public void registerCommands() {
+        registerLuminaCommand();
+    }
+
+    private void registerLuminaCommand() {
+        String[] configNodes = LuminaConfig.nodeInfos.keySet().toArray(new String[0]);
+        new CommandAPICommand("lumina")
+                .withSubcommand(new CommandAPICommand("config")
+                        .withSubcommand(generateSetSubCommand(false, configNodes))
+                        .withSubcommand(new CommandAPICommand("get")
+                                .withPermission("lumina.config.get")
+                                .withArguments(new StringArgument("node")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                                ).executes((sender, args) -> {
+                                    String node = (String) args.get("node");
+                                    ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                    if (node == null || nodeInfo == null) {
+                                        sender.sendMessage(text("No config node specified.").color(RED));
+                                        return;
+                                    }
+                                    try {
+                                        sender.sendMessage(text("The value of " + node + " is " + nodeInfo.field().get(nodeInfo.parent())));
+                                    } catch (IllegalAccessException e) {
+                                        throw new RuntimeException("Please report this to Lumina developers: " + e);
+                                    }
+                                })
+                        ).withSubcommand(new CommandAPICommand("reload")
+                                .withPermission("lumina.config.reload")
+                                .executes((sender, args) -> {
+                                    sender.sendMessage(text("Reloading Lumina config...").color(DARK_GREEN));
+                                    if (!(sender instanceof ConsoleCommandSender)) {
+                                        LOGGER.info("Reloading Lumina config...");
+                                    }
+                                    LuminaConfig.reloadAsync().thenApply((Void ignored) -> {
+                                        sender.sendMessage(text("Lumina config reloaded.").color(DARK_GREEN));
+                                        if (!(sender instanceof ConsoleCommandSender)) {
+                                            LOGGER.info("Lumina config reloaded.");
+                                        }
+                                        return null;
+                                    });
+                                })
+                        ).withSubcommand(new CommandAPICommand("save")
+                                .withPermission("lumina.config.set") // Cause `set` also called save, so use the same permission node
+                                .executes((sender, args) -> {
+                                    sender.sendMessage(text("Saving Lumina config...").color(DARK_GREEN));
+                                    if (!(sender instanceof ConsoleCommandSender)) {
+                                        LOGGER.info("Saving Lumina config...");
+                                    }
+                                    LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                                        sender.sendMessage(text("Lumina config saved.").color(DARK_GREEN));
+                                        if (!(sender instanceof ConsoleCommandSender)) {
+                                            LOGGER.info("Lumina config saved.");
+                                        }
+                                        return null;
+                                    });
+                                })
+                        ).withSubcommand(new CommandAPICommand("temp")
+                                .withSubcommand(generateSetSubCommand(true, configNodes))
+                                .withSubcommand(new CommandAPICommand("clear")
+                                        .withPermission("lumina.config.set")
+                                )
+                        )
+                ).register();
+    }
+
+    private CommandAPICommand generateSetSubCommand(boolean temp, String[] configNodes) {
+        return new CommandAPICommand("set")
+                .withPermission("lumina.config.set")
+                .withArguments(new StringArgument("node")
+                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                ).withArguments(new GreedyStringArgument("value")
+                        .replaceSuggestions(ArgumentSuggestions.strings(info -> {
+                            String node = (String) info.previousArgs().get("node");
+                            ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                            if (node == null || node.isEmpty() || nodeInfo == null) {
+                                return new String[]{};
+                            }
+                            return nodeInfo.suggestions();
+                        }))
+                ).executes((sender, args) -> {
+                    String node = (String) args.get("node");
+                    ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                    setValueInternal(node, nodeInfo, sender, args, temp);
+                });
+    }
+
+    private void setValueInternal(String node, ConfigNodeInfo nodeInfo, CommandSender sender, CommandArguments args, boolean temp) {
+        if (node == null || nodeInfo == null) {
+            sender.sendMessage(text("No config node specified.").color(RED));
+            return;
+        }
+        String value = (String) args.get("value");
+        Class<?> type = nodeInfo.type();
+        Object fileParent = nodeInfo.fileParent();
+        Object tempParent = nodeInfo.tempParent();
+        if (value == null || value.isEmpty()) {
+            sender.sendMessage(text("No value specified, expected: " + type.getSimpleName()).color(RED));
+            return;
+        }
+        try {
+            if (type.isEnum()) {
+                @SuppressWarnings({"unchecked", "rawtypes"})
+                Class<? extends Enum> enumType = (Class<? extends Enum>) type;
+                try {
+                    @SuppressWarnings("unchecked")
+                    Object enumValue = Enum.valueOf(enumType, value);
+                    nodeInfo.field().set(tempParent, enumValue);
+                    if (!temp) nodeInfo.field().set(fileParent, enumValue);
+                } catch (IllegalArgumentException ignored) {
+                    sender.sendMessage(text("Expected enum " + Arrays.toString(nodeInfo.suggestions()) + ", but entered: " + value).color(RED));
+                }
+            } else {
+                switch (type.getSimpleName()) {
+                    case "boolean" -> {
+                        boolean newValue;
+                        if ("true".equals(value)) {
+                            newValue = true;
+                        } else if ("false".equals(value)) {
+                            newValue = false;
+                        } else {
+                            sender.sendMessage(text("Expected boolean, but entered: " + value).color(RED));
+                            return;
+                        }
+                        Validator.ValidationResult result = Validator.validateBoolean(nodeInfo, newValue);
+                        if (result.type() != Validator.ValidationResultType.PASS) {
+                            sender.sendMessage(text(result.message()).color(RED));
+                            return;
+                        }
+                        nodeInfo.field().setBoolean(tempParent, newValue);
+                        if (!temp) nodeInfo.field().setBoolean(fileParent, newValue);
+                    }
+                    case "int" -> {
+                        try {
+                            int newValue = Integer.parseInt(value);
+                            Validator.ValidationResult result = Validator.validateInteger(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setInt(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setInt(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected int, but entered: " + value).color(RED));
+                        }
+                    }
+                    case "long" -> {
+                        try {
+                            long newValue = Long.parseLong(value);
+                            Validator.ValidationResult result = Validator.validateLong(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setLong(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setLong(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected long, but entered: " + value).color(RED));
+                        }
+                    }
+                    case "double" -> {
+                        try {
+                            double newValue = Double.parseDouble(value);
+                            Validator.ValidationResult result = Validator.validateDouble(nodeInfo, newValue);
+                            if (result.type() != Validator.ValidationResultType.PASS) {
+                                sender.sendMessage(text(result.message()).color(RED));
+                                return;
+                            }
+                            nodeInfo.field().setDouble(tempParent, newValue);
+                            if (!temp) nodeInfo.field().setDouble(fileParent, newValue);
+                        } catch (NumberFormatException ignored) {
+                            sender.sendMessage(text("Expected double, but entered: " + value).color(RED));
+                        }
+                    }
+                    case "String" -> {
+                        Validator.ValidationResult result = Validator.validateString(nodeInfo, value);
+                        if (result.type() != Validator.ValidationResultType.PASS) {
+                            sender.sendMessage(text(result.message()).color(RED));
+                            return;
+                        }
+                        nodeInfo.field().set(tempParent, value);
+                        if (!temp) nodeInfo.field().set(fileParent, value);
+                    }
+                    default ->
+                            throw new IllegalStateException("Please report this to Lumina developers: unexpected config field type " + type.getName());
+                }
+            }
+            LuminaConfig.mergeConfig();
+            sender.sendMessage(text("Set " + node + " to " + value + (temp ? " temporary" : "")).color(DARK_GREEN));
+            if (!temp && LuminaConfig.configModule.misc.saveConfigAfterSet) {
+                LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                    LOGGER.info("Saved Lumina config after setting {} to {}", node, value);
+                    return null;
+                });
+            }
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Please report this to Lumina developers: " + e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..82aaa736e5e502b18d6cc758a9be4369493db295
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config;
+
+import java.lang.reflect.Field;
+
+public record ConfigNodeInfo(
+        String[] suggestions,
+        Class<?> type,
+        Field field,
+        Object parent, Object fileParent, Object tempParent,
+        Validator<?> validator) {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd8a160950415d50d3865794c34cfe27eb1c5450
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
@@ -0,0 +1,112 @@
+package org.leavesmc.lumina.config;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfigModule;
+import org.leavesmc.lumina.utils.ConfigUtils;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+import org.spongepowered.configurate.loader.ConfigurationLoader;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+
+public class LuminaConfig {
+    public static LuminaConfigModule configModule, fileModule, tempModule;
+    private static ConfigurationLoader<CommentedConfigurationNode> loader;
+    private static CommentedConfigurationNode node;
+    public static Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+
+    public static void setup() {
+        Path hoconConfigPath = Path.of("lumina.conf");
+        boolean useHocon = Boolean.getBoolean("lumina.config.style.hocon") || Files.exists(hoconConfigPath);
+        boolean jsonStyle = Boolean.getBoolean("lumina.config.style.json");
+        if (useHocon || jsonStyle) {
+            loader = HoconConfigurationLoader.builder()
+                    .emitComments(true)
+                    .emitJsonCompatible(jsonStyle)
+                    .prettyPrinting(true)
+                    .path(hoconConfigPath)
+                    .build();
+        } else {
+            loader = YamlConfigurationLoader.builder()
+                    .nodeStyle(NodeStyle.BLOCK)
+                    .indent(2)
+                    .path(Path.of("lumina.yml"))
+                    .build();
+        }
+
+        loadConfig();
+        saveConfig();
+    }
+
+    private static void generateNodeInfos() {
+        try {
+            ConfigUtils.generateNodeInfos(nodeInfos, LuminaConfigModule.class, null, configModule, fileModule, tempModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void mergeConfig() {
+        try {
+            node.set(fileModule);
+            if (tempModule == null) {
+                tempModule = loader.createNode().get(LuminaConfigModule.class);
+            }
+            node.from(loader.createNode().set(LuminaConfigModule.class, tempModule));
+            configModule = node.get(LuminaConfigModule.class);
+            generateNodeInfos();
+        } catch (SerializationException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void reload() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        loadConfig();
+    }
+
+    private static void loadConfig() {
+        try {
+            node = loader.load();
+            configModule = node.get(LuminaConfigModule.class);
+            fileModule = node.get(LuminaConfigModule.class);
+            tempModule = loader.createNode().get(LuminaConfigModule.class);
+            generateNodeInfos();
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void save() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        saveConfig();
+    }
+
+    private static void saveConfig() {
+        try {
+            node.set(LuminaConfigModule.class, fileModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> reloadAsync() {
+        return ConfigUtils.runAsync(LuminaConfig::reload);
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> saveAsync() {
+        return ConfigUtils.runAsync(LuminaConfig::save);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c2bf30ef6035575e56c8743f1abee8ac8b8d558
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config;
+
+import org.leavesmc.lumina.config.modules.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LuminaConfigModule {
+    public String configVersion = "1";
+    public Fix fix = new Fix();
+    public Protocol protocol = new Protocol();
+    public Performance performance = new Performance();
+    public Modify modify = new Modify();
+    public Misc misc = new Misc();
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/Validator.java b/src/main/java/org/leavesmc/lumina/config/Validator.java
new file mode 100644
index 0000000000000000000000000000000000000000..18cc13bccf468ae730402449be0bd5303a39ee39
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/Validator.java
@@ -0,0 +1,121 @@
+package org.leavesmc.lumina.config;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+public class Validator<T> {
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public boolean validate(T newValue, T oldValue) {
+        return true;
+    }
+
+    public String getErrorMessage(T newValue) {
+        return "Invalid value: " + newValue;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateString(@NotNull ConfigNodeInfo nodeInfo, String newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<String> validator = (Validator<String>) nodeInfo.validator();
+                if (!validator.validate(newValue, (String) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateBoolean(@NotNull ConfigNodeInfo nodeInfo, Boolean newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Boolean> validator = (Validator<Boolean>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Boolean) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateInteger(@NotNull ConfigNodeInfo nodeInfo, Integer newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Integer> validator = (Validator<Integer>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Integer) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateLong(@NotNull ConfigNodeInfo nodeInfo, Long newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Long> validator = (Validator<Long>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Long) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateDouble(@NotNull ConfigNodeInfo nodeInfo, Double newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Double> validator = (Validator<Double>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Double) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <E> ValidationResult validate(@NotNull ConfigNodeInfo nodeInfo, E newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<E> validator = (Validator<E>) nodeInfo.validator();
+                if (!validator.validate(newValue, (E) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    public enum ValidationResultType {
+        PASS, FAILED
+    }
+
+    public record ValidationResult(ValidationResultType type, String message) {
+        @Contract(" -> new")
+        public static @NotNull ValidationResult pass() {
+            return new ValidationResult(ValidationResultType.PASS, null);
+        }
+
+        @Contract("_ -> new")
+        public static @NotNull ValidationResult failed(String message) {
+            return new ValidationResult(ValidationResultType.FAILED, message);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7a2e319e7dbc733b9ec9f9b67ec4ddf182dc6df
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
@@ -0,0 +1,15 @@
+package org.leavesmc.lumina.config.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * 在用户使用命令修改Config时提供常量字符串列表建议
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Suggestion {
+    String[] value() default {};
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fff13fd26a134118dac8949ee061c92055fdbde
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.annotations;
+
+import org.leavesmc.lumina.config.Validator;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Validate {
+    Class<? extends Validator> value() default Validator.class;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Fix.java b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
new file mode 100644
index 0000000000000000000000000000000000000000..4df98b3dd4a42068c43a98c399b8ebbfe3157119
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.fix.FixFoliaEntityMovingFixConfig;
+import org.leavesmc.lumina.config.modules.fix.FixFoliaTeleportAsyncConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Fix {
+    public FixFoliaEntityMovingFixConfig fixFoliaEntityMoving = new FixFoliaEntityMovingFixConfig();
+    public FixFoliaTeleportAsyncConfig fixFoliaTeleportAsync = new FixFoliaTeleportAsyncConfig();
+    public boolean fixFoliaSpectorTeleport = true;
+    public boolean allowUnsafeTeleportation = true;
+    public boolean fixVoidTrading = true;
+    public boolean useVanillaRandomSourceForPlayers = true;
+    public boolean fixFoliaPoiAccessOffRegion = true;
+    public boolean mc2025 = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Misc.java b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6f41a391d597655d799249a17445dda22c83f03
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
@@ -0,0 +1,20 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.misc.RegionFormatConfig;
+import org.leavesmc.lumina.config.modules.misc.WatchdogConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Misc {
+    public boolean mojangChatSign = true;
+    public boolean allowInorderChat = true;
+    public boolean offlineModeWarning = true;
+    public String serverModName = "Lumina";
+    public boolean fakeVanilla = false;
+    public boolean checkUsername = true;
+    public boolean alternativeKeepAlive = true;
+    public boolean saveConfigAfterSet = true;
+    public boolean verifyPublicKeyOnlyInOnlineMode = false;
+    public WatchdogConfig watchdog = new WatchdogConfig();
+    public RegionFormatConfig regionFormat = new RegionFormatConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Modify.java b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
new file mode 100644
index 0000000000000000000000000000000000000000..b22fa9a59a6a26788a26ba217ac6e8847c71d9f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
@@ -0,0 +1,7 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Modify {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
new file mode 100644
index 0000000000000000000000000000000000000000..4739bdb828be18d9bec7ae2d6c6b332de879acee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.performance.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Performance {
+    public PetalReduceSensorWorkConfig petalReduceSensorWork = new PetalReduceSensorWorkConfig();
+    public ProjectileChunkReduceConfig projectileChunkReduce = new ProjectileChunkReduceConfig();
+    public DynamicEntityActivationRangeConfig dynamicEntityActivationRange = new DynamicEntityActivationRangeConfig();
+    public boolean entityGoalSelectorInactiveTick = false;
+    public boolean allowLoadChunksToActiveClimbingEntities = false;
+    public boolean optimizeSuffocation = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d91f7ea07e768c6e2c60386e143242fc20e9152
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.protocol.LeavesBladerenProtocolConfig;
+import org.leavesmc.lumina.config.modules.protocol.PcaSyncProtocolConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Protocol {
+    public boolean carpetProtocol = false;
+    public boolean jadeProtocol = false;
+    public boolean bborProtocol = false;
+    public PcaSyncProtocolConfig pcaSyncProtocol = new PcaSyncProtocolConfig();
+    public LeavesBladerenProtocolConfig leavesBladerenProtocol = new LeavesBladerenProtocolConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abda15610a48676d145ef26bae7a7340b88b0ee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaEntityMovingFixConfig {
+    public boolean enabled = false;
+    public boolean warnOnDetected = true;
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..b043bf36de0604028cb7bdd166d000d2dec76360
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaTeleportAsyncConfig {
+    public boolean enabled = false;
+    public boolean throwOnDetected = true;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..35aed045ceb1f7647de4b0efbf7c609f62c402d8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.stupidcraft.linearpaper.region.EnumRegionFileExtension;
+
+@ConfigSerializable
+public class RegionFormatConfig {
+    public EnumRegionFileExtension format = EnumRegionFileExtension.MCA;
+    public int linearCompressionLevel = 1;
+    public int linearFlushFrequency = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e79b3e1dfa56896c20e3b7e9c9d0cc37257af05
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class WatchdogConfig {
+    public boolean enabled = false;
+    public long warnPeriodTicks = 5 * 20;
+    public long timeOutTicks = 30 * 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..92334d8b7617616f3991fd58949e3714d159eeed
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+
+@ConfigSerializable
+public class DynamicEntityActivationRangeConfig {
+    public boolean enabled = false;
+    public int startDistanceSquared = 144;
+    public int maximumActivationPriority = 20;
+    public int activationDistanceMod = 8;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..db160578fa0d35a275f953e88f04340c20d08942
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
@@ -0,0 +1,8 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LoadChunksToActiveClimbingEntitiesConfig {
+    public boolean allow = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..eed3fe3a9a7d5aa6eeeb3c2c3a40d73eafdd3f3f
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PetalReduceSensorWorkConfig {
+    public boolean enabled = true;
+    public int delayTicks = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb64dd4c224c9246fa8d999c8217096f7bebe89b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class ProjectileChunkReduceConfig {
+    public int maxProjectileLoadsPerTick;
+    public int maxProjectileLoadsPerProjectile;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..75352347781b590ddef6680bd8816bdc06631640
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LeavesBladerenProtocolConfig {
+    public boolean enableBaseProtocol = false;
+    public boolean msptSyncProtocol = false;
+    public int msptSyncTickInterval = 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..119b50c12f08c548e7a56dd983805324526fc35e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PcaSyncProtocolConfig {
+    public boolean enabled = false;
+    public SyncOption sync = SyncOption.OPS;
+
+    public enum SyncOption {
+        NOBODY,
+        BOT,
+        OPS,
+        OPS_AND_SELF,
+        EVERYONE
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java b/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..43f8e44ce868f98cb6c7efa1484878691b09140b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ConfigUtils.java
@@ -0,0 +1,107 @@
+package org.leavesmc.lumina.utils;
+
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.InternalJavaPluginFactory;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfigModule;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+import org.spongepowered.configurate.loader.AbstractConfigurationLoader;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+
+public class ConfigUtils {
+    static final Set<Class<?>> CONFIG_FIELD_TYPES = new HashSet<>(Arrays.asList(
+            String.class,
+            boolean.class,
+            int.class,
+            long.class,
+            double.class));
+    static final Plugin INTERNAL_PLUGIN = InternalJavaPluginFactory.create("LuminaConfigSystem");
+
+    @Contract("_ -> new")
+    public static @NotNull CompletableFuture<Void> runAsync(Runnable runnable) {
+        return CompletableFuture.runAsync(runnable, task -> Bukkit.getGlobalRegionScheduler().run(ConfigUtils.INTERNAL_PLUGIN, scheduled -> task.run()));
+    }
+
+    public static void generateNodeInfos(Map<String, ConfigNodeInfo> nodeInfoMap, @NotNull Class<?> clazz, String parentKey, @NotNull Object parent, @NotNull Object fileParent, @NotNull Object tempParent) throws IllegalAccessException {
+        for (Field field : clazz.getFields()) {
+            String fieldName = field.getName();
+            Class<?> fieldType = field.getType();
+            String key = parentKey == null ? toHyphen(fieldName) : parentKey + "." + toHyphen(fieldName);
+            boolean haveSuggestions = false;
+            String[] suggestions = null;
+            Validator<?> validator = new Validator<>();
+            for (Annotation annotation : field.getAnnotations()) {
+                if (annotation instanceof Suggestion value) {
+                    haveSuggestions = true;
+                    suggestions = value.value();
+                } else if (annotation instanceof Validate value) {
+                    try {
+                        validator = value.value().getDeclaredConstructor().newInstance();
+                    } catch (InstantiationException | InvocationTargetException | NoSuchMethodException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+            if (!haveSuggestions) {
+                if ("boolean".equals(fieldType.getSimpleName())) {
+                    suggestions = new String[]{"true", "false"};
+                    haveSuggestions = true;
+                } else if (ConfigUtils.CONFIG_FIELD_TYPES.contains(fieldType)) {
+                    suggestions = new String[]{field.get(parent).toString()};
+                    haveSuggestions = true;
+                } else if (fieldType.isEnum()) {
+                    suggestions = Arrays.stream(fieldType.getEnumConstants()).map(Object::toString).toArray(String[]::new);
+                    haveSuggestions = true;
+                }
+            }
+            if (haveSuggestions) {
+                nodeInfoMap.put(key, new ConfigNodeInfo(suggestions, fieldType, field, parent, fileParent, tempParent, validator));
+            } else {
+                generateNodeInfos(nodeInfoMap, fieldType, key, field.get(parent), field.get(fileParent), field.get(tempParent));
+            }
+        }
+    }
+
+    private static @NotNull String toHyphen(String input) {
+        if (input == null || input.isEmpty()) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < input.length(); i++) {
+            char ch = input.charAt(i);
+            if (Character.isUpperCase(ch) && i > 0) {
+                sb.append('-');
+            }
+            sb.append(Character.toLowerCase(ch));
+        }
+        return sb.toString();
+    }
+
+    public static @NotNull String toCamel(@NotNull String input) {
+        String[] words = input.split("-");
+        StringBuilder camelCaseString = new StringBuilder();
+
+        for (String word : words) {
+            if (!word.isEmpty()) {
+                camelCaseString.append(Character.toUpperCase(word.charAt(0)))
+                        .append(word.substring(1).toLowerCase());
+            }
+        }
+
+        return camelCaseString.toString();
+    }
+}
