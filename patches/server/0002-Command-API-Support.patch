From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7@outlook.com>
Date: Sat, 20 Jul 2024 06:06:46 +0000
Subject: [PATCH] Command API Support


diff --git a/src/main/java/dev/jorel/commandapi/CommandAPIVersionHandler.java b/src/main/java/dev/jorel/commandapi/CommandAPIVersionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c978c7f7a5291b27b62457519d0373ae1230238
--- /dev/null
+++ b/src/main/java/dev/jorel/commandapi/CommandAPIVersionHandler.java
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ * Copyright 2018, 2021 Jorel Ali (Skepter) - MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *******************************************************************************/
+// Copy from https://github.com/JorelAli/CommandAPI
+package dev.jorel.commandapi;
+
+import dev.jorel.commandapi.nms.*;
+
+import java.util.logging.Logger;
+
+/**
+ * This file handles the NMS version to be loaded. The CommandAPIVersionHandler
+ * file within the commandapi-core module is NOT used at compile time. Instead,
+ * the commandapi-vh module is loaded instead, which doesn't use reflection to
+ * load NMS instances.
+ *
+ * NMS classes implement {@code NMS<CommandListenerWrapper>}. The type
+ * CommandListenerWrapper isn't visible as in this Maven module (it's not
+ * included and in some cases, cannot be included because Maven will only select
+ * one version of a specific project (in this case, it'll only import one copy
+ * of Spigot, almost always the latest stable version (from 1.16.5)). In
+ * Eclipse, this can produce an error saying that a class cannot be resolved
+ * because it is indirectly referenced from required .class files So sidestep
+ * this, we introduce a second intermediary class NMSWrapper_VERSION which
+ * depends on CommandListenerWrapper and then our main NMS_VERSION class extends
+ * that.
+ */
+public interface CommandAPIVersionHandler {
+
+    /**
+     * Returns an instance of the current running version's implementation of the Bukkit NMS.
+     *
+     * @return an instance of NMS which can run on the specified Minecraft version
+     */
+    static CommandAPIPlatform<?, ?, ?> getPlatform() {
+        Logger.getLogger("CommandAPIVersionHandler").info("Command API is using NMS version 1_20_R4");
+        return new NMS_1_20_R4();
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java b/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3228efcb0d85c0c43cd4e52fe0b877414a5ebe5
--- /dev/null
+++ b/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
@@ -0,0 +1,1081 @@
+/*******************************************************************************
+ * Copyright 2024 Jorel Ali (Skepter) - MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *******************************************************************************/
+// Modified from https://github.com/JorelAli/CommandAPI
+package dev.jorel.commandapi.nms;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Predicate;
+import java.util.function.ToIntFunction;
+
+import dev.jorel.commandapi.*;
+import io.papermc.paper.command.brigadier.bukkit.BukkitCommandNode;
+import net.minecraft.commands.*;
+import org.bukkit.Bukkit;
+import org.bukkit.Color;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Particle;
+import org.bukkit.Particle.DustOptions;
+import org.bukkit.Particle.DustTransition;
+import org.bukkit.Registry;
+import org.bukkit.Vibration;
+import org.bukkit.Vibration.Destination;
+import org.bukkit.Vibration.Destination.BlockDestination;
+import org.bukkit.World;
+import org.bukkit.advancement.Advancement;
+import org.bukkit.block.Biome;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.craftbukkit.CraftLootTable;
+import org.bukkit.craftbukkit.CraftParticle;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftSound;
+import org.bukkit.craftbukkit.block.data.CraftBlockData;
+import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.help.CustomHelpTopic;
+import org.bukkit.craftbukkit.help.SimpleHelpMap;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.potion.CraftPotionEffectType;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+import org.bukkit.help.HelpTopic;
+import org.bukkit.inventory.Recipe;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.io.Files;
+import com.google.gson.GsonBuilder;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.Message;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+
+import dev.jorel.commandapi.arguments.ArgumentSubType;
+import dev.jorel.commandapi.arguments.SuggestionProviders;
+import dev.jorel.commandapi.commandsenders.AbstractCommandSender;
+import dev.jorel.commandapi.commandsenders.BukkitCommandSender;
+import dev.jorel.commandapi.commandsenders.BukkitNativeProxyCommandSender;
+import dev.jorel.commandapi.preprocessor.Differs;
+import dev.jorel.commandapi.wrappers.ComplexRecipeImpl;
+import dev.jorel.commandapi.wrappers.FloatRange;
+import dev.jorel.commandapi.wrappers.FunctionWrapper;
+import dev.jorel.commandapi.wrappers.IntegerRange;
+import dev.jorel.commandapi.wrappers.Location2D;
+import dev.jorel.commandapi.wrappers.NativeProxyCommandSender;
+import dev.jorel.commandapi.wrappers.ParticleData;
+import dev.jorel.commandapi.wrappers.ScoreboardSlot;
+import dev.jorel.commandapi.wrappers.SimpleFunctionWrapper;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+import net.minecraft.advancements.AdvancementHolder;
+import net.minecraft.advancements.critereon.MinMaxBounds;
+import net.minecraft.commands.arguments.ColorArgument;
+import net.minecraft.commands.arguments.ComponentArgument;
+import net.minecraft.commands.arguments.DimensionArgument;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.MessageArgument;
+import net.minecraft.commands.arguments.ParticleArgument;
+import net.minecraft.commands.arguments.RangeArgument;
+import net.minecraft.commands.arguments.ResourceArgument;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
+import net.minecraft.commands.arguments.ScoreHolderArgument;
+import net.minecraft.commands.arguments.ScoreboardSlotArgument;
+import net.minecraft.commands.arguments.blocks.BlockPredicateArgument;
+import net.minecraft.commands.arguments.blocks.BlockStateArgument;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.commands.arguments.coordinates.ColumnPosArgument;
+import net.minecraft.commands.arguments.coordinates.Vec2Argument;
+import net.minecraft.commands.arguments.coordinates.Vec3Argument;
+import net.minecraft.commands.arguments.item.FunctionArgument;
+import net.minecraft.commands.arguments.item.ItemArgument;
+import net.minecraft.commands.arguments.item.ItemInput;
+import net.minecraft.commands.arguments.item.ItemPredicateArgument;
+import net.minecraft.commands.arguments.selector.EntitySelector;
+import net.minecraft.commands.execution.ExecutionContext;
+import net.minecraft.commands.functions.CommandFunction;
+import net.minecraft.commands.functions.InstantiatedFunction;
+import net.minecraft.commands.synchronization.ArgumentUtils;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.component.DataComponentMap;
+import net.minecraft.core.component.PatchedDataComponentMap;
+import net.minecraft.core.particles.BlockParticleOption;
+import net.minecraft.core.particles.ColorParticleOption;
+import net.minecraft.core.particles.DustColorTransitionOptions;
+import net.minecraft.core.particles.DustParticleOptions;
+import net.minecraft.core.particles.ItemParticleOption;
+import net.minecraft.core.particles.ParticleOptions;
+import net.minecraft.core.particles.SculkChargeParticleOptions;
+import net.minecraft.core.particles.ShriekParticleOption;
+import net.minecraft.core.particles.SimpleParticleType;
+import net.minecraft.core.particles.VibrationParticleOption;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.network.chat.Component.Serializer;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.MinecraftServer.ReloadableResources;
+import net.minecraft.server.ServerFunctionLibrary;
+import net.minecraft.server.ServerFunctionManager;
+import net.minecraft.server.level.ColumnPos;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.packs.PackResources;
+import net.minecraft.server.packs.PackType;
+import net.minecraft.server.packs.repository.Pack;
+import net.minecraft.server.packs.repository.PackRepository;
+import net.minecraft.server.packs.resources.MultiPackResourceManager;
+import net.minecraft.server.packs.resources.SimpleReloadInstance;
+import net.minecraft.sounds.SoundEvent;
+import net.minecraft.util.Unit;
+import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.crafting.RecipeHolder;
+import net.minecraft.world.level.DataPackConfig;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.WorldDataConfiguration;
+import net.minecraft.world.level.block.state.pattern.BlockInWorld;
+import net.minecraft.world.level.gameevent.BlockPositionSource;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.scores.ScoreHolder;
+import org.bukkit.loot.LootTable;
+import org.jetbrains.annotations.NotNull;
+
+// Mojang-Mapped reflection
+
+/**
+ * NMS implementation for Minecraft 1.20.5, 1.20.6
+ */
+public class NMS_1_20_R4 extends NMS_Common {
+
+    private static final SafeVarHandle<SimpleHelpMap, Map<String, HelpTopic>> helpMapTopics;
+    private static final Field entitySelectorUsesSelector;
+    // private static final SafeVarHandle<ItemInput, CompoundTag> itemInput;
+    private static final Field serverFunctionLibraryDispatcher;
+
+    // Derived from net.minecraft.commands.Commands;
+    @NotNull
+    private static final CommandBuildContext COMMAND_BUILD_CONTEXT;
+
+    // Compute all var handles all in one go so we don't do this during main server
+    // runtime
+    static {
+        if (Bukkit.getServer() instanceof CraftServer server) {
+            COMMAND_BUILD_CONTEXT = CommandBuildContext.simple(server.getServer().registryAccess(),
+                    server.getServer().getWorldData().getDataConfiguration().enabledFeatures());
+        } else {
+            throw new IllegalStateException("Bukkit server is not a CraftServer! This should never happen!");
+        }
+
+        helpMapTopics = SafeVarHandle.ofOrNull(SimpleHelpMap.class, "helpTopics", "helpTopics", Map.class);
+        // For some reason, MethodHandles fails for this field, but Field works okay
+        // entitySelectorUsesSelector = EntitySelector::usesSelector;
+        Field usesSelector = null;
+        for (Field field : EntitySelector.class.getFields()) {
+            if (field.getType().equals(boolean.class) && Modifier.isPublic(field.getModifiers())) {
+                usesSelector = CommandAPIHandler.getField(EntitySelector.class, field.getName(), "");
+            }
+        }
+        entitySelectorUsesSelector = usesSelector;
+        // itemInput = SafeVarHandle.ofOrNull(ItemInput.class, "c", "tag", CompoundTag.class);
+        // For some reason, MethodHandles fails for this field, but Field works okay
+        Field dispatcher = null;
+        for (Field field : ServerFunctionLibrary.class.getFields()) {
+            if (CommandDispatcher.class.isAssignableFrom(field.getType())) {
+                Type genericType = field.getGenericType();
+                if (genericType instanceof ParameterizedType) {
+                    Type[] actualTypeArguments = ((ParameterizedType) genericType).getActualTypeArguments();
+                    if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(CommandSourceStack.class)) {
+                        dispatcher = CommandAPIHandler.getField(ServerFunctionLibrary.class, field.getName(), "");
+                    }
+                }
+            }
+        }
+        serverFunctionLibraryDispatcher = dispatcher;
+    }
+
+    private static NamespacedKey fromResourceLocation(ResourceLocation key) {
+        return NamespacedKey.fromString(key.getNamespace() + ":" + key.getPath());
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentBlockPredicate() {
+        return BlockPredicateArgument.blockPredicate(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentBlockState() {
+        return BlockStateArgument.block(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Differs(from = "1.20.4", by = "Now needs a command build context")
+    @Override
+    public ArgumentType<?> _ArgumentChatComponent() {
+        return ComponentArgument.textComponent(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentEnchantment() {
+        return ResourceArgument.resource(COMMAND_BUILD_CONTEXT, Registries.ENCHANTMENT);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentEntity(ArgumentSubType subType) {
+        return switch (subType) {
+            case ENTITYSELECTOR_MANY_ENTITIES -> EntityArgument.entities();
+            case ENTITYSELECTOR_MANY_PLAYERS -> EntityArgument.players();
+            case ENTITYSELECTOR_ONE_ENTITY -> EntityArgument.entity();
+            case ENTITYSELECTOR_ONE_PLAYER -> EntityArgument.player();
+            default -> throw new IllegalArgumentException("Unexpected value: " + subType);
+        };
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentItemPredicate() {
+        return ItemPredicateArgument.itemPredicate(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentItemStack() {
+        return ItemArgument.item(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentParticle() {
+        return ParticleArgument.particle(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentSyntheticBiome() {
+        return ResourceArgument.resource(COMMAND_BUILD_CONTEXT, Registries.BIOME);
+    }
+
+    @Override
+    public final Map<String, HelpTopic> getHelpMap() {
+        return helpMapTopics.get((SimpleHelpMap) Bukkit.getHelpMap());
+    }
+
+    @Override
+    public String[] compatibleVersions() {
+        return new String[]{"1.20.5", "1.20.6"};
+    }
+
+    private static String serializeNMSItemStack(ItemStack is) {
+        final DataComponentMap patchedMap = PatchedDataComponentMap.fromPatch(PatchedDataComponentMap.EMPTY, is.getComponentsPatch());
+        return new ItemInput(is.getItemHolder(), patchedMap).serialize(COMMAND_BUILD_CONTEXT);
+    }
+
+    @Differs(from = "1.20.4", by = "Everything")
+    @Override
+    public final String convert(org.bukkit.inventory.ItemStack is) {
+        return serializeNMSItemStack(CraftItemStack.asNMSCopy(is));
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    @Differs(from = "1.20.4", by = "Everything")
+    @Override
+    public final String convert(ParticleData<?> particle) {
+        final ParticleOptions particleOptions = CraftParticle.createParticleParam(particle.particle(), particle.data());
+        final ResourceLocation particleKey = BuiltInRegistries.PARTICLE_TYPE.getKey(particleOptions.getType());
+
+        // /particle dust{scale:2,color:[1,2,2]}
+        // Use the particle option's codec to convert the data into NBT. If we have any tags, add them
+        // to the end, otherwise leave it as it is (e.g. `/particle crit` as opposed to `/particle crit{}`)
+        final Codec codec = particleOptions.getType().codec().codec();
+        final DataResult<CompoundTag> result = codec.encodeStart(NbtOps.INSTANCE, particleOptions);
+        final CompoundTag particleOptionsTag = result.result().get();
+        final String dataString = particleOptionsTag.getAllKeys().isEmpty() ? "" : particleOptionsTag.getAsString();
+        return particleKey.toString() + dataString;
+    }
+
+    /**
+     * An implementation of {@link ServerFunctionManager#execute(CommandFunction, CommandSourceStack)} with a specified
+     * command result callback instead of {@link CommandResultCallback.EMPTY}
+     *
+     * @param commandFunction the command function to run
+     * @param css             the command source stack to execute this command
+     * @return the result of our function. This is either 0 is the command failed, or greater than 0 if the command succeeded
+     */
+    @SuppressWarnings("JavadocReference")
+    private final int runCommandFunction(CommandFunction<CommandSourceStack> commandFunction, CommandSourceStack css) {
+        // Profile the function. We want to simulate the execution sequence exactly
+        ProfilerFiller profiler = this.<MinecraftServer>getMinecraftServer().getProfiler();
+        profiler.push(() -> "function " + commandFunction.id());
+
+        // Store our function result
+        AtomicInteger result = new AtomicInteger();
+        CommandResultCallback onCommandResult = (succeeded, resultValue) -> result.set(resultValue);
+
+        try {
+            final InstantiatedFunction<CommandSourceStack> instantiatedFunction = commandFunction.instantiate((CompoundTag) null, this.getBrigadierDispatcher());
+            Commands.executeCommandInContext(css, (executioncontext) -> {
+                ExecutionContext.queueInitialFunctionCall(executioncontext, instantiatedFunction, css, onCommandResult);
+            });
+        } catch (FunctionInstantiationException functionInstantiationException) {
+            // We don't care if the function failed to instantiate
+            assert true;
+        } catch (Exception exception) {
+            LogUtils.getLogger().warn("Failed to execute function {}", commandFunction.id(), exception);
+        } finally {
+            profiler.pop();
+        }
+
+        return result.get();
+    }
+
+    // Converts NMS function to SimpleFunctionWrapper
+    private final SimpleFunctionWrapper convertFunction(CommandFunction<CommandSourceStack> commandFunction) {
+        ToIntFunction<CommandSourceStack> appliedObj = (CommandSourceStack css) -> runCommandFunction(commandFunction, css);
+
+        // Unpack the commands by instantiating the function with no CSS, then retrieving its entries
+        String[] commands = new String[0];
+        try {
+            final InstantiatedFunction<CommandSourceStack> instantiatedFunction = commandFunction.instantiate((CompoundTag) null, this.getBrigadierDispatcher());
+
+            List<?> cArr = instantiatedFunction.entries();
+            commands = new String[cArr.size()];
+            for (int i = 0, size = cArr.size(); i < size; i++) {
+                commands[i] = cArr.get(i).toString();
+            }
+        } catch (FunctionInstantiationException functionInstantiationException) {
+            // We don't care if the function failed to instantiate
+            assert true;
+        }
+        return new SimpleFunctionWrapper(fromResourceLocation(commandFunction.id()), appliedObj, commands);
+    }
+
+    @Override
+    public final void createDispatcherFile(File file, CommandDispatcher<CommandSourceStack> dispatcher)
+            throws IOException {
+        Files.asCharSink(file, StandardCharsets.UTF_8).write(new GsonBuilder().setPrettyPrinting().create()
+                .toJson(ArgumentUtils.serializeNodeToJson(dispatcher, dispatcher.getRoot())));
+    }
+
+    @Override
+    public final HelpTopic generateHelpTopic(String commandName, String shortDescription, String fullDescription,
+                                             String permission) {
+        return new CustomHelpTopic(commandName, shortDescription, fullDescription, permission);
+    }
+
+    @Override
+    public Advancement getAdvancement(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        return ResourceLocationArgument.getAdvancement(cmdCtx, key).toBukkit();
+    }
+
+    @Differs(from = "1.20.4", by = "Serializer.toJson now needs a Provider")
+    @Override
+    public Component getAdventureChat(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        return GsonComponentSerializer.gson().deserialize(Serializer.toJson(MessageArgument.getMessage(cmdCtx, key), COMMAND_BUILD_CONTEXT));
+    }
+
+    @Override
+    public NamedTextColor getAdventureChatColor(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        final Integer color = ColorArgument.getColor(cmdCtx, key).getColor();
+        return color == null ? NamedTextColor.WHITE : NamedTextColor.namedColor(color);
+    }
+
+    @Override
+    public final Component getAdventureChatComponent(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        // TODO: Figure out if an empty provider is suitable for this context
+        return GsonComponentSerializer.gson()
+                .deserialize(Serializer.toJson(ComponentArgument.getComponent(cmdCtx, key), COMMAND_BUILD_CONTEXT));
+    }
+
+    @Override
+    public final Object getBiome(CommandContext<CommandSourceStack> cmdCtx, String key, ArgumentSubType subType)
+            throws CommandSyntaxException {
+        final ResourceLocation resourceLocation = ResourceArgument.getResource(cmdCtx, key, Registries.BIOME).key()
+                .location();
+        return switch (subType) {
+            case BIOME_BIOME -> {
+                Biome biome;
+                try {
+                    biome = Biome.valueOf(resourceLocation.getPath().toUpperCase());
+                } catch (IllegalArgumentException biomeNotFound) {
+                    biome = null;
+                }
+                yield biome;
+            }
+            case BIOME_NAMESPACEDKEY -> (NamespacedKey) fromResourceLocation(resourceLocation);
+            default -> null;
+        };
+    }
+
+    @Override
+    public final Predicate<Block> getBlockPredicate(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        Predicate<BlockInWorld> predicate = BlockPredicateArgument.getBlockPredicate(cmdCtx, key);
+        return (Block block) -> predicate.test(new BlockInWorld(cmdCtx.getSource().getLevel(),
+                new BlockPos(block.getX(), block.getY(), block.getZ()), true));
+    }
+
+    @Override
+    public final BlockData getBlockState(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return CraftBlockData.fromData(BlockStateArgument.getBlock(cmdCtx, key).getState());
+    }
+
+    @Override
+    public CommandSourceStack getBrigadierSourceFromCommandSender(
+            AbstractCommandSender<? extends CommandSender> sender) {
+        return VanillaCommandWrapper.getListener(sender.getSource());
+    }
+
+    @Differs(from = "1.20.4", by = "Serializer.toJson now needs a Provider")
+    @Override
+    public final BaseComponent[] getChat(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        return ComponentSerializer.parse(Serializer.toJson(MessageArgument.getMessage(cmdCtx, key), COMMAND_BUILD_CONTEXT));
+    }
+
+    @Override
+    public final World getDimension(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        return DimensionArgument.getDimension(cmdCtx, key).getWorld();
+    }
+
+    @Override
+    public final Enchantment getEnchantment(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        return Registry.ENCHANTMENT.get(fromResourceLocation(
+                BuiltInRegistries.ENCHANTMENT.getKey(ResourceArgument.getEnchantment(cmdCtx, key).value())));
+    }
+
+    @Override
+    public final Object getEntitySelector(CommandContext<CommandSourceStack> cmdCtx, String str,
+                                          ArgumentSubType subType, boolean allowEmpty) throws CommandSyntaxException {
+
+        // We override the rule whereby players need "minecraft.command.selector" and
+        // have to have level 2 permissions in order to use entity selectors. We're
+        // trying to allow entity selectors to be used by anyone that registers a
+        // command via the CommandAPI.
+        EntitySelector argument = cmdCtx.getArgument(str, EntitySelector.class);
+        try {
+            entitySelectorUsesSelector.set(argument, false);
+        } catch (IllegalAccessException e) {
+            // Shouldn't happen, CommandAPIHandler#getField makes it accessible
+        }
+
+        return switch (subType) {
+            case ENTITYSELECTOR_MANY_ENTITIES:
+                try {
+                    List<org.bukkit.entity.Entity> result = new ArrayList<>();
+                    for (Entity entity : argument.findEntities(cmdCtx.getSource())) {
+                        result.add(entity.getBukkitEntity());
+                    }
+                    if (result.isEmpty() && !allowEmpty) {
+                        throw EntityArgument.NO_ENTITIES_FOUND.create();
+                    } else {
+                        yield result;
+                    }
+                } catch (CommandSyntaxException e) {
+                    if (allowEmpty) {
+                        yield new ArrayList<org.bukkit.entity.Entity>();
+                    } else {
+                        throw e;
+                    }
+                }
+            case ENTITYSELECTOR_MANY_PLAYERS:
+                try {
+                    List<Player> result = new ArrayList<>();
+                    for (ServerPlayer player : argument.findPlayers(cmdCtx.getSource())) {
+                        result.add(player.getBukkitEntity());
+                    }
+                    if (result.isEmpty() && !allowEmpty) {
+                        throw EntityArgument.NO_PLAYERS_FOUND.create();
+                    } else {
+                        yield result;
+                    }
+                } catch (CommandSyntaxException e) {
+                    if (allowEmpty) {
+                        yield new ArrayList<Player>();
+                    } else {
+                        throw e;
+                    }
+                }
+            case ENTITYSELECTOR_ONE_ENTITY:
+                yield argument.findSingleEntity(cmdCtx.getSource()).getBukkitEntity();
+            case ENTITYSELECTOR_ONE_PLAYER:
+                yield argument.findSinglePlayer(cmdCtx.getSource()).getBukkitEntity();
+            default:
+                throw new IllegalArgumentException("Unexpected value: " + subType);
+        };
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public final EntityType getEntityType(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        return EntityType.fromName(net.minecraft.world.entity.EntityType
+                .getKey(ResourceArgument.getSummonableEntityType(cmdCtx, key).value()).getPath());
+    }
+
+    @Override
+    public FloatRange getFloatRange(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        MinMaxBounds.Doubles range = RangeArgument.Floats.getRange(cmdCtx, key);
+        final Double lowBoxed = range.min().orElse(null);
+        final Double highBoxed = range.max().orElse(null);
+        final double low = lowBoxed == null ? -Float.MAX_VALUE : lowBoxed;
+        final double high = highBoxed == null ? Float.MAX_VALUE : highBoxed;
+        return new FloatRange((float) low, (float) high);
+    }
+
+    @Override
+    public final FunctionWrapper[] getFunction(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        List<FunctionWrapper> result = new ArrayList<>();
+        CommandSourceStack css = cmdCtx.getSource().withSuppressedOutput().withMaximumPermission(2);
+
+        for (CommandFunction<CommandSourceStack> commandFunction : FunctionArgument.getFunctions(cmdCtx, key)) {
+            result.add(FunctionWrapper.fromSimpleFunctionWrapper(convertFunction(commandFunction), css,
+                    entity -> cmdCtx.getSource().withEntity(((CraftEntity) entity).getHandle())));
+        }
+        return result.toArray(new FunctionWrapper[0]);
+    }
+
+    @Override
+    public SimpleFunctionWrapper getFunction(NamespacedKey key) {
+        final ResourceLocation resourceLocation = new ResourceLocation(key.getNamespace(), key.getKey());
+        Optional<CommandFunction<CommandSourceStack>> commandFunctionOptional = this
+                .<MinecraftServer>getMinecraftServer().getFunctions().get(resourceLocation);
+        if (commandFunctionOptional.isPresent()) {
+            return convertFunction(commandFunctionOptional.get());
+        } else {
+            throw new IllegalStateException("Failed to get defined function " + key
+                    + "! This should never happen - please report this to the CommandAPI"
+                    + "developers, we'd love to know how you got this error message!");
+        }
+    }
+
+    @Override
+    public Set<NamespacedKey> getFunctions() {
+        Set<NamespacedKey> result = new HashSet<>();
+        for (ResourceLocation resourceLocation : this.<MinecraftServer>getMinecraftServer().getFunctions()
+                .getFunctionNames()) {
+            result.add(fromResourceLocation(resourceLocation));
+        }
+        return result;
+    }
+
+    @Override
+    public IntegerRange getIntRange(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        MinMaxBounds.Ints range = RangeArgument.Ints.getRange(cmdCtx, key);
+        final Integer lowBoxed = range.min().orElse(null);
+        final Integer highBoxed = range.max().orElse(null);
+        final int low = lowBoxed == null ? Integer.MIN_VALUE : lowBoxed;
+        final int high = highBoxed == null ? Integer.MAX_VALUE : highBoxed;
+        return new IntegerRange(low, high);
+    }
+
+    @Override
+    public final org.bukkit.inventory.ItemStack getItemStack(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        ItemInput input = ItemArgument.getItem(cmdCtx, key);
+
+        // Create the basic ItemStack with an amount of 1
+        ItemStack item = input.createItemStack(1, false);
+        return CraftItemStack.asBukkitCopy(item);
+    }
+
+    @Override
+    public final Predicate<org.bukkit.inventory.ItemStack> getItemStackPredicate(
+            CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        // Not inside the lambda because getItemPredicate throws CommandSyntaxException
+        Predicate<ItemStack> predicate = ItemPredicateArgument.getItemPredicate(cmdCtx, key);
+        return item -> predicate.test(CraftItemStack.asNMSCopy(item));
+    }
+
+    @Override
+    public final Location2D getLocation2DBlock(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        ColumnPos blockPos = ColumnPosArgument.getColumnPos(cmdCtx, key);
+        return new Location2D(getWorldForCSS(cmdCtx.getSource()), blockPos.x(), blockPos.z());
+    }
+
+    @Override
+    public final Location2D getLocation2DPrecise(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        Vec2 vecPos = Vec2Argument.getVec2(cmdCtx, key);
+        return new Location2D(getWorldForCSS(cmdCtx.getSource()), vecPos.x, vecPos.y);
+    }
+
+    @Override
+    public final Location getLocationBlock(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        BlockPos blockPos = BlockPosArgument.getSpawnablePos(cmdCtx, key);
+        return new Location(getWorldForCSS(cmdCtx.getSource()), blockPos.getX(), blockPos.getY(), blockPos.getZ());
+    }
+
+    @Override
+    public final Location getLocationPrecise(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        Vec3 vecPos = Vec3Argument.getCoordinates(cmdCtx, key).getPosition(cmdCtx.getSource());
+        return new Location(getWorldForCSS(cmdCtx.getSource()), vecPos.x(), vecPos.y(), vecPos.z());
+    }
+
+    @Override
+    public final LootTable getLootTable(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return CraftLootTable.minecraftToBukkit(ResourceLocationArgument.getId(cmdCtx, key));
+    }
+
+    @Override
+    public NamespacedKey getMinecraftKey(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return fromResourceLocation(ResourceLocationArgument.getId(cmdCtx, key));
+    }
+
+    @SuppressWarnings("UnnecessaryBoxing")
+    @Differs(from = "1.20.4", by = "New particle option ColorParticleOption")
+    @Override
+    public final ParticleData<?> getParticle(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        final ParticleOptions particleOptions = ParticleArgument.getParticle(cmdCtx, key);
+
+        // In our test suite, we can't parse particles via CraftParticle.minecraftToBukkit
+        // on 1.20.3+ because initializing CraftParticle's static constructor requires
+        // implementing a registry. We don't care about a registry for the sake of testing,
+        // all we're actually interested in is testing that the particle data is being parsed
+        // and converted to Bukkit properly, because that's what actually matters. If the
+        // Bukkit#getServer is a CraftServer, that means we're running on a normal (Bukkit/Spigot/Paper)
+        // server. If it isn't, that means we're running in our test environment (i.e. a mocked
+        // server instance), or some weird flavour of Bukkit that we're not supposed to use.
+        final Particle particle;
+        if (Bukkit.getServer() instanceof CraftServer server) {
+            particle = CraftParticle.minecraftToBukkit(particleOptions.getType());
+        } else {
+            particle = null;
+        }
+
+        switch (particleOptions) {
+            case SimpleParticleType simpleParticleType -> {
+                return new ParticleData<Void>(particle, null);
+            }
+            case BlockParticleOption options -> {
+                return new ParticleData<BlockData>(particle, CraftBlockData.fromData(options.getState()));
+            }
+            case DustColorTransitionOptions options -> {
+                return getParticleDataAsDustColorTransitionOption(particle, options);
+            }
+            case DustParticleOptions options -> {
+                final Color color = Color.fromRGB((int) (options.getColor().x() * 255.0F),
+                        (int) (options.getColor().y() * 255.0F), (int) (options.getColor().z() * 255.0F));
+                return new ParticleData<DustOptions>(particle, new DustOptions(color, options.getScale()));
+            }
+            case ItemParticleOption options -> {
+                return new ParticleData<org.bukkit.inventory.ItemStack>(particle,
+                        CraftItemStack.asBukkitCopy(options.getItem()));
+            }
+            case VibrationParticleOption options -> {
+                return getParticleDataAsVibrationParticleOption(cmdCtx, particle, options);
+            }
+            case ShriekParticleOption options -> {
+                // CraftBukkit implements shriek particles as a (boxed) Integer object
+                return new ParticleData<Integer>(particle, Integer.valueOf(options.getDelay()));
+            }
+            case SculkChargeParticleOptions options -> {
+                // CraftBukkit implements sculk charge particles as a (boxed) Float object
+                return new ParticleData<Float>(particle, Float.valueOf(options.roll()));
+            }
+            case ColorParticleOption options -> {
+                return getParticleDataAsColorParticleOption(particle, options);
+            }
+            default -> {
+                CommandAPI.getLogger().warning("Invalid particle data type for " + particle.getDataType().toString());
+                return new ParticleData<Void>(particle, null);
+            }
+        }
+    }
+
+    @Differs(from = "1.20.4", by = "This now exists")
+    private ParticleData<Color> getParticleDataAsColorParticleOption(Particle particle,
+                                                                     ColorParticleOption options) {
+        final Color color = Color.fromARGB(
+                (int) (options.getAlpha() * 255.0F),
+                (int) (options.getRed() * 255.0F),
+                (int) (options.getGreen() * 255.0F),
+                (int) (options.getBlue() * 255.0F)
+        );
+        return new ParticleData<Color>(particle, color);
+    }
+
+    @Differs(from = "1.20.4", by = "Now uses options#getFromColor instead of options.getColor")
+    private ParticleData<DustTransition> getParticleDataAsDustColorTransitionOption(Particle particle,
+                                                                                    DustColorTransitionOptions options) {
+        final Color color = Color.fromRGB((int) (options.getFromColor().x() * 255.0F),
+                (int) (options.getFromColor().y() * 255.0F), (int) (options.getFromColor().z() * 255.0F));
+        final Color toColor = Color.fromRGB((int) (options.getToColor().x() * 255.0F),
+                (int) (options.getToColor().y() * 255.0F), (int) (options.getToColor().z() * 255.0F));
+        return new ParticleData<DustTransition>(particle, new DustTransition(color, toColor, options.getScale()));
+    }
+
+    @SuppressWarnings("removal")
+    private ParticleData<?> getParticleDataAsVibrationParticleOption(CommandContext<CommandSourceStack> cmdCtx,
+                                                                     Particle particle, VibrationParticleOption options) {
+        // The "from" part of the Vibration object in Bukkit is completely ignored now,
+        // so we just populate it with some "feasible" information
+        final Vec3 origin = cmdCtx.getSource().getPosition();
+        Level level = cmdCtx.getSource().getLevel();
+        Location from = new Location(level.getWorld(), origin.x, origin.y, origin.z);
+        final Destination destination;
+
+        if (options.getDestination() instanceof BlockPositionSource positionSource) {
+            Vec3 to = positionSource.getPosition(level).get();
+            destination = new BlockDestination(new Location(level.getWorld(), to.x(), to.y(), to.z()));
+        } else {
+            CommandAPI.getLogger().warning("Unknown or unsupported vibration destination " + options.getDestination());
+            return new ParticleData<Void>(particle, null);
+        }
+        return new ParticleData<Vibration>(particle, new Vibration(from, destination, options.getArrivalInTicks()));
+    }
+
+    @Override
+    public Object getPotionEffect(CommandContext<CommandSourceStack> cmdCtx, String key, ArgumentSubType subType) throws CommandSyntaxException {
+        return switch (subType) {
+            case POTION_EFFECT_POTION_EFFECT -> CraftPotionEffectType.minecraftToBukkit(ResourceArgument.getMobEffect(cmdCtx, key).value());
+            case POTION_EFFECT_NAMESPACEDKEY -> fromResourceLocation(ResourceLocationArgument.getId(cmdCtx, key));
+            default -> throw new IllegalArgumentException("Unexpected value: " + subType);
+        };
+    }
+
+    @Override
+    public final Recipe getRecipe(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        RecipeHolder<?> recipe = ResourceLocationArgument.getRecipe(cmdCtx, key);
+        return new ComplexRecipeImpl(fromResourceLocation(recipe.id()), recipe.toBukkitRecipe());
+    }
+
+    @Override
+    public ScoreboardSlot getScoreboardSlot(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return ScoreboardSlot.ofMinecraft(ScoreboardSlotArgument.getDisplaySlot(cmdCtx, key).id());
+    }
+
+    @Override
+    public Collection<String> getScoreHolderMultiple(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        final Collection<ScoreHolder> scoreHolders = ScoreHolderArgument.getNames(cmdCtx, key);
+        Set<String> scoreHolderNames = new HashSet<>();
+        for (ScoreHolder scoreHolder : scoreHolders) {
+            scoreHolderNames.add(scoreHolder.getScoreboardName());
+        }
+        return scoreHolderNames;
+    }
+
+    @Override
+    public String getScoreHolderSingle(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        return ScoreHolderArgument.getName(cmdCtx, key).getScoreboardName();
+    }
+
+    @Override
+    public BukkitCommandSender<? extends CommandSender> getSenderForCommand(CommandContext<CommandSourceStack> cmdCtx,
+                                                                            boolean isNative) {
+        CommandSourceStack css = cmdCtx.getSource();
+
+        CommandSender sender = css.getBukkitSender();
+        if (sender == null) {
+            // Sender CANNOT be null. This can occur when using a remote console
+            // sender. You can access it directly using
+            // this.<MinecraftServer>getMinecraftServer().remoteConsole
+            // however this may also be null, so delegate to the next most-meaningful
+            // sender.
+            sender = Bukkit.getConsoleSender();
+        }
+        Vec3 pos = css.getPosition();
+        Vec2 rot = css.getRotation();
+        World world = getWorldForCSS(css);
+        Location location = new Location(world, pos.x(), pos.y(), pos.z(), rot.y, rot.x);
+
+        Entity proxyEntity = css.getEntity();
+        CommandSender proxy = proxyEntity == null ? null : proxyEntity.getBukkitEntity();
+        if (isNative || (proxy != null && !sender.equals(proxy))) {
+            if (proxy == null) {
+                proxy = sender;
+            }
+
+            return new BukkitNativeProxyCommandSender(new NativeProxyCommandSender(sender, proxy, location, world));
+        } else {
+            return wrapCommandSender(sender);
+        }
+    }
+
+    @Override
+    public final SimpleCommandMap getSimpleCommandMap() {
+        return ((CraftServer) Bukkit.getServer()).getCommandMap();
+    }
+
+    @Override
+    public final Object getSound(CommandContext<CommandSourceStack> cmdCtx, String key, ArgumentSubType subType) {
+        final ResourceLocation soundResource = ResourceLocationArgument.getId(cmdCtx, key);
+        return switch (subType) {
+            case SOUND_SOUND -> {
+                final SoundEvent soundEvent = BuiltInRegistries.SOUND_EVENT.get(soundResource);
+                if (soundEvent == null) {
+                    yield null;
+                } else {
+                    yield CraftSound.minecraftToBukkit(soundEvent);
+                }
+            }
+            case SOUND_NAMESPACEDKEY -> {
+                yield NamespacedKey.fromString(soundResource.getNamespace() + ":" + soundResource.getPath());
+            }
+            default -> throw new IllegalArgumentException("Unexpected value: " + subType);
+        };
+    }
+
+    @Override
+    public SuggestionProvider<CommandSourceStack> getSuggestionProvider(SuggestionProviders provider) {
+        return switch (provider) {
+            case FUNCTION -> (context, builder) -> {
+                ServerFunctionManager functionData = this.<MinecraftServer>getMinecraftServer().getFunctions();
+                SharedSuggestionProvider.suggestResource(functionData.getTagNames(), builder, "#");
+                return SharedSuggestionProvider.suggestResource(functionData.getFunctionNames(), builder);
+            };
+            case RECIPES -> net.minecraft.commands.synchronization.SuggestionProviders.ALL_RECIPES;
+            case SOUNDS -> net.minecraft.commands.synchronization.SuggestionProviders.AVAILABLE_SOUNDS;
+            case ADVANCEMENTS -> (cmdCtx, builder) -> {
+                return SharedSuggestionProvider.suggestResource(this.<MinecraftServer>getMinecraftServer().getAdvancements()
+                        .getAllAdvancements().stream().map(AdvancementHolder::id), builder);
+            };
+            case LOOT_TABLES -> (cmdCtx, builder) -> {
+                return SharedSuggestionProvider.suggestResource(
+                        this.<MinecraftServer>getMinecraftServer().reloadableRegistries().getKeys(Registries.LOOT_TABLE), builder);
+            };
+            case BIOMES -> _ArgumentSyntheticBiome()::listSuggestions;
+            case ENTITIES -> net.minecraft.commands.synchronization.SuggestionProviders.SUMMONABLE_ENTITIES;
+            default -> (context, builder) -> Suggestions.empty();
+        };
+    }
+
+    @Override
+    public final SimpleFunctionWrapper[] getTag(NamespacedKey key) {
+        Collection<CommandFunction<CommandSourceStack>> customFunctions = this.<MinecraftServer>getMinecraftServer().getFunctions().getTag(new ResourceLocation(key.getNamespace(), key.getKey()));
+        SimpleFunctionWrapper[] convertedCustomFunctions = new SimpleFunctionWrapper[customFunctions.size()];
+        int index = 0;
+        for (CommandFunction<CommandSourceStack> customFunction : customFunctions) {
+            convertedCustomFunctions[index++] = convertFunction(customFunction);
+        }
+        return convertedCustomFunctions;
+    }
+
+    @Override
+    public Set<NamespacedKey> getTags() {
+        Set<NamespacedKey> result = new HashSet<>();
+        for (ResourceLocation resourceLocation : this.<MinecraftServer>getMinecraftServer().getFunctions().getTagNames()) {
+            result.add(fromResourceLocation(resourceLocation));
+        }
+        return result;
+    }
+
+    @Override
+    public World getWorldForCSS(CommandSourceStack css) {
+        return (css.getLevel() == null) ? null : css.getLevel().getWorld();
+    }
+
+    @Override
+    public final void reloadDataPacks() {
+        CommandAPI.logNormal("Reloading datapacks...");
+
+        // Get previously declared recipes to be re-registered later
+        Iterator<Recipe> recipes = Bukkit.recipeIterator();
+
+        // Update the commandDispatcher with the current server's commandDispatcher
+        ReloadableResources serverResources = this.<MinecraftServer>getMinecraftServer().resources;
+        serverResources.managers().commands = this.<MinecraftServer>getMinecraftServer().getCommands();
+
+        // Update the ServerFunctionLibrary's command dispatcher with the new one
+        try {
+            serverFunctionLibraryDispatcher.set(serverResources.managers().getFunctionLibrary(),
+                    getBrigadierDispatcher());
+        } catch (IllegalAccessException ignored) {
+            // Shouldn't happen, CommandAPIHandler#getField makes it accessible
+        }
+
+        // From this.<MinecraftServer>getMinecraftServer().reloadResources //
+        // Discover new packs
+        Collection<String> collection;
+        {
+            List<String> packIDs = new ArrayList<>(
+                    this.<MinecraftServer>getMinecraftServer().getPackRepository().getSelectedIds());
+            List<String> disabledPacks = this.<MinecraftServer>getMinecraftServer().getWorldData()
+                    .getDataConfiguration().dataPacks().getDisabled();
+
+            for (String availablePack : this.<MinecraftServer>getMinecraftServer().getPackRepository()
+                    .getAvailableIds()) {
+                // Add every other available pack that is not disabled
+                // and is not already in the list of existing packs
+                if (!disabledPacks.contains(availablePack) && !packIDs.contains(availablePack)) {
+                    packIDs.add(availablePack);
+                }
+            }
+            collection = packIDs;
+        }
+
+        // Step 1: Construct an async supplier of a list of all resource packs to
+        // be loaded in the reload phase
+        CompletableFuture<List<PackResources>> first = CompletableFuture.supplyAsync(() -> {
+            PackRepository serverPackRepository = this.<MinecraftServer>getMinecraftServer().getPackRepository();
+
+            List<PackResources> packResources = new ArrayList<>();
+            for (String packID : collection) {
+                Pack pack = serverPackRepository.getPack(packID);
+                if (pack != null) {
+                    packResources.add(pack.open());
+                }
+            }
+            return packResources;
+        });
+
+        // Step 2: Convert all of the resource packs into ReloadableResources which
+        // are replaced by our custom server resources with defined commands
+        CompletableFuture<ReloadableResources> second = first.thenCompose(packResources -> {
+            MultiPackResourceManager resourceManager = new MultiPackResourceManager(PackType.SERVER_DATA,
+                    packResources);
+
+            // Not using packResources, because we really really want this to work
+            CompletableFuture<?> simpleReloadInstance = SimpleReloadInstance.create(resourceManager,
+                    serverResources.managers().listeners(), this.<MinecraftServer>getMinecraftServer().executor,
+                    this.<MinecraftServer>getMinecraftServer(), CompletableFuture
+                            .completedFuture(Unit.INSTANCE) /* ReloadableServerResources.DATA_RELOAD_INITIAL_TASK */,
+                    LogUtils.getLogger().isDebugEnabled()).done();
+
+            return simpleReloadInstance.thenApply(x -> serverResources);
+        });
+
+        // Step 3: Actually load all of the resources
+        CompletableFuture<Void> third = second.thenAcceptAsync(resources -> {
+            this.<MinecraftServer>getMinecraftServer().resources.close();
+            this.<MinecraftServer>getMinecraftServer().resources = serverResources;
+            this.<MinecraftServer>getMinecraftServer().server.syncCommands();
+            this.<MinecraftServer>getMinecraftServer().getPackRepository().setSelected(collection);
+
+            // this.<MinecraftServer>getMinecraftServer().getSelectedPacks
+            Collection<String> selectedIDs = this.<MinecraftServer>getMinecraftServer().getPackRepository()
+                    .getSelectedIds();
+            List<String> enabledIDs = ImmutableList.copyOf(selectedIDs);
+            List<String> disabledIDs = new ArrayList<>(
+                    this.<MinecraftServer>getMinecraftServer().getPackRepository().getAvailableIds());
+
+            disabledIDs.removeIf(enabledIDs::contains);
+
+            this.<MinecraftServer>getMinecraftServer().getWorldData()
+                    .setDataConfiguration(new WorldDataConfiguration(new DataPackConfig(enabledIDs, disabledIDs),
+                            this.<MinecraftServer>getMinecraftServer().getWorldData().getDataConfiguration()
+                                    .enabledFeatures()));
+            // this.<MinecraftServer>getMinecraftServer().resources.managers().updateRegistryTags(registryAccess);
+            this.<MinecraftServer>getMinecraftServer().resources.managers().updateRegistryTags();
+            // May need to be commented out, may not. Comment it out just in case.
+            // For some reason, calling getPlayerList().saveAll() may just hang
+            // the server indefinitely. Not sure why!
+            // this.<MinecraftServer>getMinecraftServer().getPlayerList().saveAll();
+            // this.<MinecraftServer>getMinecraftServer().getPlayerList().reloadResources();
+            // this.<MinecraftServer>getMinecraftServer().getFunctions().replaceLibrary(this.<MinecraftServer>getMinecraftServer().resources.managers().getFunctionLibrary());
+            this.<MinecraftServer>getMinecraftServer().getStructureManager()
+                    .onResourceManagerReload(this.<MinecraftServer>getMinecraftServer().resources.resourceManager());
+        });
+
+        // Step 4: Block the thread until everything's done
+        if (this.<MinecraftServer>getMinecraftServer().isSameThread()) {
+            this.<MinecraftServer>getMinecraftServer().managedBlock(third::isDone);
+        }
+
+        // Run the completableFuture (and bind tags?)
+        try {
+
+            // Register recipes again because reloading datapacks
+            // removes all non-vanilla recipes
+            registerBukkitRecipesSafely(recipes);
+
+            CommandAPI.logNormal("Finished reloading datapacks");
+        } catch (Exception e) {
+            StringWriter stringWriter = new StringWriter();
+            PrintWriter printWriter = new PrintWriter(stringWriter);
+            e.printStackTrace(printWriter);
+
+            CommandAPI.logError(
+                    "Failed to load datapacks, can't proceed with normal server load procedure. Try fixing your datapacks?\n"
+                            + stringWriter.toString());
+        }
+    }
+
+    @Override
+    public Message generateMessageFromJson(String json) {
+        // TODO: Same as #getAdventureChatComponent, figure out if an empty provider is suitable here
+        return Serializer.fromJson(json, COMMAND_BUILD_CONTEXT);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> T getMinecraftServer() {
+        if (Bukkit.getServer() instanceof CraftServer server) {
+            return (T) server.getServer();
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public ArgumentType<?> _ArgumentMobEffect() {
+        return ResourceArgument.resource(COMMAND_BUILD_CONTEXT, Registries.MOB_EFFECT);
+    }
+
+    @Override
+    public ArgumentType<?> _ArgumentEntitySummon() {
+        return ResourceArgument.resource(COMMAND_BUILD_CONTEXT, Registries.ENTITY_TYPE);
+    }
+
+    @Override
+    public CommandRegistrationStrategy<CommandSourceStack> createCommandRegistrationStrategy() {
+        return new PaperCommandRegistration<>(
+                () -> this.<MinecraftServer>getMinecraftServer().getCommands().getDispatcher(),
+                node -> isBukkitCommand(node.getCommand())
+        );
+    }
+
+    private boolean isBukkitCommand(Object o) {
+        return o instanceof BukkitCommandNode.BukkitBrigCommand;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/jorel/commandapi/nms/NMS_Common.java b/src/main/java/dev/jorel/commandapi/nms/NMS_Common.java
new file mode 100644
index 0000000000000000000000000000000000000000..d9d2f5a111f1fac23de7f87e224c75112416d80d
--- /dev/null
+++ b/src/main/java/dev/jorel/commandapi/nms/NMS_Common.java
@@ -0,0 +1,595 @@
+/*******************************************************************************
+ * Copyright 2018, 2021 Jorel Ali (Skepter) - MIT License
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *******************************************************************************/
+package dev.jorel.commandapi.nms;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import dev.jorel.commandapi.CommandAPIBukkit;
+import dev.jorel.commandapi.CommandAPIHandler;
+import dev.jorel.commandapi.CommandRegistrationStrategy;
+import dev.jorel.commandapi.arguments.ArgumentSubType;
+import dev.jorel.commandapi.arguments.SuggestionProviders;
+import dev.jorel.commandapi.commandsenders.AbstractCommandSender;
+import dev.jorel.commandapi.commandsenders.BukkitCommandSender;
+import dev.jorel.commandapi.preprocessor.Differs;
+import dev.jorel.commandapi.preprocessor.Overridden;
+import dev.jorel.commandapi.preprocessor.Unimplemented;
+import dev.jorel.commandapi.wrappers.Rotation;
+import dev.jorel.commandapi.wrappers.*;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.arguments.*;
+import net.minecraft.commands.arguments.coordinates.*;
+import net.minecraft.commands.arguments.item.FunctionArgument;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.phys.Vec2;
+import org.bukkit.*;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+import org.bukkit.help.HelpTopic;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.Recipe;
+import org.bukkit.loot.LootTable;
+import org.bukkit.potion.PotionEffectType;
+import org.bukkit.scoreboard.Objective;
+import org.bukkit.scoreboard.Team;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+import static dev.jorel.commandapi.preprocessor.Unimplemented.REASON.*;
+
+/**
+ * Common NMS code To ensure that this code actually works across all versions
+ * of Minecraft that this is supposed to support (1.17+), you should be
+ * compiling this code against all of the declared Maven profiles specified in
+ * this submodule's pom.xml file, by running the following commands:
+ * <ul>
+ * <li><code>mvn clean package -pl :commandapi-bukkit-nms-common -P Platform.Bukkit,Spigot_1_19_3_R2</code></li>
+ * <li><code>mvn clean package -pl :commandapi-bukkit-nms-common -P Platform.Bukkit,Spigot_1_19_R1</code></li>
+ * <li><code>mvn clean package -pl :commandapi-bukkit-nms-common -P Platform.Bukkit,Spigot_1_18_2_R2</code></li>
+ * <li><code>mvn clean package -pl :commandapi-bukkit-nms-common -P Platform.Bukkit,Spigot_1_18_R1</code></li>
+ * <li><code>mvn clean package -pl :commandapi-bukkit-nms-common -P Platform.Bukkit,Spigot_1_17_R1</code></li>
+ * </ul>
+ * Any of these that do not work should be removed or implemented otherwise
+ * (introducing another NMS_Common module perhaps?
+ */
+public abstract class NMS_Common extends CommandAPIBukkit<CommandSourceStack> {
+    private static NamespacedKey fromResourceLocation(ResourceLocation key) {
+        return NamespacedKey.fromString(key.getNamespace() + ":" + key.getPath());
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentAngle() {
+        return AngleArgument.angle();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentAxis() {
+        return SwizzleArgument.swizzle();
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19")
+    public abstract ArgumentType<?> _ArgumentBlockPredicate();
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19")
+    public abstract ArgumentType<?> _ArgumentBlockState();
+
+    @Override
+    public final ArgumentType<?> _ArgumentChat() {
+        return MessageArgument.message();
+    }
+
+    @Override
+    @Overridden(in = "1.20.5", because = "This now takes in a CommandBuildContext")
+    public ArgumentType<?> _ArgumentChatComponent() {
+        // return ComponentArgument.textComponent();
+        return null;
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentChatFormat() {
+        return ColorArgument.color();
+    }
+
+    @Override
+    public ArgumentType<?> _ArgumentDimension() {
+        return DimensionArgument.dimension();
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19.3")
+    public abstract ArgumentType<?> _ArgumentEnchantment();
+
+    @Override
+    // I mean... really? Why?
+    @Unimplemented(because = NAME_CHANGED, info = "a (1.17)                -> entity   (1.18) -> a (1.19)")
+    @Unimplemented(because = NAME_CHANGED, info = "multipleEntities (1.17) -> entities (1.18) -> b (1.19)")
+    @Unimplemented(because = NAME_CHANGED, info = "c (1.17)                -> player   (1.18) -> c (1.19)")
+    @Unimplemented(because = NAME_CHANGED, info = "d (1.17)                -> players  (1.18) -> d (1.19)")
+    public abstract ArgumentType<?> _ArgumentEntity(ArgumentSubType subType);
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19.3")
+    public abstract ArgumentType<?> _ArgumentEntitySummon();
+
+    @Override
+    public final ArgumentType<?> _ArgumentFloatRange() {
+        return RangeArgument.floatRange();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentIntRange() {
+        return RangeArgument.intRange();
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19")
+    public abstract ArgumentType<?> _ArgumentItemPredicate();
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19")
+    public abstract ArgumentType<?> _ArgumentItemStack();
+
+    @Override
+    public final ArgumentType<?> _ArgumentMathOperation() {
+        return OperationArgument.operation();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentMinecraftKeyRegistered() {
+        return ResourceLocationArgument.id();
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19.3")
+    public abstract ArgumentType<?> _ArgumentMobEffect();
+
+    @Override
+    public final ArgumentType<?> _ArgumentNBTCompound() {
+        return CompoundTagArgument.compoundTag();
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19.3")
+    public abstract ArgumentType<?> _ArgumentParticle();
+
+    @Override
+    public final ArgumentType<?> _ArgumentPosition() {
+        return BlockPosArgument.blockPos();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentPosition2D() {
+        return ColumnPosArgument.columnPos();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentProfile() {
+        return GameProfileArgument.gameProfile();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentRotation() {
+        return RotationArgument.rotation();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentScoreboardCriteria() {
+        return ObjectiveCriteriaArgument.criteria();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentScoreboardObjective() {
+        return ObjectiveArgument.objective();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentScoreboardSlot() {
+        return ScoreboardSlotArgument.displaySlot();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentScoreboardTeam() {
+        return TeamArgument.team();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentScoreholder(ArgumentSubType subType) {
+        return switch(subType) {
+            case SCOREHOLDER_SINGLE -> ScoreHolderArgument.scoreHolder();
+            case SCOREHOLDER_MULTIPLE -> ScoreHolderArgument.scoreHolders();
+            default -> throw new IllegalArgumentException("Unexpected value: " + subType);
+        };
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.18.2")
+    public abstract ArgumentType<?> _ArgumentSyntheticBiome();
+
+    @Override
+    public final ArgumentType<?> _ArgumentTag() {
+        return FunctionArgument.functions();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentTime() {
+        return TimeArgument.time();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentUUID() {
+        return UuidArgument.uuid();
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentVec2(boolean centerPosition) {
+        return Vec2Argument.vec2(centerPosition);
+    }
+
+    @Override
+    public final ArgumentType<?> _ArgumentVec3(boolean centerPosition) {
+        return Vec3Argument.vec3(centerPosition);
+    }
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "SimpleHelpMap")
+    public abstract Map<String, HelpTopic> getHelpMap();
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION)
+    public abstract String[] compatibleVersions();
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftItemStack")
+    public abstract String convert(ItemStack is);
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION)
+    public abstract String convert(ParticleData<?> particle);
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public final String convert(PotionEffectType potion) {
+        return potion.getName().toLowerCase(Locale.ENGLISH);
+    }
+
+    @Override
+    public final String convert(Sound sound) {
+        return sound.getKey().toString();
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19")
+    public abstract void createDispatcherFile(File file, CommandDispatcher<CommandSourceStack> dispatcher) throws IOException;
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CustomHelpTopic")
+    public abstract HelpTopic generateHelpTopic(String commandName, String shortDescription, String fullDescription,
+                                                String permission);
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.20.2")
+    public abstract org.bukkit.advancement.Advancement getAdvancement(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException;
+
+    @Override
+    @Overridden(in = "1.20.5", because = "Serializer.toJson now needs a Provider")
+    public Component getAdventureChat(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        // return GsonComponentSerializer.gson().deserialize(Serializer.toJson(MessageArgument.getMessage(cmdCtx, key)));
+        return null;
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, from = "ofExact", to = "namedColor", in = "NamedTextColor", introducedIn = "Adventure 4.10.0", info = "1.18 uses Adventure 4.9.3. 1.18.2 uses Adventure 4.11.0")
+    public abstract NamedTextColor getAdventureChatColor(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @Override
+    public final float getAngle(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return AngleArgument.getAngle(cmdCtx, key);
+    }
+
+    @Override
+    public final EnumSet<Axis> getAxis(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        EnumSet<Axis> set = EnumSet.noneOf(Axis.class);
+        EnumSet<net.minecraft.core.Direction.Axis> parsedEnumSet = SwizzleArgument.getSwizzle(cmdCtx, key);
+        for (net.minecraft.core.Direction.Axis element : parsedEnumSet) {
+            set.add(switch (element) {
+                case X -> Axis.X;
+                case Y -> Axis.Y;
+                case Z -> Axis.Z;
+            });
+        }
+        return set;
+    }
+
+    @Override
+    @Unimplemented(because = NAME_CHANGED, from = "getWorld()", to = "f()", in = "1.19")
+    public abstract Predicate<Block> getBlockPredicate(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftBlockData")
+    public abstract BlockData getBlockState(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @SuppressWarnings("deprecation")
+    @Override
+    @Overridden(in = "1.20.5", because = "Serializer.toJson now needs a Provider")
+    public BaseComponent[] getChat(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        // return ComponentSerializer.parse(Serializer.toJson(MessageArgument.getMessage(cmdCtx, key)));
+        return null;
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public final ChatColor getChatColor(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return ChatColor.getByChar(ColorArgument.getColor(cmdCtx, key).getChar());
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public final BaseComponent[] getChatComponent(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        // return ComponentSerializer.parse(Serializer.toJson(ComponentArgument.getComponent(cmdCtx, key)));
+        return null;
+    }
+
+    @Override
+    public abstract CommandSourceStack getBrigadierSourceFromCommandSender(AbstractCommandSender<? extends CommandSender> sender);
+
+    @Override
+    public final BukkitCommandSender<? extends CommandSender> getCommandSenderFromCommandSource(CommandSourceStack css) {
+        try {
+            return wrapCommandSender(css.getBukkitSender());
+        } catch (UnsupportedOperationException e) {
+            return null;
+        }
+    }
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftWorld", info = "CraftWorld is implicitly referenced by ServerLevel#getWorld, due to package renaming, it can't resolve at runtime")
+    public abstract World getDimension(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.19.3")
+    public abstract Enchantment getEnchantment(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = NAME_CHANGED, from = "getKey()", to = "a()", in = "1.19")
+    public abstract EntityType getEntityType(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.20.2")
+    public abstract FloatRange getFloatRange(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftEntity")
+    public abstract FunctionWrapper[] getFunction(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, in = "1.17, 1.18 and 1.18.2")
+    public abstract SimpleFunctionWrapper getFunction(NamespacedKey key);
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, in = "1.17, 1.18 and 1.18.2")
+    public abstract Set<NamespacedKey> getFunctions();
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.20.2")
+    public abstract IntegerRange getIntRange(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftItemStack")
+    public abstract ItemStack getItemStack(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftItemStack")
+    public abstract Predicate<ItemStack> getItemStackPredicate(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = { NAME_CHANGED, REQUIRES_CSS }, from = "a, b", to = "c(), d()")
+    public abstract Location2D getLocation2DBlock(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    public Location2D getLocation2DPrecise(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        Vec2 vecPos = Vec2Argument.getVec2(cmdCtx, key);
+        return new Location2D(getWorldForCSS(cmdCtx.getSource()), vecPos.x, vecPos.y);
+    }
+
+    @Override
+    @Unimplemented(because = { NAME_CHANGED, REQUIRES_CSS }, from = "getX(), getY(), getZ()", to = "u(), v(), w()")
+    public abstract Location getLocationBlock(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = { NAME_CHANGED, REQUIRES_CSS }, from = "getX(), getY(), getZ()", to = "a(), b(), c()")
+    public abstract Location getLocationPrecise(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftLootTable")
+    public abstract LootTable getLootTable(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @Override
+    public final MathOperation getMathOperation(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        // We run this to ensure the argument exists/parses properly
+        OperationArgument.getOperation(cmdCtx, key);
+        return MathOperation.fromString(CommandAPIHandler.getRawArgumentInput(cmdCtx, key));
+    }
+
+    @Override
+    @Overridden(in = "1.17 common; 1.18", because = "1.17 uses ArgumentMinecraftKeyRegistered.f instead of ArgumentMinecraftKeyRegistered.e")
+    @Overridden(in = "1.20.5, 1.20.6", because = "ArgumentMinecraftKeyRegistered.e -> ArgumentMinecraftKeyRegistered.c")
+    public NamespacedKey getMinecraftKey(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return fromResourceLocation(ResourceLocationArgument.getId(cmdCtx, key));
+    }
+
+    @Override
+    public final <NBTContainer> Object getNBTCompound(CommandContext<CommandSourceStack> cmdCtx, String key,
+                                                      Function<Object, NBTContainer> nbtContainerConstructor) {
+        return nbtContainerConstructor.apply(CompoundTagArgument.getCompoundTag(cmdCtx, key));
+    }
+
+    @Override
+    @Overridden(in = "1.17 common", because = "The Objective.getName() method mangles itself sometimes and I don't know why. Seems to be looking for Objective.b() or something")
+    public Objective getObjective(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        String objectiveName = ObjectiveArgument.getObjective(cmdCtx, key).getName();
+        return Bukkit.getScoreboardManager().getMainScoreboard().getObjective(objectiveName);
+    }
+
+    @Override
+    public final String getObjectiveCriteria(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return ObjectiveCriteriaArgument.getCriteria(cmdCtx, key).getName();
+    }
+
+    @Override
+    public final OfflinePlayer getOfflinePlayer(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        return Bukkit.getOfflinePlayer(GameProfileArgument.getGameProfiles(cmdCtx, key).iterator().next().getId());
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.18, 1.19")
+    public abstract ParticleData<?> getParticle(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @Override
+    public final Player getPlayer(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        Player target = Bukkit.getPlayer(GameProfileArgument.getGameProfiles(cmdCtx, key).iterator().next().getId());
+        if (target == null) {
+            throw GameProfileArgument.ERROR_UNKNOWN_PLAYER.create();
+        } else {
+            return target;
+        }
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.18")
+    public abstract Object getPotionEffect(CommandContext<CommandSourceStack> cmdCtx, String key, ArgumentSubType subType)
+            throws CommandSyntaxException;
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, info = """
+		1.17 has what appears to be a different obfuscation for recipe.getId().
+		I can't be bothered to figure out what it is, but all I know is it doesn't work,
+		and we need to move it outta here!
+		""")
+    public abstract Recipe getRecipe(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException;
+
+    @Override
+    public final Rotation getRotation(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        Vec2 rotation = RotationArgument.getRotation(cmdCtx, key).getRotation(cmdCtx.getSource());
+        return new Rotation(rotation.y, rotation.x);
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, introducedIn = "1.20.2")
+    public abstract ScoreboardSlot getScoreboardSlot(CommandContext<CommandSourceStack> cmdCtx, String key);
+
+    @Override
+    // Overridden in 1.20.3 because this now returns a Collection<ScoreHolder>
+    public Collection<String> getScoreHolderMultiple(CommandContext<CommandSourceStack> cmdCtx, String key)
+            throws CommandSyntaxException {
+        // return ScoreHolderArgument.getNames(cmdCtx, key);
+        return null;
+    }
+
+    @Override
+    // Overridden in 1.20.3 because this now returns a ScoreHolder
+    public String getScoreHolderSingle(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        // return ScoreHolderArgument.getName(cmdCtx, key);
+        return null;
+    }
+
+    @Override
+    // Whyyyyyyyyyyyyyyyyyyy
+    @Unimplemented(because = NAME_CHANGED, info = "CommandListenerWrapper changes:")
+    @Unimplemented(because = NAME_CHANGED, info = "getPosition (1.17)  -> getPosition (1.18) -> e (1.19)")
+    @Unimplemented(because = NAME_CHANGED, info = "i (1.17)            -> getRotation (1.18) -> l (1.19)")
+    @Unimplemented(because = NAME_CHANGED, info = "getEntity (1.17)    -> getEntity (1.18)   -> g (1.19)")
+    @Unimplemented(because = NAME_CHANGED, info = "getWorld (1.17)     -> getLevel (1.18)    -> f (1.19)")
+    public abstract BukkitCommandSender<? extends CommandSender> getSenderForCommand(CommandContext<CommandSourceStack> cmdCtx, boolean isNative);
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftServer")
+    public abstract SimpleCommandMap getSimpleCommandMap();
+
+    @Override
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "CraftSound")
+    public abstract Object getSound(CommandContext<CommandSourceStack> cmdCtx, String key, ArgumentSubType subType);
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, info = """
+		The various methods that this uses is obfuscated to different method
+		names for different versions. For example, getMinecraftServer().getLootTables.getIds()
+		is mapped to a different method in 1.18 compared to 1.19.2. This also has various other
+		implications across all sorts of versions, so it's much more reliable to just implement
+		them in every version.
+		""")
+    public abstract SuggestionProvider<CommandSourceStack> getSuggestionProvider(SuggestionProviders provider);
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION, from = "1.18.2", to = "1.19")
+    @Differs(from = "1.18.2", by = "getTag() now returns a Collection<> instead of a Tag<>, so don't have to call .getValues()")
+    public abstract SimpleFunctionWrapper[] getTag(NamespacedKey key);
+
+    @Override
+    @Unimplemented(because = NAME_CHANGED, info = "See https://github.com/JorelAli/CommandAPI/issues/524")
+    public abstract Set<NamespacedKey> getTags();
+
+    @Override
+    public Team getTeam(CommandContext<CommandSourceStack> cmdCtx, String key) throws CommandSyntaxException {
+        String teamName = TeamArgument.getTeam(cmdCtx, key).getName();
+        return Bukkit.getScoreboardManager().getMainScoreboard().getTeam(teamName);
+    }
+
+    @Override
+    public final int getTime(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return cmdCtx.getArgument(key, Integer.class);
+    }
+
+    @Override
+    public final UUID getUUID(CommandContext<CommandSourceStack> cmdCtx, String key) {
+        return UuidArgument.getUuid(cmdCtx, key);
+    }
+
+    @Override
+    @Unimplemented(because = VERSION_SPECIFIC_IMPLEMENTATION)
+    public abstract void reloadDataPacks();
+
+    @Override
+    @Unimplemented(because = NAME_CHANGED, info = "MinecraftServer#getCommands() obfuscated differently across multiple versions")
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "VanillaCommandWrapper")
+    @Unimplemented(because = REQUIRES_CRAFTBUKKIT, classNamed = "BukkitCommandWrapper")
+    public abstract CommandRegistrationStrategy<CommandSourceStack> createCommandRegistrationStrategy();
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
index 9af388a8e56806ab44f8c3ef4f97086ce38ef3b4..7956046156b8e382fb377ebbc63fe8738d38b4ca 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
@@ -75,6 +75,7 @@ public class ModernPluginLoadingStrategy<T> implements ProviderLoadingStrategy<T
 
             // Populate missing dependencies to capture if there are multiple missing ones.
             List<String> missingDependencies = provider.validateDependencies(dependencyTree);
+            if(missingDependencies.contains("CommandAPI")) missingDependencies.remove("CommandAPI"); // Lumina - CommandAPI support
 
             if (missingDependencies.isEmpty()) {
                 validatedProviders.add(provider);
diff --git a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
index d78ad5eccd18d89050a486a0c40090a09683bd16..8302e4bedc03795c4cda526466fa4dc279b2dd21 100644
--- a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -53,7 +53,7 @@ public class EntitySelector {
     @Nullable
     private final UUID entityUUID;
     private final EntityTypeTest<Entity, ?> type;
-    private final boolean usesSelector;
+    public final boolean usesSelector; // Lumina - Command API
 
     public EntitySelector(int count, boolean includesNonPlayers, boolean localWorldOnly, Predicate<Entity> basePredicate, MinMaxBounds.Doubles distance, Function<Vec3, Vec3> positionOffset, @Nullable AABB box, BiConsumer<Vec3, List<? extends Entity>> sorter, boolean senderOnly, @Nullable String playerName, @Nullable UUID uuid, @Nullable EntityType<?> type, boolean usesAt) {
         this.maxResults = count;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index cc40d3e69a3635ca7895876159f2821091c14a9a..f16e1ee682415cf1b49aeba2fb3f879b07be3226 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -91,6 +91,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     private RemoteSampleLogger tickTimeLogger;
     @Nullable
     private DebugSampleSubscriptionTracker debugSampleSubscriptionTracker;
+    private org.bukkit.plugin.java.JavaPlugin commandAPIPlugin; // Lumina - CommandAPI
 
     // CraftBukkit start - Signature changed
     public DedicatedServer(joptsimple.OptionSet options, WorldLoader.DataLoadContext worldLoader, Thread thread, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PackRepository resourcepackrepository, WorldStem worldstem, DedicatedServerSettings dedicatedserversettings, DataFixer datafixer, Services services, ChunkProgressListenerFactory worldloadlistenerfactory) {
@@ -281,6 +282,15 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         }
 
+        // Lumina start - enable CommandAPI
+        commandAPIPlugin = org.bukkit.plugin.java.CommandAPIPluginFactory.create();
+        dev.jorel.commandapi.CommandAPI.onLoad(new dev.jorel.commandapi.CommandAPIBukkitConfig(commandAPIPlugin)
+                .shouldHookPaperReload(false)
+                .skipReloadDatapacks(true)
+                .silentLogs(true)
+        );
+        dev.jorel.commandapi.CommandAPI.onEnable();
+        // Lumina end - enable CommandAPI
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // Spigot - moved up
         this.server.loadPlugins();
diff --git a/src/main/java/org/bukkit/plugin/java/CommandAPIPluginFactory.java b/src/main/java/org/bukkit/plugin/java/CommandAPIPluginFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..8afd999c0e4453df6b3b0c52cd6521758cd786b0
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/java/CommandAPIPluginFactory.java
@@ -0,0 +1,7 @@
+package org.bukkit.plugin.java;
+
+public class CommandAPIPluginFactory {
+    public static JavaPlugin create() {
+        return new JavaPlugin(null) {};
+    }
+}
\ No newline at end of file
