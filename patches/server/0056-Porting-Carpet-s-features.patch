From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7@outlook.com>
Date: Fri, 26 Jul 2024 01:09:46 +0800
Subject: [PATCH] Porting Carpet's features

This patch is Powered by:
* fabric-carpet(https://github.com/gnembon/fabric-carpet)
* plusls-carpet-addition(https://github.com/plusls/plusls-carpet-addition)
* Leaves(https://github.com/LeavesMC/Leaves)
Leaves License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html) (https://github.com/LeavesMC/Leaves?tab=License-1-ov-file)

fabric-carpet License:
MIT License

Copyright (c) 2020 gnembon

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

plusls-carpet-addition License: CC0-1.0 License (https://github.com/plusls/plusls-carpet-addition?tab=CC0-1.0-1-ov-file)

diff --git a/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java b/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
index 18dc2bf205844f0722e5b8b42d8063d97e000f1d..a41a8dae6c59f158f847f3cd232d0f69a1d904bb 100644
--- a/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
+++ b/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
@@ -59,7 +59,7 @@ public class BlockInput implements Predicate<BlockInWorld> {
     }
 
     public boolean place(ServerLevel world, BlockPos pos, int flags) {
-        BlockState blockState = Block.updateFromNeighbourShapes(this.state, world, pos);
+        BlockState blockState = (org.leavesmc.lumina.carpet.CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.get()) ? this.state : Block.updateFromNeighbourShapes(this.state, world, pos); // Lumina - Porting Carpet's features - fill updates
         if (blockState.isAir()) {
             blockState = this.state;
         }
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index ab289a6ca85459e03acb2089c6b9e931caa9c873..6445e07c597a7f67864783268770b74995c0d980 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -100,8 +100,25 @@ public enum Direction implements StringRepresentable {
     }
 
     public static Direction[] orderedByNearest(Entity entity) {
-        float f = entity.getViewXRot(1.0F) * (float) (Math.PI / 180.0);
-        float g = -entity.getViewYRot(1.0F) * (float) (Math.PI / 180.0);
+        // Lumina start - Porting Carpet's features
+        float pitch = entity.getViewXRot(1.0F);
+        if (org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(entity)) {
+            pitch = -pitch;
+        }
+        float f = pitch * (float) (Math.PI / 180.0);
+        float yaw;
+        if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule.placementRotationFix) {
+            yaw = entity.getViewYRot(1.0F);
+        }
+        else {
+            yaw = entity.getMainYaw(1.0F);
+        }
+        if (org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(entity))
+        {
+            yaw += 180f;
+        }
+        float g = -yaw * (float) (Math.PI / 180.0);
+        // Lumina end - Porting Carpet's features
         float h = Mth.sin(f);
         float i = Mth.cos(f);
         float j = Mth.sin(g);
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index d5e8dd947cb29343074df8074e791357c72e7f7b..950e0fdea581a37a48620a55e352a94828b06152 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -156,6 +156,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.setReadOnly();
         this.stopReadingPackets = true;
     }
+    // Lumina start - Porting Carpet's features
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+    // Lumina end - Porting Carpet's features
     // Paper end - packet limiter
     @Nullable public SocketAddress haProxyAddress; // Paper - Add API to get player's proxy address
 
@@ -264,6 +269,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     protected void channelRead0(ChannelHandlerContext channelhandlercontext, Packet<?> packet) {
+        org.leavesmc.lumina.carpet.logging.logHelpers.PacketCounter.totalIn++; // Lumina - Porting Carpet's features
         if (this.channel.isOpen()) {
             PacketListener packetlistener = this.packetListener;
 
@@ -509,6 +515,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks, boolean flush) {
+        org.leavesmc.lumina.carpet.logging.logHelpers.PacketCounter.totalOut++; // Lumina - Porting Carpet's features
         ++this.sentPackets;
         if (this.channel.eventLoop().inEventLoop()) {
             this.doSendPacket(packet, callbacks, flush);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 8056ddc2164789ac8efab4f5bf2069c4768f7657..06e8fd7d5fda88ff4b4ba1112e8457b2c94727f7 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -449,6 +449,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     protected abstract boolean initServer() throws IOException;
 
     protected void loadLevel(String s) { // CraftBukkit
+        org.leavesmc.lumina.carpet.CarpetServer.onServerLoaded(this); // Lumina - Porting Carpet's features - call onServerLoaded
         if (!JvmProfiler.INSTANCE.isRunning()) {
             ;
         }
@@ -469,7 +470,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 MinecraftServer.LOGGER.warn("Failed to stop JFR profiling", throwable);
             }
         }
-
+        org.leavesmc.lumina.carpet.CarpetServer.onServerLoadedWorlds(this); // Lumina - Porting Carpet's features - call onServerLoadedWorlds
     }
 
     protected void forceDifficulty() {}
@@ -998,6 +999,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Folia end - region threading
 
     public void stopServer() {
+        org.leavesmc.lumina.carpet.CarpetServer.onServerClosed(this); // Lumina - Porting Carpet's features - call onServerClosed
         // Folia start - region threading
         // halt scheduler
         // don't wait, we may be on a scheduler thread
diff --git a/src/main/java/net/minecraft/server/commands/CloneCommands.java b/src/main/java/net/minecraft/server/commands/CloneCommands.java
index 3c62d73f51a65a274f17e6a58f56cb841dbe8dc3..1496151fafc8dfd13663ad9500f1b865696a9a8d 100644
--- a/src/main/java/net/minecraft/server/commands/CloneCommands.java
+++ b/src/main/java/net/minecraft/server/commands/CloneCommands.java
@@ -321,7 +321,7 @@ public class CloneCommands {
                 }
 
                 for (CloneCommands.CloneBlockInfo cloneBlockInfo4 : list5) {
-                    serverLevel2.blockUpdated(cloneBlockInfo4.pos, cloneBlockInfo4.state.getBlock());
+                    if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.fillUpdates) serverLevel2.blockUpdated(cloneBlockInfo4.pos, cloneBlockInfo4.state.getBlock()); // Lumina - Porting Carpet's features - fill updates
                 }
 
                 serverLevel2.getBlockTicks().copyAreaFrom(serverLevel.getBlockTicks(), boundingBox, blockPos5);
diff --git a/src/main/java/net/minecraft/server/commands/FillCommand.java b/src/main/java/net/minecraft/server/commands/FillCommand.java
index 95bb9d341ff28d37934ceba4ef07c95211cf578a..8098f4517496ff37715adf512ed1850f7916517d 100644
--- a/src/main/java/net/minecraft/server/commands/FillCommand.java
+++ b/src/main/java/net/minecraft/server/commands/FillCommand.java
@@ -197,7 +197,7 @@ public class FillCommand {
 
             for (BlockPos blockPos2 : list) {
                 Block block2 = serverLevel.getBlockState(blockPos2).getBlock();
-                serverLevel.blockUpdated(blockPos2, block2);
+                if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.fillUpdates)  serverLevel.blockUpdated(blockPos2, block2); // Lumina - Porting Carpet's features - fill updates
             }
 
             if (k == 0) {
diff --git a/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java b/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
index 87275b46c4411fd51d6572ec7b3f924e347d4ed7..b80aaa9d503741d5d50b025912355dc52190872b 100644
--- a/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
+++ b/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
@@ -183,8 +183,10 @@ public class ForceLoadCommand {
             int o = SectionPos.blockToSectionCoord(k);
             int p = SectionPos.blockToSectionCoord(l);
             long q = ((long)(o - m) + 1L) * ((long)(p - n) + 1L);
-            if (q > 256L) {
-                throw ERROR_TOO_MANY_CHUNKS.create(256, q);
+            // Lumina start - Porting Carpet's features - forceload limit
+            if (q > (long)org.leavesmc.lumina.carpet.CarpetConfig.configModule.forceloadLimit) {
+                throw ERROR_TOO_MANY_CHUNKS.create(org.leavesmc.lumina.carpet.CarpetConfig.configModule.forceloadLimit, q);
+                // Lumina end - Porting Carpet's features - forceload limit
             } else {
                 ServerLevel serverLevel = source.getLevel();
                 ResourceKey<Level> resourceKey = serverLevel.dimension();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 25aadc085d6af9f6c619bd2f5347180989514441..bed1a0366daa4467ce54b3e67ffd804503cbabee 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -282,6 +282,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         }
 
+        org.leavesmc.lumina.carpet.CarpetServer.onGameStarted(); // Lumina - Porting Carpet's features
         // Lumina start - enable CommandAPI
         commandAPIPlugin = org.bukkit.plugin.java.CommandAPIPluginFactory.create();
         dev.jorel.commandapi.CommandAPI.onLoad(new dev.jorel.commandapi.CommandAPIBukkitConfig(commandAPIPlugin)
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index dfdb85c14c4afce7879acf9093d54f7480c0a08c..92c3f9bdc6e97614ea664bee46616fb73587a7d4 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -962,6 +962,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private boolean skipPlayer(ServerPlayer player) {
+        if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule.creativePlayersLoadChunks && player.isCreative()) return true; // Lumina - Porting Carpet's features - creative players load chunks
         return player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
     }
 
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 8c42c1f0d67f437423bf6d3958c6409f44556d5c..b60b67cd386a40f04ac4759f2806ab0416d2c284 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -44,6 +44,37 @@ public abstract class DistanceManager {
     }
     // Paper end - rewrite chunk system
 
+    // Lumina start - Porting Carpet's features - spawn chunks
+    public void changeSpawnChunks(ChunkPos chunkPos,  int distance)
+    {
+        long pos = chunkPos.toLong();
+        SortedArraySet<Ticket<?>> set = this.getChunkHolderManager().getTicketsCopy().get(pos);
+        Ticket<?> existingTicket = null;
+        if (set != null)
+        {
+            Iterator<Ticket<?>> iter = set.iterator();
+            while(iter.hasNext())
+            {
+                Ticket<?> ticket = iter.next();
+                if (ticket.getType() == TicketType.START)
+                {
+                    existingTicket = ticket;
+                    iter.remove();
+                }
+            }
+            set.add(existingTicket);
+        }
+        // the reason we are removing the ticket this way is that there are sideeffects of removal
+        if (existingTicket != null)
+        {
+            removeTicket(pos, existingTicket);
+        }
+        // set optionally new spawn ticket
+        if (distance > 0)
+            addRegionTicket(TicketType.START, chunkPos, distance, net.minecraft.util.Unit.INSTANCE);
+    }
+    // Lumina end - Porting Carpet's features - spawn chunks
+
     static final Logger LOGGER = LogUtils.getLogger();
     static final int PLAYER_TICKET_LEVEL = ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING);
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 3c95ea6fdab99e414270fd5ed960c539b7ada265..f9cde77604a6e68560698e3c7d3ffe5b03d786ed 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -299,6 +299,19 @@ public class ServerPlayer extends Player {
     public @Nullable String clientBrandName = null; // Paper - Brand support
     public org.bukkit.event.player.PlayerQuitEvent.QuitReason quitReason = null; // Paper - Add API for quit reason; there are a lot of changes to do if we change all methods leading to the event
 
+    // Lumina start - Porting Carpet's features
+    private boolean isInvalidReference = false;
+    public org.leavesmc.lumina.carpet.helpers.EntityPlayerActionPack actionPack;
+    public org.leavesmc.lumina.carpet.helpers.EntityPlayerActionPack getActionPack() {
+        return actionPack;
+    }
+    public void invalidateEntityObjectReference() {
+        isInvalidReference = true;
+    }
+    public boolean isInvalidEntityObject() {
+        return isInvalidReference;
+    }
+    // Lumina end - Porting Carpet's features
     // Paper start - replace player chunk loader
     private final java.util.concurrent.atomic.AtomicReference<io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.ViewDistances> viewDistances = new java.util.concurrent.atomic.AtomicReference<>(new io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.ViewDistances(-1, -1, -1));
     public io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.PlayerChunkLoaderData chunkLoader;
@@ -450,6 +463,7 @@ public class ServerPlayer extends Player {
         this.adventure$displayName = net.kyori.adventure.text.Component.text(this.getScoreboardName()); // Paper
         this.bukkitPickUpLoot = true;
         this.maxHealthCache = this.getMaxHealth();
+        this.actionPack = new org.leavesmc.lumina.carpet.helpers.EntityPlayerActionPack(this); // Lumina - Porting Carpet's features
     }
 
     // Use method to resend items in hands in case of client desync, because the item use got cancelled.
@@ -872,6 +886,7 @@ public class ServerPlayer extends Player {
 
     @Override
     public void tick() {
+        actionPack.onUpdate(); // Lumina - Porting Carpet's features
         // CraftBukkit start
         if (this.joining) {
             this.joining = false;
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index bbb856fb9b4082d752a6761bb5196fffa48fbd6c..3f9785e1af4c96a1ae3de8ff80a7bd366473e0f6 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -119,6 +119,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     }
     public void onDisconnect(Component reason, @Nullable net.kyori.adventure.text.Component quitMessage) {
         // Paper end - Fix kick event leave message not being sent
+        org.leavesmc.lumina.carpet.CarpetServer.onPlayerLoggedOut(this.player, quitMessage); // Lumina - Porting Carpet's features
         // Folia start - region threading
         if (this.handledDisconnect) {
             // avoid retiring scheduler twice
@@ -134,6 +135,12 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
 
     }
 
+    // Lumina start - Porting Carpet's features
+    public Connection getConnection() {
+        return connection;
+    }
+    // Lumina end - Porting Carpet's features
+
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
         // Purpur start
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 7ddb7d5aa1047eb8151aef01d5db694d2683cf51..d7ec9b92c74abcf9ba9da828ba1961c7c2d6ed3f 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -3460,7 +3460,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             }
 
             boolean flag1 = packet.slotNum() >= 1 && packet.slotNum() <= 45;
-            boolean flag2 = itemstack.isEmpty() || itemstack.getCount() <= itemstack.getMaxStackSize();
+            boolean flag2 = itemstack.isEmpty() || itemstack.getCount() <= org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack); // Leaves - stackable shulker boxes
             if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.slotNum()).getItem(), packet.itemStack()))) { // Insist on valid slot
                 // CraftBukkit start - Call click event
                 InventoryView inventory = this.player.inventoryMenu.getBukkitView();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index b00e254fd059dcf5b9246b1d6171bf6d1ead8254..0b7a7f739bde72fd20a8d92f3c8fe5c75c325bb8 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -375,7 +375,11 @@ public abstract class PlayerList {
         LevelData worlddata = worldserver1.getLevelData();
 
         player.loadGameTypes((CompoundTag) optional.orElse(null)); // CraftBukkit - decompile error
-        ServerGamePacketListenerImpl playerconnection = new ServerGamePacketListenerImpl(this.server, connection, player, clientData);
+        // Lumina start - Porting Carpet's features
+        ServerGamePacketListenerImpl playerconnection;
+        if (player instanceof org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake fake) playerconnection = new org.leavesmc.lumina.carpet.patches.NetHandlerPlayServerFake(this.server, connection, fake, clientData);
+        else playerconnection = new ServerGamePacketListenerImpl(this.server, connection, player, clientData);
+        // Lumina end - Porting Carpet's features
         // Folia start - rewrite login process
         // only after setting the connection listener to game type, add the connection to this regions list
         worldserver1.getCurrentWorldData().connections.add(connection);
@@ -668,6 +672,7 @@ public abstract class PlayerList {
         } else {
             optional = this.playerIo.load(player);
         }
+        if (player instanceof org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake) ((org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake) player).fixStartingPosition.run(); // Lumina - Porting Carpet's features
 
         return optional;
     }
diff --git a/src/main/java/net/minecraft/world/Container.java b/src/main/java/net/minecraft/world/Container.java
index 541cb29a10e2c87a8214ff5beadb71bc1922d353..add96448c9b9b722aba20bfecb3c107d06fc9398 100644
--- a/src/main/java/net/minecraft/world/Container.java
+++ b/src/main/java/net/minecraft/world/Container.java
@@ -94,6 +94,12 @@ public interface Container extends Clearable {
         return Math.min(this.getMaxStackSize(), stack.getMaxStackSize());
     }
 
+    // Leaves start - stackable shulker boxes
+    default int getMaxStackLeaves(ItemStack stack) {
+        return Math.min(this.getMaxStackSize(), org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack));
+    }
+    // Leaves end - stackable shulker boxes
+
     void setChanged();
 
     boolean stillValid(Player player);
diff --git a/src/main/java/net/minecraft/world/SimpleContainer.java b/src/main/java/net/minecraft/world/SimpleContainer.java
index d04bf7d06855022c973073fb84c5d3d65f2553e1..9bedd76330e71ca7f3feecf0b90ec960c35d1a6f 100644
--- a/src/main/java/net/minecraft/world/SimpleContainer.java
+++ b/src/main/java/net/minecraft/world/SimpleContainer.java
@@ -222,7 +222,7 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
     @Override
     public void setItem(int slot, ItemStack stack) {
         this.items.set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack));
         this.setChanged();
     }
 
@@ -318,7 +318,7 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
     }
 
     private void moveItemsBetweenStacks(ItemStack source, ItemStack target) {
-        int i = this.getMaxStackSize(target);
+        int i = this.getMaxStackLeaves(target); // Leaves - stackable shulker boxes
         int j = Math.min(source.getCount(), i - target.getCount());
 
         if (j > 0) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index c17f8b0d8fe362a5a0255c5f639f2b6eb077f0f9..38c6403c780e276910cb0c30cb12b066249be81e 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -171,6 +171,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
     }
 
+    // Lumina start - Porting Carpet's features
+    public float getMainYaw(float partialTicks) {
+        return partialTicks == 1.0F ? this.yRot : Mth.lerp(partialTicks, this.yRotO, this.yRot);
+    }
+    // Lumina end - Porting Carpet's features
+
     // Paper start - Share random for entities to make them more random
     public static RandomSource SHARED_RANDOM = new RandomRandomSource();
     public static final class RandomRandomSource extends java.util.Random implements net.minecraft.world.level.levelgen.BitRandomSource { // Folia - region threading
@@ -5278,6 +5284,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public boolean isControlledByLocalInstance() {
+        if (getControllingPassenger() instanceof org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake) return !level.isClientSide; // Lumina - Porting Carpet's features
         net.minecraft.world.entity.LivingEntity entityliving = this.getControllingPassenger();
 
         if (entityliving instanceof Player entityhuman) {
diff --git a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
index 46d8bcad1545953757659870901cbbdf3340bc15..f6b06369fd420e487496a84304fa3c70530aa2ac 100644
--- a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
+++ b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
@@ -324,6 +324,19 @@ public class ExperienceOrb extends Entity {
 
     @Override
     public void playerTouch(Player player) {
+        // Lumina start - Porting Carpet's features - xp no cooldown
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.xpNoCooldown && !level().isClientSide) {
+            player.takeXpDelay = 0;
+            // reducing the count to 1 and leaving vanilla to deal with it
+            while (this.count > 1) {
+                int remainder = this.repairPlayerItems(player, this.value);
+                if (remainder > 0) {
+                    player.giveExperiencePoints(remainder);
+                }
+                this.count--;
+            }
+        }
+        // Lumina end - Porting Carpet's features - xp no cooldown
         if (!this.level().isClientSide) {
             if (player.takeXpDelay == 0 && new com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent(((net.minecraft.server.level.ServerPlayer) player).getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) this.getBukkitEntity()).callEvent()) { // Paper - PlayerPickupExperienceEvent
                 player.takeXpDelay = CraftEventFactory.callPlayerXpCooldownEvent(player, 2, PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entityhuman.takeXpDelay = 2;
diff --git a/src/main/java/net/minecraft/world/entity/MobCategory.java b/src/main/java/net/minecraft/world/entity/MobCategory.java
index c9482fc669cb7326d4a22467e6fcb5e6b4747e9d..510017d57f4f6fecf85212994400022f06a1bf5d 100644
--- a/src/main/java/net/minecraft/world/entity/MobCategory.java
+++ b/src/main/java/net/minecraft/world/entity/MobCategory.java
@@ -39,7 +39,7 @@ public enum MobCategory implements StringRepresentable {
     }
 
     public int getMaxInstancesPerChunk() {
-        return this.max;
+        return ((int) ((double)max*(Math.pow(2.0,(org.leavesmc.lumina.carpet.utils.SpawnReporter.mobcap_exponent/4))))); // Lumina - Porting Carpet's features - mob spawn
     }
 
     public boolean isFriendly() {
diff --git a/src/main/java/net/minecraft/world/entity/SpawnPlacements.java b/src/main/java/net/minecraft/world/entity/SpawnPlacements.java
index e68e464a42096e6c048c81765f85d5e9f4581c6d..8b7081b54b1374a28ae968cfd05fdaae561bc638 100644
--- a/src/main/java/net/minecraft/world/entity/SpawnPlacements.java
+++ b/src/main/java/net/minecraft/world/entity/SpawnPlacements.java
@@ -56,6 +56,11 @@ public class SpawnPlacements {
     }
 
     public static SpawnPlacementType getPlacementType(EntityType<?> type) {
+        // Lumina start - Porting Carpet's features - piglins spawning in bastions
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.piglinsSpawningInBastions && type == EntityType.PIGLIN_BRUTE) {
+             return SpawnPlacementTypes.ON_GROUND;
+        }
+        // Lumina end - Porting Carpet's features - piglins spawning in bastions
         SpawnPlacements.Data data = DATA_BY_TYPE.get(type);
         return data == null ? SpawnPlacementTypes.NO_RESTRICTIONS : data.placement;
     }
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index 7873462c6146b7431011a2b73eb7414f61afbccf..9f7e74ea6b4cc7b8bae8f8170d8064e2ffdfd5b1 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -114,7 +114,17 @@ public abstract class PathNavigation {
     }
     @Nullable
     public Path createPath(BlockPos target, @Nullable Entity entity, int distance) {
-        return this.createPath(ImmutableSet.of(target), entity, 8, false, distance);
+        // Lumina start - Porting Carpet's features - log pathfinding
+        if (!org.leavesmc.lumina.carpet.logging.LoggerRegistry.__pathfinding)
+            return this.createPath(ImmutableSet.of(target), entity, 8, false, distance);
+        Set<BlockPos> set_1 = ImmutableSet.of(target);
+        long start = System.nanoTime();
+        Path path = createPath(set_1, entity, 8, false, distance);
+        long finish = System.nanoTime();
+        float duration = (1.0F*((finish - start)/1000))/1000;
+        set_1.forEach(b -> org.leavesmc.lumina.carpet.logging.logHelpers.PathfindingVisualizer.slowPath(mob, Vec3.atBottomCenterOf(b), duration, path != null)); // ground centered position
+        return path;
+        // Lumina end - Porting Carpet's features - log pathfinding
         // Paper end - EntityPathfindEvent
     }
 
@@ -125,7 +135,17 @@ public abstract class PathNavigation {
 
     @Nullable
     public Path createPath(Entity entity, int distance) {
-        return this.createPath(ImmutableSet.of(entity.blockPosition()), entity, 16, true, distance); // Paper - EntityPathfindEvent
+        // Lumina start - Porting Carpet's features - log pathfinding
+        if (!org.leavesmc.lumina.carpet.logging.LoggerRegistry.__pathfinding)
+            return this.createPath(ImmutableSet.of(entity.blockPosition()), entity, 16, true, distance); // Paper - EntityPathfindEvent
+        Set<BlockPos> set_1 = ImmutableSet.of(entity.blockPosition());
+        long start = System.nanoTime();
+        Path path = createPath(set_1, entity, 16, true, distance);
+        long finish = System.nanoTime();
+        float duration = (1.0F*((finish - start)/1000))/1000;
+        set_1.forEach(b -> org.leavesmc.lumina.carpet.logging.logHelpers.PathfindingVisualizer.slowPath(mob, Vec3.atBottomCenterOf(b), duration, path != null));
+        return path;
+        // Lumina end - Porting Carpet's features - log pathfinding
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index d504d10fbe45dfe3f2f3d08d2473df6cd18f6dcf..2aeacaca3c1f62e067fef9c82e9f261c3d921330 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -55,7 +55,7 @@ import org.bukkit.event.entity.EntityRemoveEvent;
 // CraftBukkit end
 
 public class FallingBlockEntity extends Entity {
-
+    private org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper logHelper; // Lumina - Porting Carpet's features
     private static final Logger LOGGER = LogUtils.getLogger();
     public BlockState blockState;
     public int time;
@@ -74,6 +74,10 @@ public class FallingBlockEntity extends Entity {
         this.blockState = Blocks.SAND.defaultBlockState();
         this.dropItem = true;
         this.fallDamageMax = 40;
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__fallingBlocks && !world.isClientSide)
+            logHelper = new org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper("fallingBlocks");
+        // Lumina end - Porting Carpet's features
     }
 
     public FallingBlockEntity(Level world, double x, double y, double z, BlockState block) {
@@ -136,8 +140,20 @@ public class FallingBlockEntity extends Entity {
         return 0.04D;
     }
 
+    // Lumina start - Porting Carpet's features
+    public void remove(Entity.RemovalReason arg) {
+        super.remove(arg);
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__fallingBlocks && logHelper != null)
+            logHelper.onFinish();
+    }
+    // Lumina end - Porting Carpet's features
+
     @Override
     public void tick() {
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__fallingBlocks && logHelper != null)
+            logHelper.onTick(getX(), getY(), getZ(), getDeltaMovement());
+        // Lumina end - Porting Carpet's features
         if (this.blockState.isAir()) {
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index 4b59206a342e7fc4174439df6842d0c677be2c4c..3903231d448575f8fed4365c6c0371a04745faf2 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -22,10 +22,12 @@ import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.entity.SlotAccess;
 import net.minecraft.world.entity.TraceableEntity;
+import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
@@ -35,6 +37,7 @@ import net.minecraft.sounds.SoundSource;
 import net.minecraft.stats.Stats;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.Player;
+import org.bukkit.block.ShulkerBox;
 import org.bukkit.event.entity.EntityPickupItemEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerPickupItemEvent;
@@ -96,6 +99,22 @@ public class ItemEntity extends Entity implements TraceableEntity {
         this.bobOffs = entity.bobOffs;
     }
 
+    // Lumina start - Porting Carpet's features - lighting kills items
+    public void thunderHit(ServerLevel world, net.minecraft.world.entity.LightningBolt lightning) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.lightningKillsDropsFix) {
+            if (this.age > 8) { //Only kill item if it's older than 8 ticks
+                super.thunderHit(world, lightning);
+            }
+        } else {
+            super.thunderHit(world, lightning);
+        }
+    }
+
+    public int getPickupDelayCM() {
+        return this.pickupDelay;
+    }
+    // Lumina end - Porting Carpet's features - lighting kills items
+
     @Override
     public boolean dampensVibrations() {
         return this.getItem().is(ItemTags.DAMPENS_VIBRATIONS);
@@ -313,10 +332,49 @@ public class ItemEntity extends Entity implements TraceableEntity {
     private boolean isMergable() {
         ItemStack itemstack = this.getItem();
 
-        return this.isAlive() && this.pickupDelay != 32767 && this.age != -32768 && this.age < this.despawnRate && itemstack.getCount() < itemstack.getMaxStackSize(); // Paper - Alternative item-despawn-rate
+        return this.isAlive() && this.pickupDelay != 32767 && this.age != -32768 && this.age < this.despawnRate && itemstack.getCount() < org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack); // Paper - Alternative item-despawn-rate // Leaves - stackable shulker boxes
+    }
+
+    // Leaves end - stackable shulker boxes
+    private boolean tryStackShulkerBoxes(ItemEntity other) {
+        ItemStack selfStack = this.getItem();
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.shulkerBoxStackSize == 1 || !(selfStack.getItem() instanceof BlockItem bi) || !(bi.getBlock() instanceof ShulkerBoxBlock)) {
+            return false;
+        }
+
+        ItemStack otherStack = other.getItem();
+        if (selfStack.getItem() == otherStack.getItem()
+            && org.leavesmc.leaves.util.ShulkerBoxUtils.shulkerBoxNoItem(selfStack)
+            && org.leavesmc.leaves.util.ShulkerBoxUtils.shulkerBoxNoItem(otherStack)
+            && Objects.equals(selfStack.getComponents(), otherStack.getComponents()) // empty block entity tags are cleaned up when spawning
+            && selfStack.getCount() != org.leavesmc.lumina.carpet.CarpetConfig.configModule.shulkerBoxStackSize) {
+            int amount = Math.min(otherStack.getCount(), org.leavesmc.lumina.carpet.CarpetConfig.configModule.shulkerBoxStackSize - selfStack.getCount());
+
+            selfStack.grow(amount);
+            this.setItem(selfStack);
+
+            this.pickupDelay = Math.max(other.pickupDelay, this.pickupDelay);
+            this.age = Math.min(other.getAge(), this.age);
+
+            otherStack.shrink(amount);
+            if (otherStack.isEmpty()) {
+                other.discard();
+            }
+            else {
+                other.setItem(otherStack);
+            }
+            return true;
+        }
+        return false;
     }
+    // Leaves end - stackable shulker boxes
 
     private void tryToMerge(ItemEntity other) {
+        // Leaves start - stackable shulker boxes
+        if (tryStackShulkerBoxes(other)) {
+            return;
+        }
+        // Leaves end - stackable shulker boxes
         ItemStack itemstack = this.getItem();
         ItemStack itemstack1 = other.getItem();
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Guardian.java b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
index 6c2e2fd5826a5f8070502e20d1d140c3d70bd0d3..b516fe2e53bb90837879964e81846e4abf172e84 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Guardian.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
@@ -70,6 +70,28 @@ public class Guardian extends Monster {
         this.clientSideTailAnimationO = this.clientSideTailAnimation;
     }
 
+    // Lumina start - Porting Carpet's features reneweable sponges
+    public void thunderHit(net.minecraft.server.level.ServerLevel serverWorld, net.minecraft.world.entity.LightningBolt lightningEntity) {
+        if (!this.level().isClientSide && !this.isRemoved() && org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableSponges && !((Object)this instanceof ElderGuardian)) {
+            ElderGuardian elderGuardian = new ElderGuardian(EntityType.ELDER_GUARDIAN ,this.level());
+            elderGuardian.moveTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
+            elderGuardian.finalizeSpawn(serverWorld ,this.level().getCurrentDifficultyAt(elderGuardian.blockPosition()), MobSpawnType.CONVERSION, null);
+            elderGuardian.setNoAi(this.isNoAi());
+
+            if (this.hasCustomName()) {
+                elderGuardian.setCustomName(this.getCustomName());
+                elderGuardian.setCustomNameVisible(this.isCustomNameVisible());
+            }
+
+            this.level().addFreshEntity(elderGuardian);
+            this.discard(); // discard remove();
+        }
+        else {
+            super.thunderHit(serverWorld, lightningEntity);
+        }
+    }
+    // Lumina end - Porting Carpet's features reneweable sponges
+
     @Override
     protected void registerGoals() {
         MoveTowardsRestrictionGoal pathfindergoalmovetowardsrestriction = new MoveTowardsRestrictionGoal(this, 1.0D);
diff --git a/src/main/java/net/minecraft/world/entity/monster/Husk.java b/src/main/java/net/minecraft/world/entity/monster/Husk.java
index c34c8483a026f61fe20935697d321d7ef5d8dfbc..25530549ac1c496835a51f24cf8c04710c062112 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Husk.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Husk.java
@@ -23,7 +23,7 @@ public class Husk extends Zombie {
     }
 
     public static boolean checkHuskSpawnRules(EntityType<Husk> type, ServerLevelAccessor world, MobSpawnType spawnReason, BlockPos pos, RandomSource random) {
-        return checkMonsterSpawnRules(type, world, spawnReason, pos, random) && (MobSpawnType.isSpawner(spawnReason) || world.canSeeSky(pos));
+        return checkMonsterSpawnRules(type, world, spawnReason, pos, random) && (MobSpawnType.isSpawner(spawnReason) || world.canSeeSky(pos) || (org.leavesmc.lumina.carpet.CarpetConfig.configModule.huskSpawningInTemples && org.leavesmc.lumina.carpet.utils.SpawnOverrides.isStructureAtPosition((net.minecraft.server.level.ServerLevel)world, net.minecraft.world.level.levelgen.structure.BuiltinStructures.DESERT_PYRAMID, pos))); // Lumina - Porting Carpet's features - husks spawning in desert temples
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index ca7fbe4f8c1e1d2fb90095aa35be4dda3029c23e..d1378c5be891e41b9d43765b2d307e0e5e95f013 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -111,7 +111,7 @@ public class Inventory implements Container, Nameable {
     }
 
     private boolean hasRemainingSpaceForItem(ItemStack existingStack, ItemStack stack) {
-        return !existingStack.isEmpty() && existingStack.isStackable() && existingStack.getCount() < this.getMaxStackSize(existingStack) && ItemStack.isSameItemSameComponents(existingStack, stack); // Paper - check if itemstack is stackable first
+        return !existingStack.isEmpty() && org.leavesmc.leaves.util.ShulkerBoxUtils.isStackable(existingStack) && existingStack.getCount() < org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(existingStack) && ItemStack.isSameItemSameComponents(existingStack, stack); // Paper - check if itemstack is stackable first
     }
 
     // CraftBukkit start - Watch method above! :D
@@ -279,7 +279,9 @@ public class Inventory implements Container, Nameable {
             this.setItem(slot, itemstack1);
         }
 
-        int k = this.getMaxStackSize(itemstack1) - itemstack1.getCount();
+        // Leaves start - stackable shulker boxes
+        int k = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1) - itemstack1.getCount();
+        // Leaves end - stackable shulker boxes
         int l = Math.min(j, k);
 
         if (l == 0) {
@@ -394,7 +396,7 @@ public class Inventory implements Container, Nameable {
                 }
 
                 if (i != -1) {
-                    int j = stack.getMaxStackSize() - this.getItem(i).getCount();
+                    int j = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack) - this.getItem(i).getCount(); // Leaves - stackable shulker boxes
 
                     if (this.add(i, stack.split(j)) && notifiesClient && this.player instanceof ServerPlayer) {
                         ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetSlotPacket(-2, 0, i, this.getItem(i)));
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index b0f2e614c90137c526de865bd64469f09b95c964..4120da2d83249e40054a293dce3e30c7390de6a6 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -251,7 +251,8 @@ public abstract class Player extends LivingEntity {
     @Override
     public void tick() {
         this.noPhysics = this.isSpectator();
-        if (this.isSpectator()) {
+        this.noPhysics = this.isCreativeFlyOrSpectator(); // Lumina - creative no clip
+        if (this.isCreativeFlyOrSpectator()) { // Lumina - creative no clip
             this.setOnGround(false);
         }
 
@@ -430,7 +431,7 @@ public abstract class Player extends LivingEntity {
 
             Pose entitypose1;
 
-            if (!this.isSpectator() && !this.isPassenger() && !this.canPlayerFitWithinBlocksAndEntitiesWhen(entitypose)) {
+            if (!this.isCreativeFlyOrSpectator() && !this.isPassenger() && !this.canPlayerFitWithinBlocksAndEntitiesWhen(entitypose)) { // Lumina - creative no clip
                 if (this.canPlayerFitWithinBlocksAndEntitiesWhen(Pose.CROUCHING)) {
                     entitypose1 = Pose.CROUCHING;
                 } else {
@@ -577,7 +578,7 @@ public abstract class Player extends LivingEntity {
         }
 
         this.bob += (f - this.bob) * 0.4F;
-        if (this.getHealth() > 0.0F && !this.isSpectator()) {
+        if (this.getHealth() > 0.0F && !this.isCreativeFlyOrSpectator()) { // Lumina - creative no clip
             AABB axisalignedbb;
 
             if (this.isPassenger() && !this.getVehicle().isRemoved()) {
@@ -629,6 +630,20 @@ public abstract class Player extends LivingEntity {
         }
 
     }
+    // Leaves start - creative no clip
+    public boolean isCreativeFlyOrSpectator() {
+        return isSpectator() || (org.leavesmc.lumina.carpet.CarpetConfig.configModule.creativeNoClip && isCreative() && getAbilities().flying);
+    }
+
+    public boolean canSpectatingPlace(Level world, BlockState state, BlockPos pos, net.minecraft.world.phys.shapes.CollisionContext context) {
+        if (this.isCreativeFlyOrSpectator()) {
+            net.minecraft.world.phys.shapes.VoxelShape voxelShape = state.getCollisionShape(world, pos, context);
+            return voxelShape.isEmpty() || world.isUnobstructed(this, voxelShape.move(pos.getX(), pos.getY(), pos.getZ()));
+        } else {
+            return world.isUnobstructed(state, pos, context);
+        }
+    }
+    // Leaves end - creative no clip
 
     private void touch(Entity entity) {
         entity.playerTouch(this);
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index fe92fffd7cab267024af18d010345d9b67c62045..6dd085b7d53de14e8cb1a85bcaf00dc0103012a0 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -55,7 +55,7 @@ import org.bukkit.event.player.PlayerPickupArrowEvent;
 // CraftBukkit end
 
 public abstract class AbstractArrow extends Projectile {
-
+    private org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper logHelper; // Lumina - Porting Carpet's features
     private static final double ARROW_BASE_DAMAGE = 2.0D;
     private static final EntityDataAccessor<Byte> ID_FLAGS = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
     private static final EntityDataAccessor<Byte> PIERCE_LEVEL = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
@@ -107,7 +107,11 @@ public abstract class AbstractArrow extends Projectile {
         if (unit != null) {
             this.pickup = AbstractArrow.Pickup.CREATIVE_ONLY;
         }
-
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && !level.isClientSide) {
+            logHelper = new org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper("projectiles");
+        }
+        // Lumina end - Porting Carpet's features
     }
 
     protected AbstractArrow(EntityType<? extends AbstractArrow> type, double x, double y, double z, Level world, ItemStack stack) {
@@ -119,6 +123,7 @@ public abstract class AbstractArrow extends Projectile {
         this(type, owner.getX(), owner.getEyeY() - 0.10000000149011612D, owner.getZ(), world, stack);
         this.setOwner(owner);
     }
+    public AbstractArrow(EntityType<? extends Projectile> entityType_1, Level world_1) { super(entityType_1, world_1); } // Lumina - Porting Carpet's features
 
     public void setSoundEvent(SoundEvent sound) {
         this.soundEvent = sound;
@@ -162,6 +167,11 @@ public abstract class AbstractArrow extends Projectile {
 
     @Override
     public void tick() {
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+            logHelper.onTick(getX(), getY(), getZ(), getDeltaMovement());
+        }
+        // Lumina end - Porting Carpet's features
         super.tick();
         // Folia start - region threading - make sure entities do not move into regions they do not own
         if (!io.papermc.paper.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
@@ -386,6 +396,12 @@ public abstract class AbstractArrow extends Projectile {
 
             if (this.piercingIgnoreEntityIds.size() >= this.getPierceLevel() + 1) {
                 this.discard(EntityRemoveEvent.Cause.HIT); // CraftBukkit - add Bukkit remove cause
+                // Lumina start - Porting Carpet's features
+                if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+                    logHelper.onFinish();
+                    logHelper = null;
+                }
+                // Lumina end - Porting Carpet's features
                 return;
             }
 
@@ -426,6 +442,12 @@ public abstract class AbstractArrow extends Projectile {
 
         if (entity.hurt(damagesource, (float) i)) {
             if (flag) {
+                // Lumina start - Porting Carpet's features
+                if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+                    logHelper.onFinish();
+                    logHelper = null;
+                }
+                // Lumina end - Porting Carpet's features
                 return;
             }
 
@@ -486,7 +508,12 @@ public abstract class AbstractArrow extends Projectile {
                 this.discard(EntityRemoveEvent.Cause.HIT); // CraftBukkit - add Bukkit remove cause
             }
         }
-
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+            logHelper.onFinish();
+            logHelper = null;
+        }
+        // Lumina end - Porting Carpet's features
     }
 
     @Override
@@ -507,6 +534,12 @@ public abstract class AbstractArrow extends Projectile {
         this.setSoundEvent(SoundEvents.ARROW_HIT);
         this.setShotFromCrossbow(false);
         this.resetPiercedEntities();
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+            logHelper.onFinish();
+            logHelper = null;
+        }
+        // Lumina end - Porting Carpet's features
     }
 
     protected SoundEvent getDefaultHitGroundSoundEvent() {
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java b/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
index 845eff7401b811c179dc9dee70eca0d724be5c80..c88b98bd4ebec40649b9cfcf47ca20359ea2fb52 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
@@ -162,7 +162,7 @@ public interface ContainerEntity extends Container, MenuProvider {
     default void setChestVehicleItem(int slot, ItemStack stack) {
         this.unpackChestVehicleLootTable(null);
         this.getItemStacks().set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
     }
 
     default SlotAccess getChestVehicleSlot(int slot) {
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index 32910f677b0522ac8ec513fa0d00b714b52cfae4..301012227e15725b5cb9fb54ff11d14f2535b0d6 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -399,6 +399,26 @@ public abstract class AbstractContainerMenu {
     }
 
     private void doClick(int slotIndex, int button, ClickType actionType, Player player) {
+        // Lumina start - Porting Carpet's features - ctrlQ crafting fix
+        if (actionType == ClickType.THROW && org.leavesmc.lumina.carpet.CarpetConfig.configModule.ctrlQCraftingFix && this.getCarried().isEmpty() && slotIndex >= 0)
+        {
+            Slot slot_4 = slots.get(slotIndex);
+            if (/*slot_4 != null && */slot_4.hasItem() && slot_4.mayPickup(player))
+            {
+                if(slotIndex == 0 && button == 1)
+                {
+                    net.minecraft.world.item.Item craftedItem = slot_4.getItem().getItem();
+                    while(slot_4.hasItem() && slot_4.getItem().getItem() == craftedItem)
+                    {
+                        this.clicked(slotIndex, 0, ClickType.THROW, player);
+                    }
+                    this.broadcastChanges();
+                    this.resetQuickCraft();
+                    return;
+                }
+            }
+        }
+        // Lumina end - Porting Carpet's features - ctrlQ crafting fix
         Inventory playerinventory = player.getInventory();
         Slot slot;
         ItemStack itemstack;
@@ -454,7 +474,7 @@ public abstract class AbstractContainerMenu {
 
                         if (slot1 != null && AbstractContainerMenu.canItemQuickReplace(slot1, itemstack2, true) && slot1.mayPlace(itemstack2) && (this.quickcraftType == 2 || itemstack2.getCount() >= this.quickcraftSlots.size()) && this.canDragTo(slot1)) {
                             int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
-                            int k1 = Math.min(itemstack1.getMaxStackSize(), slot1.getMaxStackSize(itemstack1));
+                            int k1 = Math.min(org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1), slot1.getMaxStackSize(itemstack1)); // Leaves - stackable shulker boxes                            int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
                             int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
 
                             l -= l1 - j1;
@@ -573,7 +593,7 @@ public abstract class AbstractContainerMenu {
                                     slot.setByPlayer(itemstack3);
                                 }
                             } else if (ItemStack.isSameItemSameComponents(itemstack, itemstack3)) {
-                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), itemstack3.getMaxStackSize() - itemstack3.getCount(), player);
+                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack3) - itemstack3.getCount(), player);
 
                                 optional1.ifPresent((itemstack4) -> {
                                     itemstack3.grow(itemstack4.getCount());
@@ -643,7 +663,7 @@ public abstract class AbstractContainerMenu {
                         slot2 = (Slot) this.slots.get(slotIndex);
                         if (slot2.hasItem()) {
                             itemstack1 = slot2.getItem();
-                            this.setCarried(itemstack1.copyWithCount(itemstack1.getMaxStackSize()));
+                            this.setCarried(itemstack1.copyWithCount(org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1))); // Leaves - stackable shulker boxes
                         }
                     } else if (actionType == ClickType.THROW && this.getCarried().isEmpty() && slotIndex >= 0) {
                         slot2 = (Slot) this.slots.get(slotIndex);
@@ -658,13 +678,13 @@ public abstract class AbstractContainerMenu {
                             j2 = button == 0 ? 1 : -1;
 
                             for (i2 = 0; i2 < 2; ++i2) {
-                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < itemstack1.getMaxStackSize(); k2 += j2) {
+                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); k2 += j2) { // Leaves - stackable shulker boxes
                                     Slot slot3 = (Slot) this.slots.get(k2);
 
                                     if (slot3.hasItem() && AbstractContainerMenu.canItemQuickReplace(slot3, itemstack1, true) && slot3.mayPickup(player) && this.canTakeItemForPickAll(itemstack1, slot3)) {
                                         ItemStack itemstack5 = slot3.getItem();
 
-                                        if (i2 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
+                                        if (i2 != 0 || itemstack5.getCount() != org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack5)) {
                                             ItemStack itemstack6 = slot3.safeTake(itemstack5.getCount(), itemstack1.getMaxStackSize() - itemstack1.getCount(), player);
 
                                             itemstack1.grow(itemstack6.getCount());
@@ -787,7 +807,7 @@ public abstract class AbstractContainerMenu {
         ItemStack itemstack1;
         int l;
 
-        if (stack.isStackable()) {
+        if (org.leavesmc.leaves.util.ShulkerBoxUtils.isStackable(stack)) { // Leaves - stackable shulker boxes
             while (!stack.isEmpty()) {
                 if (fromLast) {
                     if (k < startIndex) {
@@ -806,6 +826,7 @@ public abstract class AbstractContainerMenu {
                 // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (!itemstack1.isEmpty() && ItemStack.isSameItemSameComponents(stack, itemstack1)) {
                     l = itemstack1.getCount() + stack.getCount();
+                    // int i1 = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); // Leaves - stackable shulker boxes // disabled temporarily
                     int i1 = slot.getMaxStackSize(itemstack1);
 
                     if (l <= i1) {
@@ -857,6 +878,7 @@ public abstract class AbstractContainerMenu {
                 }
                 // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (itemstack1.isEmpty() && slot.mayPlace(stack)) {
+                    // l = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); // Leaves - stackable shulker boxes // disabled temporarily
                     l = slot.getMaxStackSize(stack);
                     // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent
                     if (isCheck) {
diff --git a/src/main/java/net/minecraft/world/inventory/MerchantContainer.java b/src/main/java/net/minecraft/world/inventory/MerchantContainer.java
index 9140fab07aab32065f7a3b5d13dd17d61dc6d646..210b88b5d87fad641188cf5907c54824d21163ce 100644
--- a/src/main/java/net/minecraft/world/inventory/MerchantContainer.java
+++ b/src/main/java/net/minecraft/world/inventory/MerchantContainer.java
@@ -130,7 +130,7 @@ public class MerchantContainer implements Container {
     @Override
     public void setItem(int slot, ItemStack stack) {
         this.itemStacks.set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
         if (this.isPaymentSlot(slot)) {
             this.updateSellItem();
         }
diff --git a/src/main/java/net/minecraft/world/inventory/Slot.java b/src/main/java/net/minecraft/world/inventory/Slot.java
index c39c773112fb8b534b926f2f2b47fe6fbb69fcb2..ae9338b8a5598e7a257b469adae72858fed95c39 100644
--- a/src/main/java/net/minecraft/world/inventory/Slot.java
+++ b/src/main/java/net/minecraft/world/inventory/Slot.java
@@ -76,7 +76,7 @@ public class Slot {
     }
 
     public int getMaxStackSize(ItemStack stack) {
-        return Math.min(this.getMaxStackSize(), stack.getMaxStackSize());
+        return Math.min(this.getMaxStackSize(), org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack)); // Leaves - stackable shulker boxes
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/item/BlockItem.java b/src/main/java/net/minecraft/world/item/BlockItem.java
index 96fb69ec6db2e7c8c728435f0c537b076259b2fb..2913bee2c00d6e8f1a5a7e40951891313d8f0228 100644
--- a/src/main/java/net/minecraft/world/item/BlockItem.java
+++ b/src/main/java/net/minecraft/world/item/BlockItem.java
@@ -188,7 +188,7 @@ public class BlockItem extends Item {
         CollisionContext voxelshapecollision = entityhuman == null ? CollisionContext.empty() : CollisionContext.of(entityhuman);
         // CraftBukkit start - store default return
         Level world = context.getLevel(); // Paper - Cancel hit for vanished players
-        boolean defaultReturn = (!this.mustSurvive() || state.canSurvive(context.getLevel(), context.getClickedPos())) && world.checkEntityCollision(state, entityhuman, voxelshapecollision, context.getClickedPos(), true); // Paper - Cancel hit for vanished players
+        boolean defaultReturn = (!this.mustSurvive() || state.canSurvive(context.getLevel(), context.getClickedPos())) && (org.leavesmc.lumina.carpet.CarpetConfig.configModule.creativeNoClip && context.getPlayer() != null ? context.getPlayer().canSpectatingPlace(world, state, context.getClickedPos(), voxelshapecollision) : world.checkEntityCollision(state, entityhuman, voxelshapecollision, context.getClickedPos(), true)); // Paper - Cancel hit for vanished players // Lumina - creative no clip
         org.bukkit.entity.Player player = (context.getPlayer() instanceof ServerPlayer) ? (org.bukkit.entity.Player) context.getPlayer().getBukkitEntity() : null;
 
         BlockCanBuildEvent event = new BlockCanBuildEvent(CraftBlock.at(context.getLevel(), context.getClickedPos()), player, CraftBlockData.fromData(state), defaultReturn, org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(context.getHand())); // Paper - Expose hand in BlockCanBuildEvent
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 41400c4fcd5d204ba9624f776a3e2eaf29a5dff9..0de4dcaa1731725e355a141fdf31f04b0b189942 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -228,7 +228,7 @@ public final class ItemStack implements DataComponentHolder {
     @Deprecated
     @Nullable
     private Item item;
-    private PatchedDataComponentMap components;
+    public PatchedDataComponentMap components; // Leaves - stackable shulker boxes
     @Nullable
     private Entity entityRepresentation;
 
diff --git a/src/main/java/net/minecraft/world/item/PickaxeItem.java b/src/main/java/net/minecraft/world/item/PickaxeItem.java
index e2f826427a62ab52461a93aa53adfad672137d47..7188cdecbea7f1f58fd16a1f36a62eb3c9c262e3 100644
--- a/src/main/java/net/minecraft/world/item/PickaxeItem.java
+++ b/src/main/java/net/minecraft/world/item/PickaxeItem.java
@@ -6,4 +6,15 @@ public class PickaxeItem extends DiggerItem {
     public PickaxeItem(Tier material, Item.Properties properties) {
         super(material, BlockTags.MINEABLE_WITH_PICKAXE, properties);
     }
+
+    // Lumina - Porting Carpet's features - missing tools
+    public float getDestroySpeed(ItemStack stack, net.minecraft.world.level.block.state.BlockState state) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.missingTools && state.getSoundType() == net.minecraft.world.level.block.SoundType.GLASS)
+        {
+            final net.minecraft.world.item.component.Tool tool = stack.get(net.minecraft.core.component.DataComponents.TOOL);
+            return tool != null ? tool.getMiningSpeed(net.minecraft.world.level.block.Blocks.STONE.defaultBlockState()) : super.getDestroySpeed(stack, state);
+        }
+        return super.getDestroySpeed(stack, state);
+    }
+    // Lumina - Porting Carpet's features - missing tools
 }
diff --git a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
index f8f909ebdad5e96379e8bd8c610164ef0697368e..225259124bc7ab5a238475a0246ccf54cc7ea775 100644
--- a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
+++ b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
@@ -56,7 +56,7 @@ public class StandingAndWallBlockItem extends BlockItem {
 
         // CraftBukkit start
         if (iblockdata1 != null) {
-            boolean defaultReturn = world.isUnobstructed(iblockdata1, blockposition, CollisionContext.empty());
+            boolean defaultReturn = context.getPlayer() != null ? context.getPlayer().canSpectatingPlace(world, iblockdata1, blockposition, CollisionContext.empty()) : world.isUnobstructed(iblockdata1, blockposition, CollisionContext.empty()); // Lumina - creative no clip
             org.bukkit.entity.Player player = (context.getPlayer() instanceof ServerPlayer) ? (org.bukkit.entity.Player) context.getPlayer().getBukkitEntity() : null;
 
             BlockCanBuildEvent event = new BlockCanBuildEvent(CraftBlock.at(world, blockposition), player, CraftBlockData.fromData(iblockdata1), defaultReturn, org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(context.getHand())); // Paper - Expose hand in BlockCanBuildEvent
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index e314f36951e9ac15c57137e24fce8c410373130a..be62dda906a9253dbd644ae127c008618901e300 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -29,6 +29,12 @@ import net.minecraft.world.level.ItemLike;
 
 public final class Ingredient implements Predicate<ItemStack> {
 
+    // Lumina start - Porting Carpet's features
+    public List<Collection<ItemStack>> getRecipeStacks() {
+        return Arrays.stream(values).map(Ingredient.Value::getItems).toList();
+    }
+    // Lumina end - Porting Carpet's features
+
     public static final Ingredient EMPTY = new Ingredient(Stream.empty());
     public static final StreamCodec<RegistryFriendlyByteBuf, Ingredient> CONTENTS_STREAM_CODEC = ItemStack.LIST_STREAM_CODEC.map((list) -> {
         return Ingredient.fromValues(list.stream().map(Ingredient.ItemValue::new));
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index 9d0ac3fb52a76a97bf954fbc5175cea90d385d8c..809ea2940d2ac028edf77bcd30bb97f700886ece 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -38,6 +38,12 @@ import org.slf4j.Logger;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Maps;
 // CraftBukkit end
+// Lumina start - Porting Carpet's features
+import net.minecraft.world.item.Item;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+// Lumina end - Porting Carpet's features
 
 public class RecipeManager extends SimpleJsonResourceReloadListener {
 
@@ -53,6 +59,27 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
         this.registries = registryLookup;
     }
 
+    // Lumina start - Porting Carpet's features
+    public List<Recipe<?>> getAllMatching(RecipeType<?> type, ResourceLocation itemId, RegistryAccess registryAccess) {
+        // quiq cheq
+        RecipeHolder<?> recipe = byName.get(itemId);
+        if (recipe != null && recipe.value().getType().equals(type)) {
+            return List.of(recipe.value());
+        }
+        if (!byType.containsKey(type)) {
+            // happens when mods add recipe to the registry without updating recipe manager
+            return List.of();
+        }
+        Collection<RecipeHolder<?>> typeRecipes = byType.get(type);
+        Registry<Item> regs = registryAccess.registryOrThrow(Registries.ITEM);
+        Item item = regs.get(itemId);
+        return typeRecipes.stream()
+                .<Recipe<?>>map(RecipeHolder::value)
+                .filter(r -> r.getResultItem(registryAccess).getItem() == item)
+                .toList();
+    }
+    // Lumina end - Porting Carpet's features
+
     protected void apply(Map<ResourceLocation, JsonElement> prepared, ResourceManager manager, ProfilerFiller profiler) {
         this.hasErrors = false;
         Builder<RecipeType<?>, RecipeHolder<?>> builder = ImmutableMultimap.builder();
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index a0b61c77b23abec531b0b8f9b576fb4501067163..7fb23c02dc91ed3af27eb4420ce920ab22bdb359 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -102,7 +102,10 @@ import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
-
+    // Lumina start - Porting Carpet's features
+    Map<net.minecraft.world.entity.EntityType<?>, Entity> precookedMobs = new HashMap<>();
+    private static final RuntimeException CONTROL_FLOW_EXCEPTION = new RuntimeException("Should be caught for control flow in World_getOtherEntitiesLimited!");
+    // Lumina end - Porting Carpet's features
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("the_nether"));
@@ -175,6 +178,106 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         return (CraftServer) Bukkit.getServer();
     }
 
+    // Lumina start - Porting Carpet's features - fill update
+    public NeighborUpdater getNeighborUpdater() {
+        return this.getCurrentWorldData().neighborUpdater;
+    }
+
+    public Map<net.minecraft.world.entity.EntityType<?>, Entity> getPrecookedMobs() {
+        return precookedMobs;
+    }
+
+    public List<Entity> getOtherEntitiesLimited(@org.jetbrains.annotations.Nullable Entity except, AABB box, Predicate<? super Entity> predicate, int limit) {
+        this.getProfiler().incrementCounter("getEntities"); // visit
+        java.util.concurrent.atomic.AtomicInteger checkedEntities = new java.util.concurrent.atomic.AtomicInteger();
+        List<Entity> list = Lists.newArrayList();
+        try {
+            this.getEntities().get(box, (entity) -> {
+                if (checkedEntities.getAndIncrement() > limit) {
+                    throw CONTROL_FLOW_EXCEPTION;
+                }
+
+                if (entity != except && predicate.test(entity)) {
+                    list.add(entity);
+                }
+
+                if (entity instanceof EnderDragon) {
+                    EnderDragonPart[] var4 = ((EnderDragon) entity).getSubEntities();
+
+                    for (EnderDragonPart enderDragonPart : var4) {
+                        if (entity != except && predicate.test(enderDragonPart)) {
+                            list.add(enderDragonPart);
+                        }
+                    }
+                }
+            });
+        } catch (RuntimeException e) {
+            if (e != CONTROL_FLOW_EXCEPTION)
+                // If it wasn't the exception we were watching, rethrow it
+                throw e;
+        }
+        return list;
+    }
+    // Lumina end - Porting Carpet's features - fill update
+    // Lumina start - Porting Carpet's features - movable block entities
+    public boolean setBlockStateWithBlockEntity(BlockPos blockPos_1, BlockState blockState_1, BlockEntity newBlockEntity, int int_1) {
+        if (isOutsideBuildHeight(blockPos_1) || !this.isClientSide && isDebug()) return false;
+        LevelChunk worldChunk_1 = this.getChunkAt(blockPos_1);
+        Block block_1 = blockState_1.getBlock();
+
+        BlockState blockState_2;
+        if (newBlockEntity != null && block_1 instanceof net.minecraft.world.level.block.EntityBlock) {
+            blockState_2 = worldChunk_1.setBlockStateWithBlockEntity(blockPos_1, blockState_1, newBlockEntity, (int_1 & 64) != 0);
+            if (newBlockEntity instanceof net.minecraft.world.level.block.entity.LidBlockEntity) {
+                scheduleTick(blockPos_1, block_1, 5);
+            }
+        }
+        else {
+            blockState_2 = worldChunk_1.setBlockState(blockPos_1, blockState_1, (int_1 & 64) != 0);
+        }
+
+        if (blockState_2 == null) {
+            return false;
+        }
+        else {
+            BlockState blockState_3 = this.getBlockState(blockPos_1);
+
+            if (blockState_3 != blockState_2 && (blockState_3.getLightBlock((BlockGetter) this, blockPos_1) != blockState_2.getLightBlock((BlockGetter) this, blockPos_1) || blockState_3.getLightEmission() != blockState_2.getLightEmission() || blockState_3.useShapeForLightOcclusion() || blockState_2.useShapeForLightOcclusion())) {
+                ProfilerFiller profiler = getProfiler();
+                profiler.push("queueCheckLight");
+                this.getChunkSource().getLightEngine().checkBlock(blockPos_1);
+                profiler.pop();
+            }
+
+            if (blockState_3 == blockState_1) {
+                if (blockState_2 != blockState_3) {
+                    this.setBlocksDirty(blockPos_1, blockState_2, blockState_3);
+                }
+
+                if ((int_1 & 2) != 0 && (!this.isClientSide || (int_1 & 4) == 0) && (this.isClientSide || worldChunk_1.getFullStatus() != null && worldChunk_1.getFullStatus().isOrAfter(FullChunkStatus.BLOCK_TICKING))) {
+                    this.sendBlockUpdated(blockPos_1, blockState_2, blockState_1, int_1);
+                }
+
+                if (!this.isClientSide && (int_1 & 1) != 0) {
+                    this.updateNeighborsAt(blockPos_1, blockState_2.getBlock());
+                    if (blockState_1.hasAnalogOutputSignal()) {
+                        updateNeighbourForOutputSignal(blockPos_1, block_1);
+                    }
+                }
+
+                if ((int_1 & 16) == 0) {
+                    int int_2 = int_1 & -34;
+                    blockState_2.updateIndirectNeighbourShapes(this, blockPos_1, int_2); // prepare
+                    blockState_1.updateNeighbourShapes(this, blockPos_1, int_2); // updateNeighbours
+                    blockState_1.updateIndirectNeighbourShapes(this, blockPos_1, int_2); // prepare
+                }
+                this.onBlockStateChange(blockPos_1, blockState_2, blockState_3);
+            }
+            return true;
+        }
+    }
+    // Lumina end - Porting Carpet's features - movable block entities
+
     // Paper start - Use getChunkIfLoadedImmediately
     @Override
     public boolean hasChunk(int chunkX, int chunkZ) {
@@ -1032,13 +1135,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             }
 
             if ((i & 1) != 0) {
-                this.blockUpdated(blockposition, iblockdata1.getBlock());
+                if (!org.leavesmc.lumina.carpet.CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.get()) this.blockUpdated(blockposition, iblockdata1.getBlock()); // Lumina - Porting Carpet's features - fill updates
                 if (!this.isClientSide && iblockdata.hasAnalogOutputSignal()) {
                     this.updateNeighbourForOutputSignal(blockposition, newBlock.getBlock());
                 }
             }
 
-            if ((i & 16) == 0 && j > 0) {
+            if ((i & (org.leavesmc.lumina.carpet.CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.get() ? -1 : 16)) == 0 && j > 0) { // Lumina - Porting Carpet's features - fill updates
                 int k = i & -34;
 
                 // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java b/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
index 20f2b575c8131621edea0e75fbf38a9fe20a36c4..8e43f36c32f80ad20e44a9df90d7e0efffd58a66 100644
--- a/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
@@ -58,9 +58,27 @@ public abstract class AbstractCauldronBlock extends Block {
         ItemStack stack, BlockState state, Level world, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit
     ) {
         CauldronInteraction cauldronInteraction = this.interactions.map().get(stack.getItem());
-        return cauldronInteraction.interact(state, world, pos, player, hand, stack);
+        return wrapInteractor(cauldronInteraction, state, world, pos, player, hand, stack);
     }
 
+    // Leaves start - stackable shulker boxes
+    private ItemInteractionResult wrapInteractor(CauldronInteraction cauldronBehavior, BlockState blockState, Level world, BlockPos blockPos, Player playerEntity, InteractionHand hand, ItemStack itemStack) {
+        int count = -1;
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.shulkerBoxStackSize > 1 && itemStack.getItem() instanceof net.minecraft.world.item.BlockItem bi &&
+            bi.getBlock() instanceof ShulkerBoxBlock) {
+            count = itemStack.getCount();
+        }
+        ItemInteractionResult result = cauldronBehavior.interact(blockState, world, blockPos, playerEntity, hand, itemStack);
+        if (count > 0 && result.consumesAction()) {
+            ItemStack current = playerEntity.getItemInHand(hand);
+            if (current.getItem() instanceof net.minecraft.world.item.BlockItem bi && bi.getBlock() instanceof ShulkerBoxBlock) {
+                current.setCount(count);
+            }
+        }
+        return result;
+    }
+    // Leaves end - stackable shulker boxes
+
     @Override
     protected VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {
         return SHAPE;
diff --git a/src/main/java/net/minecraft/world/level/block/BarrierBlock.java b/src/main/java/net/minecraft/world/level/block/BarrierBlock.java
index f114299226082d5c2a306d211c498b12a15d2ddb..4ea61c3a82b6d6ef81dcb63d4e00230c1b668a05 100644
--- a/src/main/java/net/minecraft/world/level/block/BarrierBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BarrierBlock.java
@@ -21,6 +21,38 @@ import net.minecraft.world.level.material.Fluids;
 public class BarrierBlock extends Block implements SimpleWaterloggedBlock {
     public static final MapCodec<BarrierBlock> CODEC = simpleCodec(BarrierBlock::new);
     public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
+    // Lumina start - Porting Carpet's features - update suppression block
+    private boolean shouldPower = false;
+
+    public int getSignal(BlockState state, BlockGetter level, BlockPos pos, Direction direction) {
+        return (shouldPower && direction == Direction.DOWN) ? 15 : 0;
+    }
+
+    public void neighborChanged(BlockState state, net.minecraft.world.level.Level level, BlockPos pos, Block block, BlockPos fromPos, boolean notify) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.updateSuppressionBlock != -1) {
+            if (fromPos.equals(pos.above())) {
+                BlockState stateAbove = level.getBlockState(fromPos);
+                if (stateAbove.is(Blocks.ACTIVATOR_RAIL) && !stateAbove.getValue(PoweredRailBlock.POWERED)) {
+                    level.scheduleTick(pos, this, 1);
+                    net.minecraft.world.level.redstone.NeighborUpdater updater = level.getNeighborUpdater();
+                    if (updater instanceof net.minecraft.world.level.redstone.CollectingNeighborUpdater cnua)
+                        cnua.count = (cnua.maxChainedNeighborUpdates-org.leavesmc.lumina.carpet.CarpetConfig.configModule.updateSuppressionBlock);
+                }
+            }
+        }
+        super.neighborChanged(state, level, pos, block, fromPos, notify);
+    }
+
+    public void tick(BlockState state, net.minecraft.server.level.ServerLevel level, BlockPos pos, net.minecraft.util.RandomSource random) {
+        BlockPos posAbove = pos.above();
+        BlockState stateAbove = level.getBlockState(posAbove);
+        if (stateAbove.is(Blocks.ACTIVATOR_RAIL) && !stateAbove.getValue(PoweredRailBlock.POWERED)) {
+            shouldPower = true;
+            level.setBlock(posAbove, stateAbove.setValue(PoweredRailBlock.POWERED, true), Block.UPDATE_CLIENTS | Block.UPDATE_NONE);
+            shouldPower = false;
+        }
+    }
+    // Lumina end - Porting Carpet's features - update suppression block
 
     @Override
     public MapCodec<BarrierBlock> codec() {
diff --git a/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java b/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
index 8920855b07a31715327b8102c7faafc9f916825d..e18d13d212ec582c972357015e91f8ecc236b3c9 100644
--- a/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
@@ -24,6 +24,19 @@ public class BuddingAmethystBlock extends AmethystBlock {
         super(settings);
     }
 
+    // Lumina start - Porting Carpet's features - movable amethyst
+    public void playerDestroy(net.minecraft.world.level.Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, net.minecraft.world.level.block.entity.BlockEntity blockEntity, net.minecraft.world.item.ItemStack stack) {
+        super.playerDestroy(world, player, pos, state, blockEntity, stack, true, false);
+        // doing it here rather than though loottables since loottables are loaded on reload
+        // drawback - not controlled via loottables, but hey
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.movableAmethyst &&
+                stack.getItem() instanceof net.minecraft.world.item.PickaxeItem &&
+                net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.SILK_TOUCH, stack) > 0
+        )
+            popResource(world, pos, net.minecraft.world.item.Items.BUDDING_AMETHYST.getDefaultInstance());
+    }
+    // Lumina end - Porting Carpet's features - movable amethyst
+
     @Override
     protected void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         if (random.nextInt(5) == 0) {
diff --git a/src/main/java/net/minecraft/world/level/block/ChainBlock.java b/src/main/java/net/minecraft/world/level/block/ChainBlock.java
index 4c6f90b6b9b4bdab6e55790aca11b0b5f37a564f..fcdd5d203544847c011ed74a47ab4f0f10393934 100644
--- a/src/main/java/net/minecraft/world/level/block/ChainBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ChainBlock.java
@@ -27,6 +27,32 @@ public class ChainBlock extends RotatedPillarBlock implements SimpleWaterloggedB
     protected static final VoxelShape Z_AXIS_AABB = Block.box(6.5, 6.5, 0.0, 9.5, 9.5, 16.0);
     protected static final VoxelShape X_AXIS_AABB = Block.box(0.0, 6.5, 6.5, 16.0, 9.5, 9.5);
 
+    // Lumina start - Porting Carpet's features - custom sticky
+    public boolean isSticky(BlockState state) {
+        return org.leavesmc.lumina.carpet.CarpetConfig.configModule.chainStone.enabled();
+    }
+
+    public boolean isStickyToNeighbor(net.minecraft.world.level.Level level, BlockPos pos, BlockState state, BlockPos neighborPos, BlockState neighborState, Direction dir, Direction moveDir) {
+        net.minecraft.core.Direction.Axis axis = state.getValue(ChainBlock.AXIS);
+
+        if (axis != dir.getAxis()) {
+            return false;
+        }
+
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.chainStone == org.leavesmc.lumina.carpet.CarpetConfigModule.ChainStoneMode.STICK_TO_ALL) {
+            return true;
+        }
+        if (neighborState.is((Block)(Object)this)) {
+            return axis == neighborState.getValue(ChainBlock.AXIS);
+        }
+        if (neighborState.is(Blocks.END_ROD)) {
+            return axis == neighborState.getValue(EndRodBlock.FACING).getAxis();
+        }
+
+        return Block.canSupportCenter(level, neighborPos, dir.getOpposite());
+    }
+    // Lumina end - Porting Carpet's features - custom sticky
+
     @Override
     public MapCodec<ChainBlock> codec() {
         return CODEC;
diff --git a/src/main/java/net/minecraft/world/level/block/ChestBlock.java b/src/main/java/net/minecraft/world/level/block/ChestBlock.java
index 8fbfd18b3caeed769396b3ffb1b1778b2f38edc0..a606ba97a912aa99ed077d47c698dc65b97887b7 100644
--- a/src/main/java/net/minecraft/world/level/block/ChestBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ChestBlock.java
@@ -103,6 +103,28 @@ public class ChestBlock extends AbstractChestBlock<ChestBlockEntity> implements
         }
     };
 
+    // Lumina start - Porting Carpet's features - movable block entities
+    public boolean isSticky(BlockState state) {
+        // return org.leavesmc.lumina.carpet.CarpetConfig.configModule.movableBlockEntities; // TODO
+        return false;
+    }
+
+    public boolean isStickyToNeighbor(Level level, BlockPos pos, BlockState state, BlockPos neighborPos, BlockState neighborState, Direction dir, Direction moveDir) {
+        if (!neighborState.is((Block)(Object)this)) {
+            return false;
+        }
+
+        ChestType type = state.getValue(ChestBlock.TYPE);
+        ChestType neighborType = neighborState.getValue(ChestBlock.TYPE);
+
+        if (type == ChestType.SINGLE || neighborType == ChestType.SINGLE) {
+            return false;
+        }
+
+        return getConnectedDirection(state) == dir;
+    }
+    // Lumina end - Porting Carpet's features - movable block entities
+
     // CraftBukkit start
     public static class DoubleInventory implements MenuProvider {
 
diff --git a/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java b/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java
index 7701683000132479d8c8eaa77ac3f93e41a960be..98d9e13ba59961a83d6bb6b07de7dabe1e6af378 100644
--- a/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java
@@ -14,6 +14,11 @@ import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.Fluids;
 
 public class CoralFanBlock extends BaseCoralFanBlock {
+    // Lumina start - Porting Carpet's features - renewable coral
+    public boolean isEnabled() {
+        return org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableCoral == org.leavesmc.lumina.carpet.CarpetConfigModule.RenewableCoralMode.EXPANDED;
+    }
+    // Lumina end - Porting Carpet's features - renewable coral
 
     public static final MapCodec<CoralFanBlock> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
         return instance.group(CoralBlock.DEAD_CORAL_FIELD.forGetter((blockcoralfan) -> {
diff --git a/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java b/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java
index 4c4aa2a63be84ff614a3dc0db2864266755545a2..3585ae18a31d5f56c2e9f489fb20a9edbacad6c0 100644
--- a/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java
@@ -27,6 +27,13 @@ public class CoralPlantBlock extends BaseCoralPlantTypeBlock {
     protected static final float AABB_OFFSET = 6.0F;
     protected static final VoxelShape SHAPE = Block.box(2.0D, 0.0D, 2.0D, 14.0D, 15.0D, 14.0D);
 
+    // Lumina start - Porting Carpet's features - renewable coral
+    public boolean isEnabled() {
+        return org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableCoral == org.leavesmc.lumina.carpet.CarpetConfigModule.RenewableCoralMode.EXPANDED
+                || org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableCoral == org.leavesmc.lumina.carpet.CarpetConfigModule.RenewableCoralMode.TRUE;
+    }
+    // Lumina end - Porting Carpet's features - renewable coral
+
     @Override
     public MapCodec<CoralPlantBlock> codec() {
         return CoralPlantBlock.CODEC;
diff --git a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
index 92cab51f6b3eeb07b574bd3ba82d736e8880acae..64eda8cbe36c04927749d96dae3eaa88a7e33a43 100644
--- a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
@@ -22,6 +22,7 @@ import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.inventory.AbstractContainerMenu;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
@@ -120,12 +121,13 @@ public class DispenserBlock extends BaseEntityBlock {
     }
 
     protected DispenseItemBehavior getDispenseMethod(Level world, ItemStack stack) {
+        if (stack.getItem() == Items.CACTUS) return new org.leavesmc.lumina.carpet.helpers.BlockRotator.CactusDispenserBehaviour(); // Lumina - Porting Carpet's features - cactus dispenser
         return (DispenseItemBehavior) (!stack.isItemEnabled(world.enabledFeatures()) ? DispenserBlock.DEFAULT_BEHAVIOR : (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(stack.getItem()));
     }
 
     @Override
     protected void neighborChanged(BlockState state, Level world, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
-        boolean flag1 = world.hasNeighborSignal(pos) || world.hasNeighborSignal(pos.above());
+        boolean flag1 = world.hasNeighborSignal(pos) || org.leavesmc.lumina.carpet.helpers.QuasiConnectivity.hasQuasiSignal(world,pos.above()); // Lumina - Porting Carpet's features - quasi connectivity
         boolean flag2 = (Boolean) state.getValue(DispenserBlock.TRIGGERED);
 
         if (flag1 && !flag2) {
diff --git a/src/main/java/net/minecraft/world/level/block/HopperBlock.java b/src/main/java/net/minecraft/world/level/block/HopperBlock.java
index 86e5617d445ce762aa374e236a0ccdfe5901fce5..39773b7c4321c4aa88cf2598c42c5d93f367637e 100644
--- a/src/main/java/net/minecraft/world/level/block/HopperBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/HopperBlock.java
@@ -98,7 +98,10 @@ public class HopperBlock extends BaseEntityBlock {
 
     @Override
     public BlockState getStateForPlacement(BlockPlaceContext ctx) {
-        Direction direction = ctx.getClickedFace().getOpposite();
+        // Lumina start - Porting Carpet's features - cactus
+        Direction direction = ctx.getClickedFace();
+        if (!org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(ctx.getPlayer())) direction = direction.getOpposite();
+        // Lumina end - Porting Carpet's features - cactus
         return this.defaultBlockState()
             .setValue(FACING, direction.getAxis() == Direction.Axis.Y ? Direction.DOWN : direction)
             .setValue(ENABLED, Boolean.valueOf(true));
diff --git a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
index f1e349f55a7152f507eff62a4d9fe80805b27308..826f29aa6817a4e9fca67589092a718b993ec7a5 100644
--- a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
@@ -56,6 +56,11 @@ public class InfestedBlock extends Block {
             entitysilverfish.moveTo((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D, 0.0F, 0.0F);
             world.addFreshEntity(entitysilverfish, SpawnReason.SILVERFISH_BLOCK); // CraftBukkit - add SpawnReason
             entitysilverfish.spawnAnim();
+            // Lumina start - Porting Carpet's features - silverfish drop gravel
+            if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.silverFishDropGravel) {
+                popResource(world, pos, new ItemStack(Blocks.GRAVEL));
+            }
+            // Lumina end - Porting Carpet's features - silverfish drop gravel
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/block/LiquidBlock.java b/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
index 84623c632d8c2f0fa7ec939c711316d757117d23..a3aa932a64943a1d9d4cd601dd0a0e7a2d0ac5d2 100644
--- a/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
@@ -190,6 +190,13 @@ public class LiquidBlock extends Block implements BucketPickup {
                 BlockPos blockposition1 = pos.relative(enumdirection.getOpposite());
 
                 if (world.getFluidState(blockposition1).is(FluidTags.WATER)) {
+                    // Lumina start - Porting Carpet's features - renewable deepslate
+                    if(org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableDeepslate && !world.getFluidState(pos).isSource() && world.dimension() == Level.OVERWORLD && pos.getY() < 0) {
+                        world.setBlockAndUpdate(pos, Blocks.COBBLED_DEEPSLATE.defaultBlockState());
+                        this.fizz(world, pos);
+                        return false;
+                    }
+                    // Lumina end - Porting Carpet's features - renewable deepslate
                     Block block = world.getFluidState(pos).isSource() ? Blocks.OBSIDIAN : Blocks.COBBLESTONE;
 
                     // CraftBukkit start
@@ -210,7 +217,22 @@ public class LiquidBlock extends Block implements BucketPickup {
                 }
             }
         }
-
+        // Lumina start - Porting Carpet's features - renewable blackstone
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableBlackstone) {
+            if (fluid.is(FluidTags.LAVA)) {
+                for(Direction direction : Direction.values()) {
+                    if (direction != Direction.DOWN) {
+                        BlockPos blockPos = pos.relative(direction); // offset
+                        if (world.getBlockState(blockPos).is(Blocks.BLUE_ICE)) {
+                            world.setBlockAndUpdate(pos, Blocks.BLACKSTONE.defaultBlockState());
+                            fizz(world, pos);
+                            return false;
+                        }
+                    }
+                }
+            }
+        }
+        // Lumina end - Porting Carpet's features - renewable blackstone
         return true;
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index ed61a1a90f139d0f07442b19a2c547e87a6eff9a..a9462d275c3b0f7d4cabe22fe3c1c609e31b538d 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -546,7 +546,7 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         boolean flag = !stack.isEmpty() && ItemStack.isSameItemSameComponents(itemstack1, stack);
 
         this.items.set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
         if (slot == 0 && !flag) {
             this.cookingTotalTime = AbstractFurnaceBlockEntity.getTotalCookTime(this.level, this.recipeType, this, this.cookSpeedMultiplier); // Paper - cook speed multiplier API
             this.cookingProgress = 0;
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
index 21c747f00892a8372c3ef239f63d59ccaa315295..4de789780bfef0ed4f480cb2d010144835b944c5 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
@@ -146,7 +146,7 @@ public abstract class BaseContainerBlockEntity extends BlockEntity implements Co
     @Override
     public void setItem(int slot, ItemStack stack) {
         this.getItems().set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
         this.setChanged();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index 2731226ad4e525cd5f185590b9b3648b1fcdcfdd..dcda1c691a8732cc71b8b18d0c4f0defb424d99c 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -44,11 +44,17 @@ public abstract class BlockEntity {
     private final BlockEntityType<?> type;
     @Nullable
     protected Level level;
-    protected final BlockPos worldPosition;
+    protected BlockPos worldPosition; // Lumina - Porting Carpet's features
     protected boolean remove;
     private BlockState blockState;
     private DataComponentMap components;
 
+    // Lumina start - Porting Carpet's features - movable block entity
+    public void setCMPos(BlockPos newPos) {
+        worldPosition = newPos;
+    }
+    // Lumina end - Porting Carpet's features
+
     // Folia start - region ticking
     public void updateTicks(final long fromTickOffset, final long fromRedstoneTimeOffset) {
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 5a51c11074f629f640374094b59fb986ac2b77e1..491b522060f1126407035f3720f4684bb544078f 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -22,6 +22,7 @@ import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.inventory.AbstractContainerMenu;
 import net.minecraft.world.inventory.HopperMenu;
+import net.minecraft.world.item.DyeColor;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
@@ -161,7 +162,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     public void setItem(int slot, ItemStack stack) {
         this.unpackLootTable((Player) null);
         this.getItems().set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
     }
 
     @Override
@@ -486,6 +487,25 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     // Paper end - Perf: Optimize Hoppers
 
     private static boolean ejectItems(Level world, BlockPos pos, HopperBlockEntity blockEntity) {
+        // Lumina start - Porting Carpet's features - hopper counters
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.hopperCounters) {
+            Direction hopperFacing = world.getBlockState(pos).getValue(HopperBlock.FACING);
+            DyeColor woolColor = org.leavesmc.lumina.carpet.utils.WoolTool.getWoolColorAtPosition(
+                    world,
+                    pos.relative(hopperFacing));
+            if (woolColor != null) {
+                Container inventory = HopperBlockEntity.getContainerAt(world, pos);
+                for (int i = 0; i < inventory.getContainerSize(); ++i) {
+                    if (!inventory.getItem(i).isEmpty()) {
+                        ItemStack itemstack = inventory.getItem(i);//.copy();
+                        org.leavesmc.lumina.carpet.helpers.HopperCounter.getCounter(woolColor).add(world.getServer(), itemstack);
+                        inventory.setItem(i, ItemStack.EMPTY);
+                    }
+                }
+                return true;
+            }
+        }
+        // Lumina end - Porting Carpet's features - hopper counters
         Container iinventory = HopperBlockEntity.getAttachedContainer(world, pos, blockEntity);
 
         if (iinventory == null) {
@@ -783,9 +803,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
             if (itemstack1.isEmpty()) {
                 // Spigot start - SPIGOT-6693, InventorySubcontainer#setItem
                 ItemStack leftover = ItemStack.EMPTY; // Paper - Make hoppers respect inventory max stack size
-                if (!stack.isEmpty() && stack.getCount() > to.getMaxStackSize()) {
+                if (!stack.isEmpty() && (stack.getCount() > to.getMaxStackSize() || stack.getCount() > stack.getMaxStackSize())) { // Leaves - stackable shulker boxes
                     leftover = stack; // Paper - Make hoppers respect inventory max stack size
-                    stack = stack.split(to.getMaxStackSize());
+                    stack = stack.split(Math.min(to.getMaxStackSize(), stack.getMaxStackSize())); // Leaves - stackable shulker boxes
                 }
                 // Spigot end
                 IGNORE_TILE_UPDATES.set(Boolean.TRUE); // Paper - Perf: Optimize Hoppers // Folia - region threading
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
index 4caceb37f0aec4a1d326fe45ff096e6473b64447..25b13cf76b62d4c64d0548627c60c37c103e541c 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
@@ -163,7 +163,7 @@ public class ShulkerBoxBlockEntity extends RandomizableContainerBlockEntity impl
                 while (iterator.hasNext()) {
                     Entity entity = (Entity) iterator.next();
 
-                    if (entity.getPistonPushReaction() != PushReaction.IGNORE) {
+                    if (entity.getPistonPushReaction() != PushReaction.IGNORE  && !(entity instanceof Player player && player.isCreativeFlyOrSpectator())) { // Lumina - creative no clip
                         entity.move(MoverType.SHULKER_BOX, new Vec3((axisalignedbb.getXsize() + 0.01D) * (double) enumdirection.getStepX(), (axisalignedbb.getYsize() + 0.01D) * (double) enumdirection.getStepY(), (axisalignedbb.getZsize() + 0.01D) * (double) enumdirection.getStepZ()));
                     }
                 }
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index bf9a6f40998144ba7dbdfafc8dbdbb84168d1edb..431d95c45f6fab95241396794bccfedf41339f40 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -69,6 +69,12 @@ public class PistonBaseBlock extends DirectionalBlock {
     protected static final VoxelShape DOWN_AABB = Block.box(0.0D, 4.0D, 0.0D, 16.0D, 16.0D, 16.0D);
     private final boolean isSticky;
 
+    // Lumina start - Porting Carpet's features - movable block entities // TODO
+    public boolean publicShouldExtend(Level world_1, BlockPos blockPos_1, Direction direction_1) {
+        return getNeighborSignal(world_1, blockPos_1,direction_1);
+    }
+    // Lumina end - Porting Carpet's features - movable block entities
+
     @Override
     public MapCodec<PistonBaseBlock> codec() {
         return PistonBaseBlock.CODEC;
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index 58b570cfdd52b414752b5a117946d59031eafe94..799ecfcc947407d57e36ce47305d33f3cb5595f5 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -157,7 +157,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
                                         h = (double)direction.getStepZ();
                                 }
 
-                                entity.setDeltaMovement(e, g, h);
+                                if (!(entity instanceof net.minecraft.world.entity.player.Player player) || !player.isCreativeFlyOrSpectator()) entity.setDeltaMovement(e, g, h); // Lumina - creative no clip
                                 // Paper - EAR items stuck in in slime pushed by a piston
                                 entity.activatedTick = Math.max(entity.activatedTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 10); // Folia - region threading
                                 entity.activatedImmunityTick = Math.max(entity.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 10); // Folia - region threading
@@ -193,6 +193,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
     }
 
     private static void moveEntityByPiston(Direction direction, Entity entity, double distance, Direction movementDirection) {
+        if (entity instanceof net.minecraft.world.entity.player.Player player && player.isCreativeFlyOrSpectator()) return; // Lumina - creative no clip
         NOCLIP.set(direction);
         entity.move(
             MoverType.PISTON,
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 2034ca2edd3aff61d94416266e75402babd3e741..1b95d8ac61d9d4a3717a65fdf1dac6d6596b661a 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -189,7 +189,7 @@ public abstract class BlockBehaviour implements FeatureElement {
                     // CraftBukkit end
                 }
 
-                state.spawnAfterBreak(worldserver, pos, ItemStack.EMPTY, flag);
+                state.spawnAfterBreak(worldserver, pos, ItemStack.EMPTY, flag || org.leavesmc.lumina.carpet.CarpetConfig.configModule.xpFromExplosions); // Lumina - Porting Carpet's features - xp from explosions
                 state.getDrops(lootparams_a).forEach((itemstack) -> {
                     stackMerger.accept(itemstack, pos);
                 });
@@ -1088,6 +1088,11 @@ public abstract class BlockBehaviour implements FeatureElement {
         }
 
         public PushReaction getPistonPushReaction() {
+            // Lumina start - Porting Carpet's features - movable amethyst
+            if (org.leavesmc.lumina.carpet.CarpetConfig.configModule.movableAmethyst && getBlock() instanceof net.minecraft.world.level.block.BuddingAmethystBlock) {
+                return PushReaction.NORMAL;
+            }
+            // Lumina end - Porting Carpet's features - movable amethyst
             return !this.isDestroyable() ? PushReaction.BLOCK : this.pushReaction; // Paper - Protect Bedrock and End Portal/Frames from being destroyed
         }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 1aac95b03a9e2e37c24f2a30bcb259c1424e1c78..4758fdbd9c729e7bdd024d7d2f341d3ff74a4596 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -349,6 +349,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     public abstract void removeBlockEntity(BlockPos pos);
 
     public void markPosForPostprocessing(BlockPos pos) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.SKIP_GENERATION_CHECKS.get()) return; // Lumina - Porting Carpet's features - Skip generation checks
         ChunkAccess.LOGGER.warn("Trying to mark a block for PostProcessing @ {}, but this operation is not supported.", pos);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 9a17f3d0b53b2ab0358012e4238164f8af0a6c6e..cdae8bf6b5e83b95a653ec4736c272e69a9f6d57 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -532,6 +532,12 @@ public abstract class ChunkGenerator {
 
         while (iterator.hasNext()) {
             Entry<Structure, LongSet> entry = (Entry) iterator.next();
+            // Lumina start - Porting Carpet's features - custome mob spawn
+            WeightedRandomList<MobSpawnSettings.SpawnerData> res = org.leavesmc.lumina.carpet.utils.SpawnOverrides.test(accessor, entry.getValue(), group, entry.getKey(), pos);
+            if (res != null) {
+                return res;
+            }
+            // Lumina end - Porting Carpet's features - custome mob spawn
             Structure structure = (Structure) entry.getKey();
             StructureSpawnOverride structurespawnoverride = (StructureSpawnOverride) structure.spawnOverrides().get(group);
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index b1c86ba3010f67a3a0db34b92df459bcf51ff15f..1e96806c974a9fdb574f851daea2fb67cb9ac409 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -99,6 +99,79 @@ public class LevelChunk extends ChunkAccess {
         this(world, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, (LevelChunkSection[]) null, (LevelChunk.PostLoadProcessor) null, (BlendingData) null);
     }
 
+    // Lumina start - Porting Carpet's features - fill updates
+    public BlockState setBlockStateWithBlockEntity(BlockPos blockPos_1, BlockState newBlockState, BlockEntity newBlockEntity, boolean boolean_1) {
+        int x = blockPos_1.getX() & 15;
+        int y = blockPos_1.getY();
+        int z = blockPos_1.getZ() & 15;
+        LevelChunkSection chunkSection = this.getSection(this.getSectionIndex(y));
+        if (chunkSection.hasOnlyAir()) {
+            if (newBlockState.isAir()) {
+                return null;
+            }
+        }
+
+        boolean boolean_2 = chunkSection.hasOnlyAir();
+        BlockState oldBlockState = chunkSection.setBlockState(x, y & 15, z, newBlockState);
+        if (oldBlockState == newBlockState) {
+            return null;
+        }
+        else {
+            Block newBlock = newBlockState.getBlock();
+            Block oldBlock = oldBlockState.getBlock();
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING)).update(x, y, z, newBlockState);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES)).update(x, y, z, newBlockState);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.OCEAN_FLOOR)).update(x, y, z, newBlockState);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.WORLD_SURFACE)).update(x, y, z, newBlockState);
+            boolean boolean_3 = chunkSection.hasOnlyAir();
+            if (boolean_2 != boolean_3) {
+                this.level.getChunkSource().getLightEngine().updateSectionStatus(blockPos_1, boolean_3);
+            }
+
+            if (!this.level.isClientSide) {
+                if (!(oldBlock instanceof net.minecraft.world.level.block.piston.MovingPistonBlock))//this is a movableTE special case, if condition wasn't there it would remove the blockentity that was carried for some reason
+                    oldBlockState.onRemove(this.level, blockPos_1, newBlockState, boolean_1);//this kills it
+            }
+            else if (oldBlock != newBlock && oldBlock instanceof EntityBlock) {
+                this.level.removeBlockEntity(blockPos_1);
+            }
+
+            if (chunkSection.getBlockState(x, y & 15, z).getBlock() != newBlock) {
+                return null;
+            }
+            else {
+                BlockEntity oldBlockEntity = null;
+                if (oldBlockState.hasBlockEntity()) {
+                    oldBlockEntity = this.getBlockEntity(blockPos_1, LevelChunk.EntityCreationType.CHECK);
+                    if (oldBlockEntity != null) {
+                        oldBlockEntity.setBlockState(oldBlockState);
+                        updateBlockEntityTicker(oldBlockEntity);
+                    }
+                }
+
+                if (oldBlockState.hasBlockEntity()) {
+                    if (newBlockEntity == null) {
+                        newBlockEntity = ((EntityBlock) newBlock).newBlockEntity(blockPos_1, newBlockState);
+                    }
+                    if (newBlockEntity != oldBlockEntity && newBlockEntity != null) {
+                        newBlockEntity.clearRemoved();
+                        this.level.setBlockEntity(newBlockEntity);
+                        newBlockEntity.setBlockState(newBlockState);
+                        updateBlockEntityTicker(newBlockEntity);
+                    }
+                }
+
+                if (!this.level.isClientSide) {
+                    newBlockState.onPlace(this.level, blockPos_1, oldBlockState, boolean_1); //This can call setblockstate! (e.g. hopper does)
+                }
+
+                this.unsaved = true; // shouldSave
+                return oldBlockState;
+            }
+        }
+    }
+    // Lumina end - Porting Carpet's features - fill updates
+
     public LevelChunk(Level world, ChunkPos pos, UpgradeData upgradeData, LevelChunkTicks<Block> blockTickScheduler, LevelChunkTicks<Fluid> fluidTickScheduler, long inhabitedTime, @Nullable LevelChunkSection[] sectionArrayInitializer, @Nullable LevelChunk.PostLoadProcessor entityLoader, @Nullable BlendingData blendingData) {
         super(pos, upgradeData, world, net.minecraft.server.MinecraftServer.getServer().registryAccess().registryOrThrow(Registries.BIOME), inhabitedTime, sectionArrayInitializer, blendingData); // Paper - Anti-Xray - The world isn't ready yet, use server singleton for registry
         this.tickersInLevel = Maps.newHashMap();
@@ -461,7 +534,16 @@ public class LevelChunk extends ChunkAccess {
                 boolean flag3 = iblockdata1.hasBlockEntity();
 
                 if (!this.level.isClientSide && !this.level.getCurrentWorldData().isBlockPlaceCancelled) { // Paper - prevent calling cleanup logic when undoing a block place upon a cancelled BlockPlaceEvent // Folia - region threading
-                    iblockdata1.onRemove(this.level, blockposition, iblockdata, flag);
+                    // Lumina start - Porting Carpet's features - fill updates
+                    if (org.leavesmc.lumina.carpet.CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.get()) { // doing due dilligence from AbstractBlock onStateReplaced{
+                        if (iblockdata1.hasBlockEntity() && !iblockdata1.is(iblockdata.getBlock())) {
+                            this.level.removeBlockEntity(blockposition);
+                        }
+                    }
+                    else {
+                        iblockdata1.onRemove(this.level, blockposition, iblockdata, flag);
+                    }
+                    // Lumina end - Porting Carpet's features - fill updates
                 } else if (!iblockdata1.is(block) && flag3) {
                     this.removeBlockEntity(blockposition);
                 }
@@ -471,11 +553,13 @@ public class LevelChunk extends ChunkAccess {
                 } else {
                     // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
                     if (!this.level.isClientSide && doPlace && (!this.level.getCurrentWorldData().captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // Folia - region threading
-                        iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
+                        if (!org.leavesmc.lumina.carpet.CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.get()) iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                     }
 
                     if (iblockdata.hasBlockEntity()) {
-                        BlockEntity tileentity = this.getBlockEntity(blockposition, LevelChunk.EntityCreationType.CHECK);
+                        BlockEntity tileentity =
+                                // (!org.leavesmc.lumina.carpet.CarpetConfig.configModule.movableBlockEntities) ? this.getBlockEntity(blockposition, LevelChunk.EntityCreationType.CHECK) :
+                                this.level.getBlockEntity(blockposition); // Lumina - Porting Carpet's features - movable block entities // TODO
 
                         if (tileentity == null) {
                             tileentity = ((EntityBlock) block).newBlockEntity(blockposition, iblockdata);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java
index 7bc5ff8eb1174834dcc27363af4a5cef19017b3d..44d75c68eec02c6c6407352b63e32ba6081eb1e5 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java
@@ -22,6 +22,12 @@ public abstract class CoralFeature extends Feature<NoneFeatureConfiguration> {
         super(configCodec);
     }
 
+    // Lumina start - Porting Carpet's features - renewable coral
+    public boolean growSpecific(net.minecraft.world.level.Level worldIn, RandomSource random, BlockPos pos, BlockState blockUnder) {
+        return placeFeature(worldIn, random, pos, blockUnder);
+    }
+    // Lumina end - Porting Carpet's features - renewable coral
+
     @Override
     public boolean place(FeaturePlaceContext<NoneFeatureConfiguration> context) {
         RandomSource randomSource = context.random();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java
index 4ccb92ca80752eb614114b554f65bb8427785d41..bedd0980a2a6318f058666c77d043551e961f845 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java
@@ -49,8 +49,14 @@ public class HugeFungusFeature extends Feature<HugeFungusConfiguration> {
                 }
             }
 
+            // Lumina start - Porting Carpet's features - thick fungus growth
             boolean bl = !hugeFungusConfiguration.planted && randomSource.nextFloat() < 0.06F;
             worldGenLevel.setBlock(blockPos, Blocks.AIR.defaultBlockState(), 4);
+            boolean natural = !hugeFungusConfiguration.planted;
+            bl = natural && bl ||
+                    !natural && (org.leavesmc.lumina.carpet.CarpetConfig.configModule.thickFungusGrowth == org.leavesmc.lumina.carpet.CarpetConfigModule.FungusGrowthMode.ALL ||
+                            org.leavesmc.lumina.carpet.CarpetConfig.configModule.thickFungusGrowth == org.leavesmc.lumina.carpet.CarpetConfigModule.FungusGrowthMode.RANDOM && randomSource.nextFloat() < 0.06F);
+            // Lumina end - Porting Carpet's features - thick fungus growth
             this.placeStem(worldGenLevel, randomSource, hugeFungusConfiguration, blockPos2, i, bl);
             this.placeHat(worldGenLevel, randomSource, hugeFungusConfiguration, blockPos2, i, bl);
             return true;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java b/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java
index 05cca3aef35f7ab016790a7ea2328772fcf7bf38..d63a35ba6886f251b3a4213b6a6fa8774ad51cdb 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java
@@ -23,7 +23,7 @@ public interface PieceGeneratorSupplier<C extends FeatureConfiguration> {
         Predicate<PieceGeneratorSupplier.Context<C>> predicate, PieceGenerator<C> generator
     ) {
         Optional<PieceGenerator<C>> optional = Optional.of(generator);
-        return context -> predicate.test(context) ? optional : Optional.empty();
+        return context -> (org.leavesmc.lumina.carpet.CarpetConfig.SKIP_GENERATION_CHECKS.get() || predicate.test(context)) ? optional : Optional.empty(); // Lumina - Porting Carpet's features - skip generation checks
     }
 
     static <C extends FeatureConfiguration> Predicate<PieceGeneratorSupplier.Context<C>> checkForBiomeOnTop(Heightmap.Types heightmapType) {
diff --git a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
index 58296b67f80587af485b0068e461cfd3d8d6f96f..2762c02ece0f4ff5b8a2d781281c65618277dacc 100644
--- a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
@@ -501,7 +501,7 @@ public abstract class FlowingFluid extends Fluid {
         if (block instanceof LiquidBlockContainer ifluidcontainer) {
             return ifluidcontainer.canPlaceLiquid((Player) null, world, pos, state, fluid);
         } else {
-            return !(block instanceof DoorBlock) && !state.is(BlockTags.SIGNS) && !state.is(Blocks.LADDER) && !state.is(Blocks.SUGAR_CANE) && !state.is(Blocks.BUBBLE_COLUMN) ? (!state.is(Blocks.NETHER_PORTAL) && !state.is(Blocks.END_PORTAL) && !state.is(Blocks.END_GATEWAY) && !state.is(Blocks.STRUCTURE_VOID) ? !state.blocksMotion() : false) : false;
+            return !(block instanceof DoorBlock) && !state.is(BlockTags.SIGNS) && !state.is(Blocks.LADDER) && !state.is(Blocks.SUGAR_CANE) && !state.is(Blocks.BUBBLE_COLUMN) && (!state.is(Blocks.NETHER_PORTAL) && !state.is(Blocks.END_PORTAL) && !state.is(Blocks.END_GATEWAY) && !((org.leavesmc.lumina.carpet.CarpetConfig.configModule.liquidDamageDisabled) ? (state.isAir() || state.is(Blocks.WATER) || state.is(Blocks.LAVA)) : state.is(Blocks.STRUCTURE_VOID)) && !state.blocksMotion()); // Lumina - Porting Carpet's features - liquid damage disabled
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/material/LavaFluid.java b/src/main/java/net/minecraft/world/level/material/LavaFluid.java
index 3bb4a9a1a6249e8ba2de237f801210e7f4fd5825..03a91cf6ed6e77262f5208f61b06a151d4efa3e2 100644
--- a/src/main/java/net/minecraft/world/level/material/LavaFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/LavaFluid.java
@@ -210,6 +210,13 @@ public abstract class LavaFluid extends FlowingFluid {
 
             if (this.is(FluidTags.LAVA) && fluid1.is(FluidTags.WATER)) {
                 if (state.getBlock() instanceof LiquidBlock) {
+                    // Lumina start - Porting Carpet's features - renewable deepslate
+                    if(org.leavesmc.lumina.carpet.CarpetConfig.configModule.renewableDeepslate && ((Level)world).dimension() == Level.OVERWORLD && pos.getY() < 0) {
+                        world.setBlock(pos, Blocks.DEEPSLATE.defaultBlockState(), 3);
+                        this.fizz(world, pos);
+                        return;
+                    }
+                    // Lumina end - Porting Carpet's features - renewable deepslate
                     // CraftBukkit start
                     if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(world.getMinecraftWorld(), pos, Blocks.STONE.defaultBlockState(), 3)) {
                         return;
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index a6bc5c5053f1fce822166d0cd1ea67dc490dc0af..57737218697f90c55b3e8a87f1c4ac5bbdf373f7 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -15,10 +15,10 @@ import org.slf4j.Logger;
 public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
-    private final int maxChainedNeighborUpdates;
+    public final int maxChainedNeighborUpdates; // Lumina - Porting Carpet's features - access
     private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
     private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
-    private int count = 0;
+    public int count = 0; // Lumina - Porting Carpet's features - access
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
         this.level = world;
diff --git a/src/main/java/org/leavesmc/leaves/protocol/CarpetServerProtocol.java b/src/main/java/org/leavesmc/leaves/protocol/CarpetServerProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..25a56039f950d8dae0494233daac802141ad09f2
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/protocol/CarpetServerProtocol.java
@@ -0,0 +1,127 @@
+package org.leavesmc.leaves.protocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.protocol.core.LeavesCustomPayload;
+import org.leavesmc.leaves.protocol.core.LeavesProtocol;
+import org.leavesmc.leaves.protocol.core.ProtocolHandler;
+import org.leavesmc.leaves.protocol.core.ProtocolUtils;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.config.LuminaConfig;
+
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+@LeavesProtocol(namespace = "carpet")
+public class CarpetServerProtocol {
+
+    public static final String PROTOCOL_ID = "carpet";
+    public static final String VERSION = "leaves-carpet-1.0.0";
+
+    private static final ResourceLocation HELLO_ID = CarpetServerProtocol.id("hello");
+
+    private static final String HI = "69";
+    private static final String HELLO = "420";
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    @ProtocolHandler.PlayerJoin
+    public static void onPlayerJoin(ServerPlayer player) {
+        if (LuminaConfig.configModule.protocol.carpetProtocol) {
+            CompoundTag data = new CompoundTag();
+            data.putString(HI, VERSION);
+            ProtocolUtils.sendPayloadPacket(player, new CarpetPayload(data));
+            CarpetServer.onPlayerLoggedIn(player);
+        }
+    }
+
+    @ProtocolHandler.PayloadReceiver(payload = CarpetPayload.class, payloadId = "hello")
+    private static void handleHello(@NotNull ServerPlayer player, @NotNull CarpetServerProtocol.CarpetPayload payload) {
+        if (LuminaConfig.configModule.protocol.carpetProtocol) {
+            if (payload.nbt.contains(HELLO)) {
+                CarpetServer.LOGGER.info("Player {} joined with carpet {}", player.getScoreboardName(), payload.nbt.getString(HELLO));
+                CompoundTag data = new CompoundTag();
+                CarpetRules.write(data);
+                ProtocolUtils.sendPayloadPacket(player, new CarpetPayload(data));
+            }
+        }
+    }
+
+    @ProtocolHandler.Ticker
+    private static void tick() {
+        CarpetServer.tick(MinecraftServer.getServer());
+    }
+
+    public static class CarpetRules {
+
+        private static final Map<String, CarpetRule> rules = new HashMap<>();
+
+        public static void write(@NotNull CompoundTag tag) {
+            CompoundTag rulesNbt = new CompoundTag();
+            rules.values().forEach(rule -> rule.writeNBT(rulesNbt));
+
+            tag.put("Rules", rulesNbt);
+        }
+
+        public static void register(CarpetRule rule) {
+            rules.put(rule.name, rule);
+        }
+    }
+
+    public record CarpetRule(String identifier, String name, String value) {
+
+        @NotNull
+        @Contract("_, _, _ -> new")
+        public static CarpetRule of(String identifier, String name, Enum<?> value) {
+            return new CarpetRule(identifier, name, value.name().toLowerCase(Locale.ROOT));
+        }
+
+        @NotNull
+        @Contract("_, _, _ -> new")
+        public static CarpetRule of(String identifier, String name, boolean value) {
+            return new CarpetRule(identifier, name, Boolean.toString(value));
+        }
+
+        public void writeNBT(@NotNull CompoundTag rules) {
+            CompoundTag rule = new CompoundTag();
+            String key = name;
+
+            while (rules.contains(key)) {
+                key = key + "2";
+            }
+
+            rule.putString("Value", value);
+            rule.putString("Manager", identifier);
+            rule.putString("Rule", name);
+            rules.put(key, rule);
+        }
+    }
+
+    public record CarpetPayload(CompoundTag nbt) implements LeavesCustomPayload<CarpetPayload> {
+
+        @New
+        public CarpetPayload(ResourceLocation location, FriendlyByteBuf buf) {
+            this(buf.readNbt());
+        }
+
+        @Override
+        public void write(FriendlyByteBuf buf) {
+            buf.writeNbt(nbt);
+        }
+
+        @Override
+        @NotNull
+        public ResourceLocation id() {
+            return HELLO_ID;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/leaves/util/ShulkerBoxUtils.java b/src/main/java/org/leavesmc/leaves/util/ShulkerBoxUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3aa030299ec3fa8170b7fc39b5f23e7eb4141ba
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/util/ShulkerBoxUtils.java
@@ -0,0 +1,28 @@
+package org.leavesmc.leaves.util;
+
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.ItemContainerContents;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+public class ShulkerBoxUtils {
+
+    public static boolean shulkerBoxNoItem(@NotNull ItemStack stack) {
+        return stack.getComponents().getOrDefault(DataComponents.CONTAINER, ItemContainerContents.EMPTY).stream().findAny().isEmpty();
+    }
+
+    public static int getItemStackMaxCount(ItemStack stack) {
+        if (CarpetConfig.configModule.shulkerBoxStackSize > 1 && stack.getItem() instanceof BlockItem bi &&
+                bi.getBlock() instanceof ShulkerBoxBlock && org.leavesmc.leaves.util.ShulkerBoxUtils.shulkerBoxNoItem(stack)) {
+            return CarpetConfig.configModule.shulkerBoxStackSize;
+        }
+        return stack.getMaxStackSize();
+    }
+
+    public static boolean isStackable(ItemStack itemStack) {
+        return getItemStackMaxCount(itemStack) > 1 && (!itemStack.isDamageableItem() || !itemStack.isDamaged());
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5bf7371e4d16726b1f275a9bd0fdb02a12ae9be
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfig.java
@@ -0,0 +1,83 @@
+package org.leavesmc.lumina.carpet;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import net.minecraft.world.level.block.Block;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.ConfigUtils;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.leavesmc.lumina.config.LuminaConfigModule;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+
+public class CarpetConfig {
+    public static final ThreadLocal<Boolean> IMPENDING_FILL_SKIP_UPDATES = ThreadLocal.withInitial(() -> false);
+    public static final ThreadLocal<Boolean> SKIP_GENERATION_CHECKS = ThreadLocal.withInitial(() -> false);
+    public static CarpetConfigModule configModule;
+    public static Block structureBlockIgnoredBlock;
+    private static HoconConfigurationLoader loader;
+    private static CommentedConfigurationNode node;
+    public static Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+
+    public static void setup() {
+        loader = HoconConfigurationLoader.builder()
+                .emitComments(true)
+                .prettyPrinting(true)
+                .path(Paths.get("carpet.conf"))
+                .build();
+
+        loadConfig();
+        saveConfig();
+
+        try {
+            ConfigUtils.generateNodeInfos(nodeInfos, CarpetConfigModule.class, null, configModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void reload() {
+        RegionizedServer.ensureGlobalTickThread("Reload carpet config off global region thread!");
+        loadConfig();
+    }
+
+    private static void loadConfig() {
+        try {
+            node = loader.load();
+            configModule = node.get(CarpetConfigModule.class);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void save() {
+        RegionizedServer.ensureGlobalTickThread("Reload carpet config off global region thread!");
+        saveConfig();
+    }
+
+    private static void saveConfig() {
+        try {
+            node.set(CarpetConfigModule.class, configModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> reloadAsync() {
+        return ConfigUtils.runAsync(CarpetConfig::reload);
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> saveAsync() {
+        return ConfigUtils.runAsync(CarpetConfig::save);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..43a4b19c8d9195f0f88cc1d8444386d444d43be2
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
@@ -0,0 +1,473 @@
+package org.leavesmc.lumina.carpet;
+
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.StructureBlockEntity;
+import net.minecraft.world.level.block.piston.PistonStructureResolver;
+import net.minecraft.world.level.border.BorderStatus;
+import net.minecraft.world.level.border.WorldBorder;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.Validator;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.Comment;
+
+import java.util.Optional;
+
+@ConfigSerializable
+public class CarpetConfigModule {
+    @Comment("Sets the language for Carpet")
+    public Lang language = Lang.zh_cn;
+
+    @Comment("Dropping entire stacks works also from on the crafting UI result slot")
+    public boolean ctrlQCraftingFix = false;
+
+    @Comment("Parrots don't get of your shoulders until you receive proper damage")
+    public boolean persistentParrots = false;
+
+    @Comment("Players absorb XP instantly, without delay")
+    public boolean xpNoCooldown = false;
+
+    @Validate(ShulkerBoxValidator.class)
+    @Comment("""
+            When set more than 1, empty shulker boxes can stack when thrown on the ground,
+            or when manipulated inside the inventories""")
+    public int shulkerBoxStackSize = 1;
+
+    @Comment("Explosions won't destroy blocks")
+    public boolean explosionNoBlockDamage = false;
+
+    @Comment("Experience will drop from all experience barring blocks with any explosion type")
+    public boolean xpFromExplosions = false;
+
+    @Comment("Removes random TNT momentum when primed")
+    public boolean tntPrimerMomentumRemoved = false;
+
+    @Validate(TNTRandomRangeValidator.class)
+    @Comment("Sets the tnt random explosion range to a fixed value, set to -1 for default behavior")
+    public double tntRandomRange = -1;
+
+    @Validate(TNTAngleValidator.class)
+    @Comment("Sets the horizontal random angle on TNT for debugging of TNT contraptions, set to -1 for default behavior")
+    public double hardcodeTNTangle = -1.0D;
+
+    @Comment("Merges stationary primed TNT entities")
+    public boolean mergeTNT = false;
+
+    @Comment("Only husks spawn in desert temples")
+    public boolean huskSpawningInTemples = false;
+
+    @Comment("Shulkers will respawn in end cities")
+    public boolean shulkerSpawningInEndCities = false;
+
+    @Comment("""
+            Piglins will respawn in bastion remnants
+            Includes piglins, brutes, and a few hoglins""")
+    public boolean piglinsSpawningInBastions = false;
+
+    @Comment("TNT doesn't update when placed against a power source")
+    public boolean tntDoNotUpdate = false;
+
+    @Comment("""
+            Prevents players from rubberbanding when moving too fast or being kicked out for 'flying'
+            Puts more trust in clients positioning, increases player allowed mining distance to 32 blocks""")
+    public boolean antiCheatDisabled = false;
+
+    @Validate(QuasiConnectivityValidator.class)
+    @Comment("""
+            Pistons, droppers, and dispensers check for power to the block(s) above them.
+            Defines the range at which pistons, droppers, and dispensers check for 'quasi power""")
+    public int quasiConnectivity = 1;
+
+    @Comment("""
+            Players can flip and rotate blocks when holding cactus
+            Doesn't cause block updates when rotated/flipped
+            Applies to pistons, observers, droppers, repeaters, stairs, glazed terracotta etc...""")
+    public boolean flippinCactus = false;
+
+    @Comment("""
+            hoppers pointing to wool will count items passing through them
+            Enables /counter command, and actions while placing red and green carpets on wool blocks
+            Use /counter <color?> reset to reset the counter, and /counter <color?> to query
+            In survival, place green carpet on same color wool to query, red to reset the counters
+            Counters are global and shared between players, 16 channels available
+            Items counted are destroyed, count up to one stack per tick per hopper""")
+    public boolean hopperCounters = false;
+
+    @Comment("""
+            Allows Budding Amethyst blocks to be moved by pistons
+            as well as adds extra drop when mining with silk touch pickaxe""")
+    public boolean movableAmethyst = false;
+
+    @Comment("Guardians turn into Elder Guardian when struck by lightning")
+    public boolean renewableSponges = false;
+
+    // @Comment("Pistons can push block entities, like hoppers, chests etc.")
+    // public boolean movableBlockEntities = false; // TODO
+
+    @Comment("""
+            Chains will stick to each other on the long ends
+            and will stick to other blocks that connect to them directly.
+            With stick_to_all: it will stick even if not visually connected""")
+    public ChainStoneMode chainStone = ChainStoneMode.FALSE;
+
+    @Comment("Saplings turn into dead shrubs in hot climates and no water access")
+    public boolean desertShrubs = false;
+
+    @Comment("Silverfish drop a gravel item when breaking out of a block")
+    public boolean silverFishDropGravel = false;
+
+    @Comment("summoning a lightning bolt has all the side effects of natural lightning")
+    public boolean summonNaturalLightning = false;
+
+    @Comment("Enables /spawn command for spawn tracking")
+    public boolean commandSpawn = true;
+
+    @Comment("Enables /log command to monitor events via chat and overlays")
+    public boolean commandLog = true;
+
+    @Suggestion({"none", "tps", "mobcaps,tps"})
+    @Comment("""
+            sets these loggers in their default configurations for all new players
+            use csv, like 'tps,mobcaps' for multiple loggers, none for nothing""")
+    public String defaultLoggers = "none";
+
+    @Comment("""
+            Enables /distance command to measure in game distance between points
+            Also enables brown carpet placement action if 'carpets' rule is turned on as well""")
+    public boolean commandDistance = true;
+
+    @Comment("""
+            "Enables /info command for blocks
+            Also enables gray carpet placement action if 'carpets' rule is turned on as well""")
+    public boolean commandInfo = true;
+
+    @Comment("""
+            Enables /perimeterinfo command
+            that scans the area around the block for potential spawnable spots""")
+    public boolean commandPerimeterInfo = true;
+
+    @Comment("""
+            Enables /draw commands
+            allows for drawing simple shapes or other shapes which are sorta difficult to do normally""")
+    public boolean commandDraw = true;
+
+    @Comment("Enables /player command to control/spawn players")
+    public boolean commandPlayer = true;
+
+    @Comment("Spawn offline players in online mode if online-mode player with specified name does not exist")
+    public boolean allowSpawningOfflinePlayers = true;
+
+    @Comment("Allows listing fake players on the multiplayer screen")
+    public boolean allowListingFakePlayers = false;
+
+    @Comment("Allows to track mobs AI via /track command")
+    public boolean commandTrackAI = true;
+
+    @Comment("lacing carpets may issue carpet commands for non-op players")
+    public boolean carpets = false;
+
+    @Comment("Glass can be broken faster with pickaxes")
+    public boolean missingTools = false;
+
+    @Comment("fill/clone/setblock and structure blocks cause block updates")
+    public boolean fillUpdates = true;
+
+    @Comment("placing blocks cause block updates")
+    public boolean interactionUpdates = true;
+
+    @Comment("Disables breaking of blocks caused by flowing liquids")
+    public boolean liquidDamageDisabled = false;
+
+    @Validate(PushLimitValidator.class)
+    @Suggestion({"10", "12", "14", "100"})
+    @Comment("Customizable piston push limit")
+    public int pushLimit = PistonStructureResolver.MAX_PUSH_DEPTH;
+
+    @Validate(PushLimitValidator.class)
+    @Suggestion({"9", "15", "30"})
+    @Comment("Customizable powered rail power range")
+    public int railPowerLimit = 9;
+
+    @Validate(ForceloadLimitValidator.class)
+    @Comment("Customizable forceload chunk limit")
+    public int forceloadLimit = 256;
+
+    @Comment("Cactus in dispensers rotates blocks.Rotates block anti-clockwise if possible")
+    public boolean rotatorBlock = false;
+
+    @Comment("""
+            Coral structures will grow with bonemeal from coral plants
+            Expanded also allows growing from coral fans for sustainable farming outside of warm oceans""")
+    public RenewableCoralMode renewableCoral = RenewableCoralMode.FALSE;
+
+    @Comment("Nether basalt generator without soul sand below will convert into blackstone instead")
+    public boolean renewableBlackstone = false;
+
+    @Comment("Lava and water generate deepslate and cobbled deepslate instead below Y0")
+    public boolean renewableDeepslate = false;
+
+    @Comment("fixes block placement rotation issue when player rotates quickly while placing blocks")
+    public boolean placementRotationFix = false;
+
+    @Comment("Spawning requires much less CPU and Memory")
+    public boolean lagFreeSpawning = false;
+
+    @Comment("Increases for testing purposes number of blue skulls shot by the wither")
+    public boolean moreBlueSkulls = false;
+
+    @Comment("""
+            Can allow to phase through walls in creative mode
+            On servers it needs to be set on both client and server to function properly.
+            Needs carpet client. Has no effect when set on the server only.""")
+    public boolean creativeNoClip = false;
+
+    @Validate(StructureBlockLimitValidator.class)
+    @Suggestion({"48", "96", "192", "256"})
+    @Comment("""
+            Customizable structure block limit of each axis
+            WARNING: Needs to be permanent for correct loading.
+            Setting 'structureBlockIgnored' to air is recommended
+            when saving massive structures.
+            Required on client of player editing the Structure Block.
+            'structureBlockOutlineDistance' may be required for
+            correct rendering of long structures.""")
+    public int structureBlockLimit = StructureBlockEntity.MAX_SIZE_PER_AXIS;
+
+    @Validate(StructureBlockIgnoredValidator.class)
+    @Suggestion({"minecraft:structure_void", "minecraft:air"})
+    @Comment("Changes the block ignored by the Structure Block")
+    public String structureBlockIgnored = "minecraft:structure_void";
+
+    @Validate(NonNegativeNumberValidator.class)
+    @Suggestion({"96", "192", "2048"})
+    @Comment("Customizable Structure Block outline render distance, required on client to work properly")
+    public int structureBlockOutlineDistance = 96;
+
+    @Comment("""
+            Lightning kills the items that drop when lightning kills an entity
+            Setting to true will prevent lightning from killing drops
+            Fixes [MC-206922](https://bugs.mojang.com/browse/MC-206922).""")
+    public boolean lightningKillsDropsFix = false;
+
+    @Validate(UpdateSuppressionBlockValidator.class)
+    @Suggestion({"-1", "0", "10", "50"})
+    @Comment("""
+            Placing an activator rail on top of a barrier block will fill the neighbor updater stack when the rail turns off.
+            The integer entered is the amount of updates that should be left in the stack. set to -1 to disable this""")
+    public int updateSuppressionBlock = -1;
+
+    @Comment("""
+            Creative players load chunks, or they don't! Just like spectators!
+            Toggling behaves exactly as if the player is in spectator mode,
+            also toggling the gamerule spectatorsGenerateChunks.""")
+    public boolean creativePlayersLoadChunks = true;
+
+    @Validate(PushLimitValidator.class)
+    @Suggestion({"8", "16", "32"})
+    @Comment("Customizable sculk sensor range")
+    public int sculkSensorRange = 8;
+
+    @Validate(WorldBorderValidator.class)
+    @Comment("""
+            Makes world borders move based on in game time instead of real time
+            This has the effect that when the tick rate changes the world border speed also changes proportional to it""")
+    public boolean tickSyncedWorldBorders = false;
+
+    // refers to "[MC-215169](https://bugs.mojang.com/browse/MC-215169)." - unconfirmed yet that its a java bug
+    @Comment("""
+            Allows to grow nether fungi with 3x3 base with bonemeal
+            Setting to 'all' will make all nether fungi grow into 3x3 trees
+            Setting to 'random' will make 6% of all nether fungi grow into 3x3 trees
+            (this being consistent with worldgen)""")
+    public FungusGrowthMode thickFungusGrowth = FungusGrowthMode.FALSE;
+
+    public static class ShulkerBoxValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue > 0 && newValue <= 64;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 64, but got " + newValue;
+        }
+    }
+
+    public static class TNTRandomRangeValidator extends Validator<Double> {
+        @Override
+        public boolean validate(Double newValue, Double oldValue) {
+            return newValue == -1 || newValue >= 0;
+        }
+
+        @Override
+        public String getErrorMessage(Double newValue) {
+            return "Value can't be negative, or -1, but got " + newValue;
+        }
+    }
+
+    public static class TNTAngleValidator extends Validator<Double> {
+        @Override
+        public boolean validate(Double newValue, Double oldValue) {
+            return (newValue >= 0 && newValue < Math.PI * 2) || newValue == -1;
+        }
+
+        @Override
+        public String getErrorMessage(Double newValue) {
+            return "Value must be a number between 0 and 2Pi(include 0), or -1, but got " + newValue;
+        }
+    }
+
+    public static class QuasiConnectivityValidator extends Validator<Integer> {
+        private int maxRange = 1;
+
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            int minRange = 0;
+            int maxRange = 1;
+
+            if (!MinecraftServer.getServer().isReady()) {
+                maxRange = Integer.MAX_VALUE;
+            } else {
+                for (Level level : MinecraftServer.getServer().getAllLevels()) {
+                    maxRange = Math.max(maxRange, level.getHeight() - 1);
+                }
+            }
+
+            this.maxRange = maxRange;
+
+            return newValue >= minRange && newValue <= maxRange;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 0 to the max level height(now " + maxRange + "), but got " + newValue;
+        }
+    }
+
+
+    public static class PushLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 1 && newValue <= 1024;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 1 to 1024, but got " + newValue;
+        }
+    }
+
+    public static class ForceloadLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 0 && newValue <= 20000000;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a number from 0 to 20M, but got " + newValue;
+        }
+    }
+
+    public static class NonNegativeNumberValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= 0;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "Value should be a non-negative number, but got " + newValue;
+        }
+    }
+
+    public static class StructureBlockLimitValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue >= StructureBlockEntity.MAX_SIZE_PER_AXIS;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "You have to choose a value greater or equal to 48, but got " + newValue;
+        }
+    }
+
+    public static class StructureBlockIgnoredValidator extends Validator<String> {
+        @Override
+        public boolean validate(String newValue, String oldValue) {
+            Optional<Block> ignoredBlock = MinecraftServer.getServer()
+                    .registryAccess()
+                    .registryOrThrow(Registries.BLOCK)
+                    .getOptional(ResourceLocation.tryParse(newValue));
+            if (ignoredBlock.isEmpty()) {
+                return false;
+            }
+            CarpetConfig.structureBlockIgnoredBlock = ignoredBlock.get();
+            return true;
+        }
+
+        @Override
+        public String getErrorMessage(String newValue) {
+            return "Unknown block: " + newValue;
+        }
+    }
+
+    public static class UpdateSuppressionBlockValidator extends Validator<Integer> {
+        @Override
+        public boolean validate(Integer newValue, Integer oldValue) {
+            return newValue < -1;
+        }
+
+        @Override
+        public String getErrorMessage(Integer newValue) {
+            return "This value represents the amount of updates required before the logger logs them. Must be -1 or larger, but got " + newValue;
+        }
+    }
+
+    public static class WorldBorderValidator extends Validator<Boolean> {
+        @Override
+        public boolean validate(@NotNull Boolean newValue, @NotNull Boolean oldValue) {
+            if (oldValue.booleanValue() != newValue.booleanValue()) {
+                // Needed for the update
+                CarpetConfig.configModule.tickSyncedWorldBorders = newValue;
+                for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                    WorldBorder worldBorder = level.getWorldBorder();
+                    if (worldBorder.getStatus() != BorderStatus.STATIONARY) {
+                        double from = worldBorder.getSize();
+                        double to = worldBorder.getLerpTarget();
+                        long time = worldBorder.getLerpRemainingTime();
+                        worldBorder.lerpSizeBetween(from, to, time);
+                    }
+                }
+            }
+            return true;
+        }
+    }
+
+    public enum Lang {
+        zh_cn, zh_tw, en_us, fr_fr, pt_br
+    }
+
+    public enum ChainStoneMode {
+        TRUE, FALSE, STICK_TO_ALL;
+
+        public boolean enabled() {
+            return this != FALSE;
+        }
+    }
+
+    public enum RenewableCoralMode {
+        FALSE, EXPANDED, TRUE
+    }
+
+    public enum FungusGrowthMode {
+        FALSE, RANDOM, ALL
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetServer.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..12c8d360805a73156453056e1e269d8379b43df0
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetServer.java
@@ -0,0 +1,118 @@
+package org.leavesmc.lumina.carpet;
+
+import com.mojang.logging.LogUtils;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.plugin.Plugin;
+import org.leavesmc.lumina.carpet.command.PlayerCommand;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import org.leavesmc.lumina.carpet.logging.HUDController;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.script.utils.ParticleParser;
+import org.leavesmc.lumina.carpet.utils.MobAI;
+import org.leavesmc.lumina.carpet.utils.SpawnReporter;
+import org.slf4j.Logger;
+
+public class CarpetServer {
+    public static Plugin PLUGIN = new MinecraftInternalPlugin();
+    public static final Logger LOGGER = LogUtils.getLogger();
+    // public static final List<CarpetExtension> extensions = new ArrayList<>(); // TODO
+
+    // public static void manageExtension(CarpetExtension extension) {
+    //     extensions.add(extension);
+    //     // Stop the stupid practice of extensions mixing into Carpet just to register themselves
+    //     if (StackWalker.getInstance().walk(stream -> stream.skip(1)
+    //             .anyMatch(el -> el.getClassName() == CarpetServer.class.getName())))
+    //     {
+    //         CarpetSettings.LOG.warn("""
+    //                 Extension '%s' is registering itself using a mixin into Carpet instead of a regular ModInitializer!
+    //                 This is stupid and will crash the game in future versions!""".formatted(extension.getClass().getSimpleName()));
+    //     }
+    // } // TODO
+
+    public static void onGameStarted() {
+        CarpetConfig.setup();
+        // settingsManager = new carpet.settings.SettingsManager(CarpetSettings.carpetVersion, "carpet", "Carpet Mod");
+        // settingsManager.parseSettingsClass(CarpetSettings.class);
+        // extensions.forEach(CarpetExtension::onGameStarted); // TODO
+    }
+
+    public static void onServerLoaded(MinecraftServer server) {
+        // should not be needed - that bit needs refactoring, but not now.
+        SpawnReporter.resetSpawnStats(server, true);
+
+        // forEachManager(sm -> sm.attachServer(server));
+        // extensions.forEach(e -> e.onServerLoaded(server)); // TODO
+        MobAI.resetTrackers();
+        LoggerRegistry.initLoggers();
+    }
+
+    public static void onServerLoadedWorlds(MinecraftServer server) {
+        HopperCounter.resetAll(server, true);
+        // extensions.forEach(e -> e.onServerLoadedWorlds(server)); // TODO
+    }
+
+    public static void tick(MinecraftServer server) {
+        HUDController.update_hud(server, null);
+
+        // //in case something happens
+        // CarpetSettings.impendingFillSkipUpdates.set(false); // I REALLY DON'T KNOW WHAT'S THIS
+
+        // extensions.forEach(e -> e.onTick(server)); // TODO
+    }
+
+    public static void registerCarpetCommands() {
+        if (CarpetConfig.configModule == null) {
+            return;
+        }
+        PlayerCommand.register();
+    }
+
+    public static void onPlayerLoggedIn(ServerPlayer player) {
+        LoggerRegistry.playerConnected(player);
+        // extensions.forEach(e -> e.onPlayerLoggedIn(player)); // TODO
+    }
+
+    public static void onPlayerLoggedOut(ServerPlayer player, Component reason) {
+        LoggerRegistry.playerDisconnected(player);
+        // extensions.forEach(e -> e.onPlayerLoggedOut(player)); // TODO
+    }
+
+    public static void onServerClosed(MinecraftServer server) {
+        LoggerRegistry.stopLoggers();
+        HUDController.resetScarpetHUDs();
+        ParticleParser.resetCache();
+        // extensions.forEach(e -> e.onServerClosed(server)); // TODO
+    }
+
+    // not API
+    // carpet's included
+    // public static void forEachManager(Consumer<SettingsManager> consumer) {
+    //     consumer.accept(settingsManager);
+    //     for (CarpetExtension e : extensions) {
+    //         SettingsManager manager = e.extensionSettingsManager();
+    //         if (manager != null) {
+    //             consumer.accept(manager);
+    //         }
+    //     }
+    // } // TODO
+
+    public static void registerExtensionLoggers() {
+        // extensions.forEach(CarpetExtension::registerLoggers); // TODO
+    }
+
+    public static void onReload(MinecraftServer server) {
+        // extensions.forEach(e -> e.onReload(server)); // TODO
+    }
+
+    // private static final Set<CarpetExtension> warnedOutdatedManagerProviders = new HashSet<>(); // TODO
+
+    // static void warnOutdatedManager(CarpetExtension ext) {
+    //     if (warnedOutdatedManagerProviders.add(ext))
+    //         CarpetSettings.LOG.warn("""
+    //                 %s is providing a SettingsManager from an outdated method in CarpetExtension!
+    //                 This behaviour will not work in later Carpet versions and the manager won't be registered!""".formatted(ext.getClass().getName()));
+    // } // TODO
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..819b5499d1b78c4df5114b3facdce09c3b6ff535
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/PlayerCommand.java
@@ -0,0 +1,146 @@
+package org.leavesmc.lumina.carpet.command;
+
+import com.mojang.authlib.GameProfile;
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import dev.jorel.commandapi.executors.CommandArguments;
+import dev.jorel.commandapi.wrappers.Rotation;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.Level;
+import org.bukkit.*;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.permissions.ServerOperator;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake;
+
+import java.util.Arrays;
+
+import static org.leavesmc.lumina.LuminaCommand.*;
+
+public class PlayerCommand {
+    public static void register() {
+        SpawnCommand.register();
+    }
+
+    private static class SpawnCommand {
+        public static void register() {
+            createBase("spawn").withOptionalArguments(
+                    new LiteralArgument("at").combineWith(new LocationArgument("position")),
+                    new LiteralArgument("facing").combineWith(new RotationArgument("direction")),
+                    new LiteralArgument("in").combineWith(new WorldArgument("dimension")),
+                    new LiteralArgument("in")
+                            .withRequirement(ServerOperator::isOp)
+                            .combineWith(new MultiLiteralArgument("gamemode", Arrays
+                                    .stream(GameType.values())
+                                    .map(GameType::name)
+                                    .toArray(String[]::new)))
+            ).executes(SpawnCommand::spawn).register("carpet");
+        }
+
+        private static boolean canSpawn(CommandSender sender, @NotNull CommandArguments args) {
+            String playerName = (String) args.get("player");
+            if (playerName == null) {
+                sendError(sender, "Invalid player name");
+                return false;
+            }
+            MinecraftServer server = MinecraftServer.getServer();
+            PlayerList manager = server.getPlayerList();
+
+            if (manager.getPlayerByName(playerName) != null) {
+                sendInfo(sender, "r Player rb " + playerName + "r  is already logged on");
+                return false;
+            }
+            @SuppressWarnings("DataFlowIssue") GameProfile profile = server.getProfileCache().get(playerName).orElse(null);
+            if (profile == null) {
+                if (!CarpetConfig.configModule.allowSpawningOfflinePlayers) {
+                    sendInfo(sender, "r Player " + playerName + " is either banned by Mojang, or auth servers are down. Banned players can only be summoned in Singleplayer and in servers in off-line mode.");
+                    return false;
+                } else {
+                    profile = new GameProfile(UUIDUtil.createOfflinePlayerUUID(playerName), playerName);
+                }
+            }
+            if (manager.getBans().isBanned(profile)) {
+                sendInfo(sender, "r Player rb " + playerName + "r  is banned on this server");
+                return false;
+            }
+            if (manager.isUsingWhitelist() && manager.isWhiteListed(profile) && !sender.isOp()) {
+                sendInfo(sender, "r Whitelisted players can only be spawned by operators");
+                return false;
+            }
+            return true;
+        }
+
+        @SuppressWarnings("UnusedReturnValue")
+        private static boolean spawn(CommandSender sender, CommandArguments args) {
+            if (!canSpawn(sender, args)) {
+                return false;
+            }
+            Location pos = null;
+            Rotation facing = new Rotation(0, 0);
+            World world = Bukkit.getWorld(new NamespacedKey("minecraft", "overworld"));
+            GameType mode = GameType.CREATIVE;
+            boolean flying = false;
+            if (sender instanceof Player player) {
+                ServerPlayer serverPlayer = (ServerPlayer) sender;
+                pos = player.getLocation();
+                facing = new Rotation(player.getLocation().getYaw(), player.getLocation().getPitch());
+                world = player.getWorld();
+                mode = serverPlayer.gameMode.getGameModeForPlayer();
+                flying = serverPlayer.getAbilities().flying;
+            }
+            pos = (Location) args.getOrDefault("position", pos);
+            facing = (Rotation) args.getOrDefault("direction", facing);
+            world = (World) args.getOrDefault("dimension", world);
+            if (pos == null) {
+                sendError(sender, "Need position to spawn player in console.");
+                return false;
+            }
+            GameMode nullableGameMode = (GameMode) args.get("gamemode");
+            if (nullableGameMode != null) {
+                mode = GameType.byId(nullableGameMode.getValue());
+            }
+
+            if (mode == GameType.SPECTATOR) {
+                // Force override flying to true for spectator players, or they will fell out of the world.
+                flying = true;
+            } else if (mode.isSurvival()) {
+                // Force override flying to false for survival-like players, or they will fly too
+                flying = false;
+            }
+            String playerName = (String) args.get("player");
+            // noinspection DataFlowIssue
+            if (playerName.length() > SharedConstants.MAX_PLAYER_NAME_LENGTH) {
+                sendInfo(sender, "rb Player name: " + playerName + " is too long");
+                return false;
+            }
+
+            if (!Level.isInSpawnableBounds(BlockPos.containing(pos.getX(), pos.getY(), pos.getZ()))) {
+                sendInfo(sender, "rb Player " + playerName + " cannot be placed outside of the world");
+                return false;
+            }
+            boolean success = EntityPlayerMPFake.createFake(playerName, MinecraftServer.getServer(), pos, facing.getPitch(), facing.getYaw(), world, mode, flying);
+            if (!success) {
+                sendInfo(sender, "rb Player " + playerName + " doesn't exist and cannot spawn in online mode. Turn the server offline or the allowSpawningOfflinePlayers on to spawn non-existing players");
+                return false;
+            }
+            return true;
+        }
+    }
+
+    private static CommandAPICommand createBase(String literal) {
+        return new CommandAPICommand("player")
+                .withPermission("carpet.command.player")
+                .withArguments(
+                        new StringArgument("player"),
+                        new LiteralArgument(literal)
+                );
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/BlockRotator.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/BlockRotator.java
new file mode 100644
index 0000000000000000000000000000000000000000..e247ef47b5a0b42922a2239801f8963c2f26b075
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/BlockRotator.java
@@ -0,0 +1,164 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.dispenser.BlockSource;
+import net.minecraft.core.dispenser.DispenseItemBehavior;
+import net.minecraft.core.dispenser.OptionalDispenseItemBehavior;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.BaseRailBlock;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.DirectionalBlock;
+import net.minecraft.world.level.block.DispenserBlock;
+import net.minecraft.world.level.block.EndRodBlock;
+import net.minecraft.world.level.block.HopperBlock;
+import net.minecraft.world.level.block.HorizontalDirectionalBlock;
+import net.minecraft.world.level.block.ObserverBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.piston.PistonBaseBlock;
+import net.minecraft.world.level.block.piston.PistonStructureResolver;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+public class BlockRotator {
+    public static boolean flipBlockWithCactus(BlockState state, Level world, Player player, InteractionHand hand, BlockHitResult hit) {
+        if (!player.getAbilities().mayBuild || !CarpetConfig.configModule.flippinCactus || !playerHoldsCactusMainhand(player)) {
+            return false;
+        }
+        CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.set(true);
+        boolean retval = flipBlock(state, world, player, hand, hit);
+        CarpetConfig.IMPENDING_FILL_SKIP_UPDATES.set(false);
+        return retval;
+    }
+
+    public static ItemStack dispenserRotate(BlockSource source, ItemStack stack) {
+        Direction sourceFace = source.state().getValue(DispenserBlock.FACING);
+        Level world = source.level();
+        BlockPos blockpos = source.pos().relative(sourceFace); // offset
+        BlockState blockstate = world.getBlockState(blockpos);
+        Block block = blockstate.getBlock();
+
+        // Block rotation for blocks that can be placed in all 6 or 4 rotations.
+        if (block instanceof DirectionalBlock || block instanceof DispenserBlock) {
+            Direction face = blockstate.getValue(DirectionalBlock.FACING);
+            if (block instanceof PistonBaseBlock baseBlock && (
+                    blockstate.getValue(PistonBaseBlock.EXTENDED)
+                            || (baseBlock.publicShouldExtend(world, blockpos, face) && (new PistonStructureResolver(world, blockpos, face, true)).resolve())
+            )
+            ) {
+                return stack;
+            }
+
+            Direction rotatedFace = face.getClockWise(sourceFace.getAxis());
+            if (sourceFace.get3DDataValue() % 2 == 0 || rotatedFace == face) {   // Flip to make blocks always rotate clockwise relative to the dispenser
+                // when index is equal to zero. when index is equal to zero the dispenser is in the opposite direction.
+                rotatedFace = rotatedFace.getOpposite();
+            }
+            world.setBlock(blockpos, blockstate.setValue(DirectionalBlock.FACING, rotatedFace), 3);
+        } else if (block instanceof HorizontalDirectionalBlock) // Block rotation for blocks that can be placed in only 4 horizontal rotations.
+        {
+            if (block instanceof BedBlock)
+                return stack;
+            Direction face = blockstate.getValue(HorizontalDirectionalBlock.FACING).getClockWise(Direction.Axis.Y);
+
+            if (sourceFace == Direction.DOWN) { // same as above.
+                face = face.getOpposite();
+            }
+            world.setBlock(blockpos, blockstate.setValue(HorizontalDirectionalBlock.FACING, face), 3);
+        } else if (block == Blocks.HOPPER) {
+            Direction face = blockstate.getValue(HopperBlock.FACING);
+            if (face != Direction.DOWN) {
+                face = face.getClockWise(Direction.Axis.Y);
+                world.setBlock(blockpos, blockstate.setValue(HopperBlock.FACING, face), 3);
+            }
+        }
+        // Send block update to the block that just have been rotated.
+        world.neighborChanged(blockpos, block, source.pos());
+
+        return stack;
+    }
+
+    public static boolean flipBlock(BlockState state, Level world, Player player, InteractionHand hand, BlockHitResult hit) {
+        Block block = state.getBlock();
+        BlockPos pos = hit.getBlockPos();
+        Vec3 hitVec = hit.getLocation().subtract(pos.getX(), pos.getY(), pos.getZ());
+        Direction facing = hit.getDirection();
+        BlockState newState = null;
+        if ((block instanceof HorizontalDirectionalBlock || block instanceof BaseRailBlock) && !(block instanceof BedBlock)) {
+            newState = state.rotate(Rotation.CLOCKWISE_90);
+        } else if (block instanceof ObserverBlock || block instanceof EndRodBlock) {
+            newState = state.setValue(DirectionalBlock.FACING, state.getValue(DirectionalBlock.FACING).getOpposite());
+        } else if (block instanceof DispenserBlock) {
+            newState = state.setValue(DispenserBlock.FACING, state.getValue(DispenserBlock.FACING).getOpposite());
+        } else if (block instanceof PistonBaseBlock) {
+            if (!(state.getValue(PistonBaseBlock.EXTENDED)))
+                newState = state.setValue(DirectionalBlock.FACING, state.getValue(DirectionalBlock.FACING).getOpposite());
+        } else if (block instanceof SlabBlock) {
+            if (state.getValue(SlabBlock.TYPE) != SlabType.DOUBLE) {
+                newState = state.setValue(SlabBlock.TYPE, state.getValue(SlabBlock.TYPE) == SlabType.TOP ? SlabType.BOTTOM : SlabType.TOP);
+            }
+        } else if (block instanceof HopperBlock) {
+            if (state.getValue(HopperBlock.FACING) != Direction.DOWN) {
+                newState = state.setValue(HopperBlock.FACING, state.getValue(HopperBlock.FACING).getClockWise());
+            }
+        } else if (block instanceof StairBlock) {
+            if ((facing == Direction.UP && hitVec.y == 1.0f) || (facing == Direction.DOWN && hitVec.y == 0.0f)) {
+                newState = state.setValue(StairBlock.HALF, state.getValue(StairBlock.HALF) == Half.TOP ? Half.BOTTOM : Half.TOP);
+            } else {
+                boolean turnCounterClockwise = switch (facing) {
+                    case NORTH -> (hitVec.x <= 0.5);
+                    case SOUTH -> !(hitVec.x <= 0.5);
+                    case EAST -> (hitVec.z <= 0.5);
+                    case WEST -> !(hitVec.z <= 0.5);
+                    default -> false;
+                };
+                newState = state.rotate(turnCounterClockwise ? Rotation.COUNTERCLOCKWISE_90 : Rotation.CLOCKWISE_90);
+            }
+        } else if (block instanceof RotatedPillarBlock) {
+            newState = state.setValue(RotatedPillarBlock.AXIS, switch (state.getValue(RotatedPillarBlock.AXIS)) {
+                case X -> Direction.Axis.Z;
+                case Y -> Direction.Axis.X;
+                case Z -> Direction.Axis.Y;
+            });
+        }
+        if (newState != null) {
+            world.setBlock(pos, newState, Block.UPDATE_CLIENTS | 1024); // no constant matching 1024 in Block, what does this do?
+            world.setBlocksDirty(pos, state, newState);
+            return true;
+        }
+        return false;
+    }
+
+    private static boolean playerHoldsCactusMainhand(Player playerIn) {
+        return playerIn.getMainHandItem().getItem() == Items.CACTUS;
+    }
+
+    public static boolean flippinEligibility(Entity entity) {
+        return CarpetConfig.configModule.flippinCactus && entity instanceof Player p && p.getOffhandItem().getItem() == Items.CACTUS;
+    }
+
+    public static class CactusDispenserBehaviour extends OptionalDispenseItemBehavior implements DispenseItemBehavior {
+        @Override
+        protected ItemStack execute(BlockSource source, ItemStack stack) {
+            if (CarpetConfig.configModule.rotatorBlock) {
+                return BlockRotator.dispenserRotate(source, stack);
+            } else {
+                return super.execute(source, stack);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/CarpetTaintedList.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/CarpetTaintedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0eb90b1f501d9d702d9d08e09ba7c0e2108fba2
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/CarpetTaintedList.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class CarpetTaintedList<E> extends ArrayList<E>
+{
+    public CarpetTaintedList(final List<E> list)
+    {
+        super(list);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/EntityPlayerActionPack.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/EntityPlayerActionPack.java
new file mode 100644
index 0000000000000000000000000000000000000000..78bc4d132897569238d12fe5b3a7bef61466667b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/EntityPlayerActionPack.java
@@ -0,0 +1,543 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake;
+import net.minecraft.commands.arguments.EntityAnchorArgument;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.protocol.game.ClientboundSetCarriedItemPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.horse.AbstractHorse;
+import net.minecraft.world.entity.decoration.ItemFrame;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.entity.vehicle.Boat;
+import net.minecraft.world.entity.vehicle.Minecart;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.script.utils.Tracer;
+
+public class EntityPlayerActionPack {
+    private final ServerPlayer player;
+
+    private final Map<ActionType, Action> actions = new EnumMap<>(ActionType.class);
+
+    private BlockPos currentBlock;
+    private int blockHitDelay;
+    private boolean isHittingBlock;
+    private float curBlockDamageMP;
+
+    private boolean sneaking;
+    private boolean sprinting;
+    private float forward;
+    private float strafing;
+
+    private int itemUseCooldown;
+
+    public EntityPlayerActionPack(ServerPlayer playerIn) {
+        player = playerIn;
+        stopAll();
+    }
+
+    public void copyFrom(EntityPlayerActionPack other) {
+        actions.putAll(other.actions);
+        currentBlock = other.currentBlock;
+        blockHitDelay = other.blockHitDelay;
+        isHittingBlock = other.isHittingBlock;
+        curBlockDamageMP = other.curBlockDamageMP;
+
+        sneaking = other.sneaking;
+        sprinting = other.sprinting;
+        forward = other.forward;
+        strafing = other.strafing;
+
+        itemUseCooldown = other.itemUseCooldown;
+    }
+
+    public EntityPlayerActionPack start(ActionType type, Action action) {
+        Action previous = actions.remove(type);
+        if (previous != null) type.stop(player, previous);
+        if (action != null) {
+            actions.put(type, action);
+            type.start(player, action); // noop
+        }
+        return this;
+    }
+
+    public EntityPlayerActionPack setSneaking(boolean doSneak) {
+        sneaking = doSneak;
+        player.setShiftKeyDown(doSneak);
+        if (sprinting && sneaking)
+            setSprinting(false);
+        return this;
+    }
+
+    public EntityPlayerActionPack setSprinting(boolean doSprint) {
+        sprinting = doSprint;
+        player.setSprinting(doSprint);
+        if (sneaking && sprinting)
+            setSneaking(false);
+        return this;
+    }
+
+    public EntityPlayerActionPack setForward(float value) {
+        forward = value;
+        return this;
+    }
+
+    public EntityPlayerActionPack setStrafing(float value) {
+        strafing = value;
+        return this;
+    }
+
+    public EntityPlayerActionPack look(Direction direction) {
+        return switch (direction) {
+            case NORTH -> look(180, 0);
+            case SOUTH -> look(0, 0);
+            case EAST -> look(-90, 0);
+            case WEST -> look(90, 0);
+            case UP -> look(player.getYRot(), -90);
+            case DOWN -> look(player.getYRot(), 90);
+        };
+    }
+
+    public EntityPlayerActionPack look(Vec2 rotation) {
+        return look(rotation.x, rotation.y);
+    }
+
+    public EntityPlayerActionPack look(float yaw, float pitch) {
+        player.setYRot(yaw % 360); // setYaw
+        player.setXRot(Mth.clamp(pitch, -90, 90)); // setPitch
+        // maybe player.moveTo(player.getX(), player.getY(), player.getZ(), yaw, Mth.clamp(pitch,-90.0F, 90.0F));
+        return this;
+    }
+
+    public EntityPlayerActionPack lookAt(Vec3 position) {
+        player.lookAt(EntityAnchorArgument.Anchor.EYES, position);
+        return this;
+    }
+
+    public EntityPlayerActionPack turn(float yaw, float pitch) {
+        return look(player.getYRot() + yaw, player.getXRot() + pitch);
+    }
+
+    public EntityPlayerActionPack turn(Vec2 rotation) {
+        return turn(rotation.x, rotation.y);
+    }
+
+    public EntityPlayerActionPack stopMovement() {
+        setSneaking(false);
+        setSprinting(false);
+        forward = 0.0F;
+        strafing = 0.0F;
+        return this;
+    }
+
+
+    public EntityPlayerActionPack stopAll() {
+        for (ActionType type : actions.keySet()) type.stop(player, actions.get(type));
+        actions.clear();
+        return stopMovement();
+    }
+
+    public EntityPlayerActionPack mount(boolean onlyRideables) {
+        // test what happens
+        List<Entity> entities;
+        if (onlyRideables) {
+            entities = player.level().getEntities(player, player.getBoundingBox().inflate(3.0D, 1.0D, 3.0D),
+                    e -> e instanceof Minecart || e instanceof Boat || e instanceof AbstractHorse);
+        } else {
+            entities = player.level().getEntities(player, player.getBoundingBox().inflate(3.0D, 1.0D, 3.0D));
+        }
+        if (entities.size() == 0)
+            return this;
+        Entity closest = null;
+        double distance = Double.POSITIVE_INFINITY;
+        Entity currentVehicle = player.getVehicle();
+        for (Entity e : entities) {
+            if (e == player || (currentVehicle == e))
+                continue;
+            double dd = player.distanceToSqr(e);
+            if (dd < distance) {
+                distance = dd;
+                closest = e;
+            }
+        }
+        if (closest == null) return this;
+        if (closest instanceof AbstractHorse && onlyRideables)
+            ((AbstractHorse) closest).mobInteract(player, InteractionHand.MAIN_HAND);
+        else
+            player.startRiding(closest, true);
+        return this;
+    }
+
+    public EntityPlayerActionPack dismount() {
+        player.stopRiding();
+        return this;
+    }
+
+    public void onUpdate() {
+        Map<ActionType, Boolean> actionAttempts = new HashMap<>();
+        actions.values().removeIf(e -> e.done);
+        for (Map.Entry<ActionType, Action> e : actions.entrySet()) {
+            ActionType type = e.getKey();
+            Action action = e.getValue();
+            // skipping attack if use was successful
+            if (!(actionAttempts.getOrDefault(ActionType.USE, false) && type == ActionType.ATTACK)) {
+                Boolean actionStatus = action.tick(this, type);
+                if (actionStatus != null)
+                    actionAttempts.put(type, actionStatus);
+            }
+            // optionally retrying use after successful attack and unsuccessful use
+            if (type == ActionType.ATTACK
+                    && actionAttempts.getOrDefault(ActionType.ATTACK, false)
+                    && !actionAttempts.getOrDefault(ActionType.USE, true)) {
+                // according to MinecraftClient.handleInputEvents
+                Action using = actions.get(ActionType.USE);
+                if (using != null) // this is always true - we know use worked, but just in case
+                {
+                    using.retry(this, ActionType.USE);
+                }
+            }
+        }
+        float vel = sneaking ? 0.3F : 1.0F;
+        // The != 0.0F checks are needed given else real players can't control minecarts, however it works with fakes and else they don't stop immediately
+        if (forward != 0.0F || player instanceof EntityPlayerMPFake) {
+            player.zza = forward * vel;
+        }
+        if (strafing != 0.0F || player instanceof EntityPlayerMPFake) {
+            player.xxa = strafing * vel;
+        }
+    }
+
+    static HitResult getTarget(ServerPlayer player) {
+        double reach = player.gameMode.isCreative() ? 5 : 4.5f;
+        return Tracer.rayTrace(player, 1, reach, false);
+    }
+
+    private void dropItemFromSlot(int slot, boolean dropAll) {
+        Inventory inv = player.getInventory(); // getInventory;
+        if (!inv.getItem(slot).isEmpty())
+            player.drop(inv.removeItem(slot,
+                    dropAll ? inv.getItem(slot).getCount() : 1
+            ), false, true); // scatter, keep owner
+    }
+
+    public void drop(int selectedSlot, boolean dropAll) {
+        Inventory inv = player.getInventory(); // getInventory;
+        if (selectedSlot == -2) // all
+        {
+            for (int i = inv.getContainerSize(); i >= 0; i--)
+                dropItemFromSlot(i, dropAll);
+        } else // one slot
+        {
+            if (selectedSlot == -1)
+                selectedSlot = inv.selected;
+            dropItemFromSlot(selectedSlot, dropAll);
+        }
+    }
+
+    public void setSlot(int slot) {
+        player.getInventory().selected = slot - 1;
+        player.connection.send(new ClientboundSetCarriedItemPacket(slot - 1));
+    }
+
+    public enum ActionType {
+        USE(true) {
+            @Override
+            boolean execute(ServerPlayer player, Action action) {
+                EntityPlayerActionPack ap = player.getActionPack();
+                if (ap.itemUseCooldown > 0) {
+                    ap.itemUseCooldown--;
+                    return true;
+                }
+                if (player.isUsingItem()) {
+                    return true;
+                }
+                HitResult hit = getTarget(player);
+                for (InteractionHand hand : InteractionHand.values()) {
+                    switch (hit.getType()) {
+                        case BLOCK: {
+                            player.resetLastActionTime();
+                            ServerLevel world = player.serverLevel();
+                            BlockHitResult blockHit = (BlockHitResult) hit;
+                            BlockPos pos = blockHit.getBlockPos();
+                            Direction side = blockHit.getDirection();
+                            if (pos.getY() < player.level().getMaxBuildHeight() - (side == Direction.UP ? 1 : 0) && world.mayInteract(player, pos)) {
+                                InteractionResult result = player.gameMode.useItemOn(player, world, player.getItemInHand(hand), hand, blockHit);
+                                if (result.consumesAction()) {
+                                    if (result.shouldSwing()) player.swing(hand);
+                                    ap.itemUseCooldown = 3;
+                                    return true;
+                                }
+                            }
+                            break;
+                        }
+                        case ENTITY: {
+                            player.resetLastActionTime();
+                            EntityHitResult entityHit = (EntityHitResult) hit;
+                            Entity entity = entityHit.getEntity();
+                            boolean handWasEmpty = player.getItemInHand(hand).isEmpty();
+                            boolean itemFrameEmpty = (entity instanceof ItemFrame) && ((ItemFrame) entity).getItem().isEmpty();
+                            Vec3 relativeHitPos = entityHit.getLocation().subtract(entity.getX(), entity.getY(), entity.getZ());
+                            if (entity.interactAt(player, relativeHitPos, hand).consumesAction()) {
+                                ap.itemUseCooldown = 3;
+                                return true;
+                            }
+                            // fix for SS itemframe always returns CONSUME even if no action is performed
+                            if (player.interactOn(entity, hand).consumesAction() && !(handWasEmpty && itemFrameEmpty)) {
+                                ap.itemUseCooldown = 3;
+                                return true;
+                            }
+                            break;
+                        }
+                    }
+                    ItemStack handItem = player.getItemInHand(hand);
+                    if (player.gameMode.useItem(player, player.level(), handItem, hand).consumesAction()) {
+                        ap.itemUseCooldown = 3;
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            @Override
+            void inactiveTick(ServerPlayer player, Action action) {
+                EntityPlayerActionPack ap = player.getActionPack();
+                ap.itemUseCooldown = 0;
+                player.releaseUsingItem();
+            }
+        },
+        ATTACK(true) {
+            @Override
+            boolean execute(ServerPlayer player, Action action) {
+                HitResult hit = getTarget(player);
+                switch (hit.getType()) {
+                    case ENTITY: {
+                        EntityHitResult entityHit = (EntityHitResult) hit;
+                        if (!action.isContinuous) {
+                            player.attack(entityHit.getEntity());
+                            player.swing(InteractionHand.MAIN_HAND);
+                        }
+                        player.resetAttackStrengthTicker();
+                        player.resetLastActionTime();
+                        return true;
+                    }
+                    case BLOCK: {
+                        EntityPlayerActionPack ap = player.getActionPack();
+                        if (ap.blockHitDelay > 0) {
+                            ap.blockHitDelay--;
+                            return false;
+                        }
+                        BlockHitResult blockHit = (BlockHitResult) hit;
+                        BlockPos pos = blockHit.getBlockPos();
+                        Direction side = blockHit.getDirection();
+                        if (player.blockActionRestricted(player.level(), pos, player.gameMode.getGameModeForPlayer()))
+                            return false;
+                        if (ap.currentBlock != null && player.level().getBlockState(ap.currentBlock).isAir()) {
+                            ap.currentBlock = null;
+                            return false;
+                        }
+                        BlockState state = player.level().getBlockState(pos);
+                        boolean blockBroken = false;
+                        if (player.gameMode.getGameModeForPlayer().isCreative()) {
+                            player.gameMode.handleBlockBreakAction(pos, ServerboundPlayerActionPacket.Action.START_DESTROY_BLOCK, side, player.level().getMaxBuildHeight(), -1);
+                            ap.blockHitDelay = 5;
+                            blockBroken = true;
+                        } else if (ap.currentBlock == null || !ap.currentBlock.equals(pos)) {
+                            if (ap.currentBlock != null) {
+                                player.gameMode.handleBlockBreakAction(ap.currentBlock, ServerboundPlayerActionPacket.Action.ABORT_DESTROY_BLOCK, side, player.level().getMaxBuildHeight(), -1);
+                            }
+                            player.gameMode.handleBlockBreakAction(pos, ServerboundPlayerActionPacket.Action.START_DESTROY_BLOCK, side, player.level().getMaxBuildHeight(), -1);
+                            boolean notAir = !state.isAir();
+                            if (notAir && ap.curBlockDamageMP == 0) {
+                                state.attack(player.level(), pos, player);
+                            }
+                            if (notAir && state.getDestroyProgress(player, player.level(), pos) >= 1) {
+                                ap.currentBlock = null;
+                                // instamine??
+                                blockBroken = true;
+                            } else {
+                                ap.currentBlock = pos;
+                                ap.curBlockDamageMP = 0;
+                            }
+                        } else {
+                            ap.curBlockDamageMP += state.getDestroyProgress(player, player.level(), pos);
+                            if (ap.curBlockDamageMP >= 1) {
+                                player.gameMode.handleBlockBreakAction(pos, ServerboundPlayerActionPacket.Action.STOP_DESTROY_BLOCK, side, player.level().getMaxBuildHeight(), -1);
+                                ap.currentBlock = null;
+                                ap.blockHitDelay = 5;
+                                blockBroken = true;
+                            }
+                            player.level().destroyBlockProgress(-1, pos, (int) (ap.curBlockDamageMP * 10));
+
+                        }
+                        player.resetLastActionTime();
+                        player.swing(InteractionHand.MAIN_HAND);
+                        return blockBroken;
+                    }
+                }
+                return false;
+            }
+
+            @Override
+            void inactiveTick(ServerPlayer player, Action action) {
+                EntityPlayerActionPack ap = player.getActionPack();
+                if (ap.currentBlock == null) return;
+                player.level().destroyBlockProgress(-1, ap.currentBlock, -1);
+                player.gameMode.handleBlockBreakAction(ap.currentBlock, ServerboundPlayerActionPacket.Action.ABORT_DESTROY_BLOCK, Direction.DOWN, player.level().getMaxBuildHeight(), -1);
+                ap.currentBlock = null;
+            }
+        },
+        JUMP(true) {
+            @Override
+            boolean execute(ServerPlayer player, Action action) {
+                if (action.limit == 1) {
+                    if (player.onGround()) player.jumpFromGround(); // onGround
+                } else {
+                    player.setJumping(true);
+                }
+                return false;
+            }
+
+            @Override
+            void inactiveTick(ServerPlayer player, Action action) {
+                player.setJumping(false);
+            }
+        },
+        DROP_ITEM(true) {
+            @Override
+            boolean execute(ServerPlayer player, Action action) {
+                player.resetLastActionTime();
+                player.drop(false); // dropSelectedItem
+                return false;
+            }
+        },
+        DROP_STACK(true) {
+            @Override
+            boolean execute(ServerPlayer player, Action action) {
+                player.resetLastActionTime();
+                player.drop(true); // dropSelectedItem
+                return false;
+            }
+        },
+        SWAP_HANDS(true) {
+            @Override
+            boolean execute(ServerPlayer player, Action action) {
+                player.resetLastActionTime();
+                ItemStack itemStack_1 = player.getItemInHand(InteractionHand.OFF_HAND);
+                player.setItemInHand(InteractionHand.OFF_HAND, player.getItemInHand(InteractionHand.MAIN_HAND));
+                player.setItemInHand(InteractionHand.MAIN_HAND, itemStack_1);
+                return false;
+            }
+        };
+
+        public final boolean preventSpectator;
+
+        ActionType(boolean preventSpectator) {
+            this.preventSpectator = preventSpectator;
+        }
+
+        void start(ServerPlayer player, Action action) {
+        }
+
+        abstract boolean execute(ServerPlayer player, Action action);
+
+        void inactiveTick(ServerPlayer player, Action action) {
+        }
+
+        void stop(ServerPlayer player, Action action) {
+            inactiveTick(player, action);
+        }
+    }
+
+    public static class Action {
+        public boolean done = false;
+        public final int limit;
+        public final int interval;
+        public final int offset;
+        private int count;
+        private int next;
+        private final boolean isContinuous;
+
+        private Action(int limit, int interval, int offset, boolean continuous) {
+            this.limit = limit;
+            this.interval = interval;
+            this.offset = offset;
+            next = interval + offset;
+            isContinuous = continuous;
+        }
+
+        public static Action once() {
+            return new Action(1, 1, 0, false);
+        }
+
+        public static Action continuous() {
+            return new Action(-1, 1, 0, true);
+        }
+
+        public static Action interval(int interval) {
+            return new Action(-1, interval, 0, false);
+        }
+
+        public static Action interval(int interval, int offset) {
+            return new Action(-1, interval, offset, false);
+        }
+
+        Boolean tick(EntityPlayerActionPack actionPack, ActionType type) {
+            next--;
+            Boolean cancel = null;
+            if (next <= 0) {
+                if (interval == 1 && !isContinuous) {
+                    // need to allow entity to tick, otherwise won't have effect (bow)
+                    // actions are 20 tps, so need to clear status mid tick, allowing entities process it till next time
+                    if (!type.preventSpectator || !actionPack.player.isSpectator()) {
+                        type.inactiveTick(actionPack.player, this);
+                    }
+                }
+
+                if (!type.preventSpectator || !actionPack.player.isSpectator()) {
+                    cancel = type.execute(actionPack.player, this);
+                }
+                count++;
+                if (count == limit) {
+                    type.stop(actionPack.player, null);
+                    done = true;
+                    return cancel;
+                }
+                next = interval;
+            } else {
+                if (!type.preventSpectator || !actionPack.player.isSpectator()) {
+                    type.inactiveTick(actionPack.player, this);
+                }
+            }
+            return cancel;
+        }
+
+        void retry(EntityPlayerActionPack actionPack, ActionType type) {
+            // assuming action run but was unsuccesful that tick, but opportunity emerged to retry it, lets retry it.
+            if (!type.preventSpectator || !actionPack.player.isSpectator()) {
+                type.execute(actionPack.player, this);
+            }
+            count++;
+            if (count == limit) {
+                type.stop(actionPack.player, null);
+                done = true;
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/FertilizableCoral.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/FertilizableCoral.java
new file mode 100644
index 0000000000000000000000000000000000000000..53b275c250d97f5595e27fdc6fc6f24cdd5be029
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/FertilizableCoral.java
@@ -0,0 +1,77 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.HolderSet;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.level.block.BaseCoralPlantTypeBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.BonemealableBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.levelgen.feature.CoralClawFeature;
+import net.minecraft.world.level.levelgen.feature.CoralFeature;
+import net.minecraft.world.level.levelgen.feature.CoralMushroomFeature;
+import net.minecraft.world.level.levelgen.feature.CoralTreeFeature;
+import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
+import net.minecraft.world.level.material.MapColor;
+
+/**
+ * Deduplicates logic for the different behaviors of the {@code renewableCoral} rule
+ */
+public interface FertilizableCoral extends BonemealableBlock {
+    /**
+     * @return Whether the rule for this behavior is enabled
+     */
+    boolean isEnabled();
+
+    @Override
+    public default boolean isValidBonemealTarget(LevelReader world, BlockPos pos, BlockState state) {
+        return isEnabled()
+                && state.getValue(BaseCoralPlantTypeBlock.WATERLOGGED)
+                && world.getFluidState(pos.above()).is(FluidTags.WATER);
+    }
+
+    @Override
+    public default boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return random.nextFloat() < 0.15D;
+    }
+
+    @Override
+    public default void performBonemeal(ServerLevel worldIn, RandomSource random, BlockPos pos, BlockState blockUnder) {
+        int variant = random.nextInt(3);
+        CoralFeature coral = switch (variant) {
+            case 0 -> new CoralClawFeature(NoneFeatureConfiguration.CODEC);
+            case 1 -> new CoralTreeFeature(NoneFeatureConfiguration.CODEC);
+            default -> new CoralMushroomFeature(NoneFeatureConfiguration.CODEC);
+        };
+
+        MapColor color = blockUnder.getMapColor(worldIn, pos);
+        BlockState properBlock = blockUnder;
+        HolderSet.Named<Block> coralBlocks = worldIn.registryAccess().registryOrThrow(Registries.BLOCK).getTag(BlockTags.CORAL_BLOCKS).orElseThrow();
+        for (Holder<Block> block : coralBlocks) {
+            properBlock = block.value().defaultBlockState();
+            if (properBlock.getMapColor(worldIn, pos) == color) {
+                break;
+            }
+        }
+        worldIn.setBlock(pos, Blocks.WATER.defaultBlockState(), Block.UPDATE_NONE);
+
+        if (!coral.growSpecific(worldIn, random, pos, properBlock)) {
+            worldIn.setBlock(pos, blockUnder, 3);
+        } else {
+            if (worldIn.random.nextInt(10) == 0) {
+                BlockPos randomPos = pos.offset(worldIn.random.nextInt(16) - 8, worldIn.random.nextInt(8), worldIn.random.nextInt(16) - 8);
+                if (coralBlocks.contains(worldIn.getBlockState(randomPos).getBlockHolder())) {
+                    worldIn.setBlock(randomPos, Blocks.WET_SPONGE.defaultBlockState(), Block.UPDATE_ALL);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/HopperCounter.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/HopperCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..520aec415548003720af59aa2c3bad3e2fc3efc2
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/HopperCounter.java
@@ -0,0 +1,392 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import it.unimi.dsi.fastutil.objects.Object2LongLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2LongMap;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.item.DyeItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeType;
+import net.minecraft.world.level.block.AbstractBannerBlock;
+import net.minecraft.world.level.block.BeaconBeamBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.material.MapColor;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import static java.util.Map.entry;
+
+/**
+ * The actual object residing in each hopper counter which makes them count the items and saves them. There is one for each
+ * colour in MC.
+ */
+
+public class HopperCounter {
+    /**
+     * A map of all the {@link HopperCounter} counters.
+     */
+    private static final Map<DyeColor, HopperCounter> COUNTERS;
+
+    /**
+     * The default display colour of each item, which makes them look nicer when printing the counter contents to the chat
+     */
+
+    public static final TextColor WHITE = TextColor.fromLegacyFormat(ChatFormatting.WHITE);
+
+    static {
+        EnumMap<DyeColor, HopperCounter> counterMap = new EnumMap<>(DyeColor.class);
+        for (DyeColor color : DyeColor.values()) {
+            counterMap.put(color, new HopperCounter(color));
+        }
+        COUNTERS = Collections.unmodifiableMap(counterMap);
+    }
+
+    /**
+     * The counter's colour, determined by the colour of wool it's pointing into
+     */
+    public final DyeColor color;
+    /**
+     * The string which is passed into {@link Messenger#m} which makes each counter name be displayed in the colour of
+     * that counter.
+     */
+    private final String coloredName;
+    /**
+     * All the items stored within the counter, as a map of {@link Item} mapped to a {@code long} of the amount of items
+     * stored thus far of that item type.
+     */
+    private final Object2LongMap<Item> counter = new Object2LongLinkedOpenHashMap<>();
+    /**
+     * The starting tick of the counter, used to calculate in-game time. Only initialised when the first item enters the
+     * counter
+     */
+    private long startTick;
+    /**
+     * The starting millisecond of the counter, used to calculate IRl time. Only initialised when the first item enters
+     * the counter
+     */
+    private long startMillis;
+    // private PubSubInfoProvider<Long> pubSubProvider;
+
+    private HopperCounter(DyeColor color) {
+        startTick = -1;
+        this.color = color;
+        String hexColor = Integer.toHexString(color.getTextColor());
+        if (hexColor.length() < 6)
+            hexColor = "0".repeat(6 - hexColor.length()) + hexColor;
+        this.coloredName = '#' + hexColor + ' ' + color.getName();
+    }
+
+    /**
+     * Method used to add items to the counter. Note that this is when the {@link HopperCounter#startTick} and
+     * {@link HopperCounter#startMillis} variables are initialised, so you can place the counters and then start the farm
+     * after all the collection is sorted out.
+     */
+    public void add(MinecraftServer server, ItemStack stack) {
+        if (startTick < 0) {
+            startTick = server.overworld().getGameTime();
+            startMillis = System.currentTimeMillis();
+        }
+        Item item = stack.getItem();
+        counter.put(item, counter.getLong(item) + stack.getCount());
+        // pubSubProvider.publish();
+    }
+
+    /**
+     * Resets the counter, clearing its items but keeping the clock running.
+     */
+    public void reset(MinecraftServer server) {
+        counter.clear();
+        startTick = server.overworld().getGameTime();
+        startMillis = System.currentTimeMillis();
+        // pubSubProvider.publish();
+    }
+
+    /**
+     * Resets all counters, clearing their items.
+     *
+     * @param fresh Whether or not to start the clocks going immediately or later.
+     */
+    public static void resetAll(MinecraftServer server, boolean fresh) {
+        for (HopperCounter counter : COUNTERS.values()) {
+            counter.reset(server);
+            if (fresh) counter.startTick = -1;
+        }
+    }
+
+    /**
+     * Prints all the counters to chat, nicely formatted, and you can choose whether to diplay in in game time or IRL time
+     */
+    public static List<Component> formatAll(MinecraftServer server, boolean realtime) {
+        List<Component> text = new ArrayList<>();
+
+        for (HopperCounter counter : COUNTERS.values()) {
+            List<Component> temp = counter.format(server, realtime, false);
+            if (temp.size() > 1) {
+                if (!text.isEmpty()) text.add(Messenger.s(""));
+                text.addAll(temp);
+            }
+        }
+        if (text.isEmpty()) {
+            text.add(Messenger.s("No items have been counted yet."));
+        }
+        return text;
+    }
+
+    /**
+     * Prints a single counter's contents and timings to chat, with the option to keep it short (so no item breakdown,
+     * only rates). Again, realtime displays IRL time as opposed to in game time.
+     */
+    public List<Component> format(MinecraftServer server, boolean realTime, boolean brief) {
+        long ticks = Math.max(realTime ? (System.currentTimeMillis() - startMillis) / 50 : server.overworld().getGameTime() - startTick, 1);
+        if (startTick < 0 || ticks == 0) {
+            if (brief) {
+                return Collections.singletonList(Messenger.c("b" + coloredName, "w : ", "gi -, -/h, - min "));
+            }
+            return Collections.singletonList(Messenger.c(coloredName, "w  hasn't started counting yet"));
+        }
+        long total = getTotalItems();
+        if (total == 0) {
+            if (brief) {
+                return Collections.singletonList(Messenger.c("b" + coloredName, "w : ", "wb 0", "w , ", "wb 0", "w /h, ", String.format("wb %.1f ", ticks / (20.0 * 60.0)), "w min"));
+            }
+            return Collections.singletonList(Messenger.c("w No items for ", coloredName, String.format("w  yet (%.2f min.%s)",
+                            ticks / (20.0 * 60.0), (realTime ? " - real time" : "")),
+                    "nb  [X]", "^g reset", "!/counter " + color.getName() + " reset"));
+        }
+        if (brief) {
+            return Collections.singletonList(Messenger.c("b" + coloredName, "w : ",
+                    "wb " + total, "w , ",
+                    "wb " + (total * (20 * 60 * 60) / ticks), "w /h, ",
+                    String.format("wb %.1f ", ticks / (20.0 * 60.0)), "w min"
+            ));
+        }
+        List<Component> items = new ArrayList<>();
+        items.add(Messenger.c("w Items for ", coloredName,
+                "w  (", String.format("wb %.2f", ticks * 1.0 / (20 * 60)), "w  min" + (realTime ? " - real time" : "") + "), ",
+                "w total: ", "wb " + total, "w , (", String.format("wb %.1f", total * 1.0 * (20 * 60 * 60) / ticks), "w /h):",
+                "nb [X]", "^g reset", "!/counter " + color + " reset"
+        ));
+        items.addAll(counter.object2LongEntrySet().stream().sorted((e, f) -> Long.compare(f.getLongValue(), e.getLongValue())).map(e ->
+        {
+            Item item = e.getKey();
+            MutableComponent itemName = Component.translatable(item.getDescriptionId());
+            Style itemStyle = itemName.getStyle();
+            TextColor color = guessColor(item, server.registryAccess());
+            itemName.setStyle((color != null) ? itemStyle.withColor(color) : itemStyle.withItalic(true));
+            long count = e.getLongValue();
+            return Messenger.c("g - ", itemName,
+                    "g : ", "wb " + count, "g , ",
+                    String.format("wb %.1f", count * (20.0 * 60.0 * 60.0) / ticks), "w /h"
+            );
+        }).collect(Collectors.toList()));
+        return items;
+    }
+
+    /**
+     * Converts a colour to have a low brightness and uniform colour, so when it prints the items in different colours
+     * it's not too flashy and bright, but enough that it's not dull to look at.
+     */
+    public static int appropriateColor(int color) {
+        if (color == 0) return MapColor.SNOW.col;
+        int r = (color >> 16 & 255);
+        int g = (color >> 8 & 255);
+        int b = (color & 255);
+        if (r < 70) r = 70;
+        if (g < 70) g = 70;
+        if (b < 70) b = 70;
+        return (r << 16) + (g << 8) + b;
+    }
+
+    /**
+     * Maps items that don't get a good block to reference for colour, or those that colour is wrong to a number of blocks, so we can get their colours easily with the
+     * {@link Block#defaultMapColor()} method as these items have those same colours.
+     */
+    private static final Map<Item, Block> DEFAULTS = Map.ofEntries(
+            entry(Items.DANDELION, Blocks.YELLOW_WOOL),
+            entry(Items.POPPY, Blocks.RED_WOOL),
+            entry(Items.BLUE_ORCHID, Blocks.LIGHT_BLUE_WOOL),
+            entry(Items.ALLIUM, Blocks.MAGENTA_WOOL),
+            entry(Items.AZURE_BLUET, Blocks.SNOW_BLOCK),
+            entry(Items.RED_TULIP, Blocks.RED_WOOL),
+            entry(Items.ORANGE_TULIP, Blocks.ORANGE_WOOL),
+            entry(Items.WHITE_TULIP, Blocks.SNOW_BLOCK),
+            entry(Items.PINK_TULIP, Blocks.PINK_WOOL),
+            entry(Items.OXEYE_DAISY, Blocks.SNOW_BLOCK),
+            entry(Items.CORNFLOWER, Blocks.BLUE_WOOL),
+            entry(Items.WITHER_ROSE, Blocks.BLACK_WOOL),
+            entry(Items.LILY_OF_THE_VALLEY, Blocks.WHITE_WOOL),
+            entry(Items.BROWN_MUSHROOM, Blocks.BROWN_MUSHROOM_BLOCK),
+            entry(Items.RED_MUSHROOM, Blocks.RED_MUSHROOM_BLOCK),
+            entry(Items.STICK, Blocks.OAK_PLANKS),
+            entry(Items.GOLD_INGOT, Blocks.GOLD_BLOCK),
+            entry(Items.IRON_INGOT, Blocks.IRON_BLOCK),
+            entry(Items.DIAMOND, Blocks.DIAMOND_BLOCK),
+            entry(Items.NETHERITE_INGOT, Blocks.NETHERITE_BLOCK),
+            entry(Items.SUNFLOWER, Blocks.YELLOW_WOOL),
+            entry(Items.LILAC, Blocks.MAGENTA_WOOL),
+            entry(Items.ROSE_BUSH, Blocks.RED_WOOL),
+            entry(Items.PEONY, Blocks.PINK_WOOL),
+            entry(Items.CARROT, Blocks.ORANGE_WOOL),
+            entry(Items.APPLE, Blocks.RED_WOOL),
+            entry(Items.WHEAT, Blocks.HAY_BLOCK),
+            entry(Items.PORKCHOP, Blocks.PINK_WOOL),
+            entry(Items.RABBIT, Blocks.PINK_WOOL),
+            entry(Items.CHICKEN, Blocks.WHITE_TERRACOTTA),
+            entry(Items.BEEF, Blocks.NETHERRACK),
+            entry(Items.ENCHANTED_GOLDEN_APPLE, Blocks.GOLD_BLOCK),
+            entry(Items.COD, Blocks.WHITE_TERRACOTTA),
+            entry(Items.SALMON, Blocks.ACACIA_PLANKS),
+            entry(Items.ROTTEN_FLESH, Blocks.BROWN_WOOL),
+            entry(Items.PUFFERFISH, Blocks.YELLOW_TERRACOTTA),
+            entry(Items.TROPICAL_FISH, Blocks.ORANGE_WOOL),
+            entry(Items.POTATO, Blocks.WHITE_TERRACOTTA),
+            entry(Items.MUTTON, Blocks.RED_WOOL),
+            entry(Items.BEETROOT, Blocks.NETHERRACK),
+            entry(Items.MELON_SLICE, Blocks.MELON),
+            entry(Items.POISONOUS_POTATO, Blocks.SLIME_BLOCK),
+            entry(Items.SPIDER_EYE, Blocks.NETHERRACK),
+            entry(Items.GUNPOWDER, Blocks.GRAY_WOOL),
+            entry(Items.TURTLE_SCUTE, Blocks.LIME_WOOL),
+            entry(Items.ARMADILLO_SCUTE, Blocks.ANCIENT_DEBRIS),
+            entry(Items.FEATHER, Blocks.WHITE_WOOL),
+            entry(Items.FLINT, Blocks.BLACK_WOOL),
+            entry(Items.LEATHER, Blocks.SPRUCE_PLANKS),
+            entry(Items.GLOWSTONE_DUST, Blocks.GLOWSTONE),
+            entry(Items.PAPER, Blocks.WHITE_WOOL),
+            entry(Items.BRICK, Blocks.BRICKS),
+            entry(Items.INK_SAC, Blocks.BLACK_WOOL),
+            entry(Items.SNOWBALL, Blocks.SNOW_BLOCK),
+            entry(Items.WATER_BUCKET, Blocks.WATER),
+            entry(Items.LAVA_BUCKET, Blocks.LAVA),
+            entry(Items.MILK_BUCKET, Blocks.WHITE_WOOL),
+            entry(Items.CLAY_BALL, Blocks.CLAY),
+            entry(Items.COCOA_BEANS, Blocks.COCOA),
+            entry(Items.BONE, Blocks.BONE_BLOCK),
+            entry(Items.COD_BUCKET, Blocks.BROWN_TERRACOTTA),
+            entry(Items.PUFFERFISH_BUCKET, Blocks.YELLOW_TERRACOTTA),
+            entry(Items.SALMON_BUCKET, Blocks.PINK_TERRACOTTA),
+            entry(Items.TROPICAL_FISH_BUCKET, Blocks.ORANGE_TERRACOTTA),
+            entry(Items.SUGAR, Blocks.WHITE_WOOL),
+            entry(Items.BLAZE_POWDER, Blocks.GOLD_BLOCK),
+            entry(Items.ENDER_PEARL, Blocks.WARPED_PLANKS),
+            entry(Items.NETHER_STAR, Blocks.DIAMOND_BLOCK),
+            entry(Items.PRISMARINE_CRYSTALS, Blocks.SEA_LANTERN),
+            entry(Items.PRISMARINE_SHARD, Blocks.PRISMARINE),
+            entry(Items.RABBIT_HIDE, Blocks.OAK_PLANKS),
+            entry(Items.CHORUS_FRUIT, Blocks.PURPUR_BLOCK),
+            entry(Items.SHULKER_SHELL, Blocks.SHULKER_BOX),
+            entry(Items.NAUTILUS_SHELL, Blocks.BONE_BLOCK),
+            entry(Items.HEART_OF_THE_SEA, Blocks.CONDUIT),
+            entry(Items.HONEYCOMB, Blocks.HONEYCOMB_BLOCK),
+            entry(Items.NAME_TAG, Blocks.BONE_BLOCK),
+            entry(Items.TOTEM_OF_UNDYING, Blocks.YELLOW_TERRACOTTA),
+            entry(Items.TRIDENT, Blocks.PRISMARINE),
+            entry(Items.GHAST_TEAR, Blocks.WHITE_WOOL),
+            entry(Items.PHANTOM_MEMBRANE, Blocks.BONE_BLOCK),
+            entry(Items.EGG, Blocks.BONE_BLOCK),
+            //entry(Items.,Blocks.),
+            entry(Items.COPPER_INGOT, Blocks.COPPER_BLOCK),
+            entry(Items.AMETHYST_SHARD, Blocks.AMETHYST_BLOCK));
+
+    /**
+     * Gets the colour to print an item in when printing its count in a hopper counter.
+     */
+    public static TextColor fromItem(Item item, RegistryAccess registryAccess) {
+        if (DEFAULTS.containsKey(item))
+            return TextColor.fromRgb(appropriateColor(DEFAULTS.get(item).defaultMapColor().col));
+        if (item instanceof DyeItem dye)
+            return TextColor.fromRgb(appropriateColor(dye.getDyeColor().getMapColor().col));
+        Block block = null;
+        final Registry<Item> itemRegistry = registryAccess.registryOrThrow(Registries.ITEM);
+        final Registry<Block> blockRegistry = registryAccess.registryOrThrow(Registries.BLOCK);
+        ResourceLocation id = itemRegistry.getKey(item);
+        if (item instanceof BlockItem blockItem) {
+            block = blockItem.getBlock();
+        } else if (blockRegistry.getOptional(id).isPresent()) {
+            block = blockRegistry.get(id);
+        }
+        if (block != null) {
+            if (block instanceof AbstractBannerBlock)
+                return TextColor.fromRgb(appropriateColor(((AbstractBannerBlock) block).getColor().getMapColor().col));
+            if (block instanceof BeaconBeamBlock)
+                return TextColor.fromRgb(appropriateColor(((BeaconBeamBlock) block).getColor().getMapColor().col));
+            return TextColor.fromRgb(appropriateColor(block.defaultMapColor().col));
+        }
+        return null;
+    }
+
+    /**
+     * Guesses the item's colour from the item itself. It first calls {@link HopperCounter#fromItem} to see if it has a
+     * valid colour there, if not just makes a guess, and if that fails just returns null
+     */
+    public static TextColor guessColor(Item item, RegistryAccess registryAccess) {
+        TextColor direct = fromItem(item, registryAccess);
+        if (direct != null) return direct;
+
+        ResourceLocation id = registryAccess.registryOrThrow(Registries.ITEM).getKey(item);
+        for (RecipeType<?> type : registryAccess.registryOrThrow(Registries.RECIPE_TYPE)) {
+            for (Recipe<?> r : MinecraftServer.getServer().getRecipeManager().getAllMatching(type, id, registryAccess)) {
+                for (Ingredient ingredient : r.getIngredients()) {
+                    for (Collection<ItemStack> stacks : ingredient.getRecipeStacks()) {
+                        for (ItemStack iStak : stacks) {
+                            TextColor cand = fromItem(iStak.getItem(), registryAccess);
+                            if (cand != null)
+                                return cand;
+                        }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns the hopper counter for the given color
+     */
+    public static HopperCounter getCounter(DyeColor color) {
+        return COUNTERS.get(color);
+    }
+
+    /**
+     * Returns the hopper counter from the colour name, if not null
+     */
+    public static HopperCounter getCounter(String color) {
+        try {
+            DyeColor colorEnum = DyeColor.valueOf(color.toUpperCase(Locale.ROOT));
+            return COUNTERS.get(colorEnum);
+        } catch (IllegalArgumentException e) {
+            return null;
+        }
+    }
+
+    /**
+     * The total number of items in the counter
+     */
+    public long getTotalItems() {
+        return counter.isEmpty() ? 0 : counter.values().longStream().sum();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/ParticleDisplay.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/ParticleDisplay.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec494f4ee53695c06486d8318a6439729883e7f8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/ParticleDisplay.java
@@ -0,0 +1,40 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.script.utils.ParticleParser;
+import net.minecraft.core.particles.ParticleOptions;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.phys.Vec3;
+
+public class ParticleDisplay
+{
+    public static void drawParticleLine(@NotNull ServerPlayer player, Vec3 from, Vec3 to, String main, String accent, int count, double spread)
+    {
+        ParticleOptions accentParticle = ParticleParser.getEffect(accent, player.server.registryAccess());
+        ParticleOptions mainParticle = ParticleParser.getEffect(main, player.server.registryAccess());
+
+        if (accentParticle != null) player.serverLevel().sendParticles(
+                player,
+                accentParticle,
+                true,
+                to.x, to.y, to.z, count,
+                spread, spread, spread, 0.0);
+
+        double lineLengthSq = from.distanceToSqr(to);
+        if (lineLengthSq == 0) return;
+
+        Vec3 incvec = to.subtract(from).normalize();//    multiply(50/sqrt(lineLengthSq));
+        for (Vec3 delta = new Vec3(0.0,0.0,0.0);
+             delta.lengthSqr() < lineLengthSq;
+             delta = delta.add(incvec.scale(player.level().random.nextFloat())))
+        {
+            player.serverLevel().sendParticles(
+                    player,
+                    mainParticle,
+                    true,
+                    delta.x+from.x, delta.y+from.y, delta.z+from.z, 1,
+                    0.0, 0.0, 0.0, 0.0);
+        }
+    }
+
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/QuasiConnectivity.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/QuasiConnectivity.java
new file mode 100644
index 0000000000000000000000000000000000000000..949eea4d3c29e0b2f7e90e1ea924f8521a3914a6
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/QuasiConnectivity.java
@@ -0,0 +1,23 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.SignalGetter;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+public class QuasiConnectivity {
+
+    public static boolean hasQuasiSignal(SignalGetter level, BlockPos pos) {
+        for (int i = 1; i <= CarpetConfig.configModule.quasiConnectivity; i++) {
+            BlockPos above = pos.above(i);
+
+            if (level.isOutsideBuildHeight(above)) {
+                break;
+            }
+            if (level.hasNeighborSignal(above)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/HUDController.java b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDController.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bcf53cc224422de8d68aa53f607e5f2a7de9188
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDController.java
@@ -0,0 +1,143 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import org.bukkit.Bukkit;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import org.leavesmc.lumina.carpet.logging.logHelpers.PacketCounter;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.SpawnReporter;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ClientboundTabListPacket;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.world.level.Level;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Consumer;
+
+public class HUDController {
+    private static final List<Consumer<MinecraftServer>> HUDListeners = new ArrayList<>();
+
+    /**
+     * Adds listener to be called when HUD is updated for logging information
+     *
+     * @param listener - a method to be called when new HUD inforation are collected
+     */
+    public static void register(Consumer<MinecraftServer> listener) {
+        HUDListeners.add(listener);
+    }
+
+    public static final Map<ServerPlayer, List<Component>> player_huds = new HashMap<>();
+    //keyed with player names so unlogged players don't hold the reference
+    public static final Map<String, Component> scarpet_headers = new HashMap<>();
+
+    public static final Map<String, Component> scarpet_footers = new HashMap<>();
+
+    public static void resetScarpetHUDs() {
+        scarpet_headers.clear();
+        scarpet_footers.clear();
+    }
+
+    public static void addMessage(ServerPlayer player, Component hudMessage) {
+        if (player == null) return;
+        if (!player_huds.containsKey(player)) {
+            player_huds.put(player, new ArrayList<>());
+        } else {
+            player_huds.get(player).add(Component.literal("\n"));
+        }
+        player_huds.get(player).add(hudMessage);
+    }
+
+    public static void clearPlayer(ServerPlayer player) {
+        ClientboundTabListPacket packet = new ClientboundTabListPacket(Component.literal(""), Component.literal(""));
+        player.connection.send(packet);
+    }
+
+
+    public static void update_hud(MinecraftServer server, List<ServerPlayer> force) {
+
+        if (RegionizedServer.getGlobalTickData().getCurrentTick() % 20 != 0 && force == null)
+            return;
+
+        player_huds.clear();
+
+        server.getPlayerList().getPlayers().forEach(p -> {
+            Component scarpetFOoter = scarpet_footers.get(p.getScoreboardName());
+            if (scarpetFOoter != null) HUDController.addMessage(p, scarpetFOoter);
+        });
+
+        if (LoggerRegistry.__tps)
+            LoggerRegistry.getLogger("tps").log(() -> send_tps_display(server));
+
+        if (LoggerRegistry.__mobcaps)
+            LoggerRegistry.getLogger("mobcaps").log((option, player) -> {
+                ResourceKey<Level> dim = switch (option) {
+                    case "overworld" -> Level.OVERWORLD;
+                    case "nether" -> Level.NETHER;
+                    case "end" -> Level.END;
+                    default -> player.level().dimension();
+                };
+                return new Component[]{SpawnReporter.printMobcapsForDimension(server.getLevel(dim), false).get(0)};
+            });
+
+        if (LoggerRegistry.__counter)
+            LoggerRegistry.getLogger("counter").log((option) -> send_counter_info(server, option));
+
+        if (LoggerRegistry.__packets)
+            LoggerRegistry.getLogger("packets").log(HUDController::packetCounter);
+
+        // extensions have time to pitch in.
+        HUDListeners.forEach(l -> l.accept(server));
+
+        Set<ServerPlayer> targets = new HashSet<>(player_huds.keySet());
+        if (force != null) targets.addAll(force);
+        for (ServerPlayer player : targets) {
+            ClientboundTabListPacket packet = new ClientboundTabListPacket(
+                    scarpet_headers.getOrDefault(player.getScoreboardName(), Component.literal("")),
+                    Messenger.c(player_huds.getOrDefault(player, List.of()).toArray(new Object[0]))
+            );
+            player.connection.send(packet);
+        }
+    }
+
+    private static Component[] send_tps_display(MinecraftServer server) {
+        double MSPT = ((double) server.getAverageTickTimeNanos()) / TimeUtil.NANOSECONDS_PER_MILLISECOND;
+        ServerTickRateManager trm = server.tickRateManager();
+
+        double TPS = 1000.0D / Math.max(trm.isSprinting() ? 0.0 : trm.millisecondsPerTick(), MSPT);
+        if (trm.isFrozen()) {
+            TPS = 0;
+        }
+        String color = Messenger.heatmap_color(MSPT, trm.millisecondsPerTick());
+        return new Component[]{Messenger.c(
+                "g TPS: ", String.format(Locale.US, "%s %.1f", color, TPS),
+                "g  MSPT: ", String.format(Locale.US, "%s %.1f", color, MSPT))};
+    }
+
+    private static Component[] send_counter_info(MinecraftServer server, String colors) {
+        List<Component> res = new ArrayList<>();
+        for (String color : colors.split(",")) {
+            HopperCounter counter = HopperCounter.getCounter(color);
+            if (counter != null) res.addAll(counter.format(server, false, true));
+        }
+        return res.toArray(new Component[0]);
+    }
+
+    private static Component[] packetCounter() {
+        Component[] ret = new Component[]{
+                Messenger.c("w I/" + PacketCounter.totalIn + " O/" + PacketCounter.totalOut),
+        };
+        PacketCounter.reset();
+        return ret;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/HUDLogger.java b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3de8593057c4f7c3f017c7fe3d3d85fcf646684
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDLogger.java
@@ -0,0 +1,44 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import java.lang.reflect.Field;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+
+public class HUDLogger extends Logger {
+    static Logger stardardHUDLogger(String logName, String def, String[] options) {
+        return stardardHUDLogger(logName, def, options, false);
+    }
+
+    static Logger stardardHUDLogger(String logName, String def, String[] options, boolean strictOptions) {
+        // should convert to factory method if more than 2 classes are here
+        try {
+            return new HUDLogger(LoggerRegistry.class.getField("__" + logName), logName, def, options, strictOptions);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException("Failed to create logger " + logName);
+        }
+    }
+
+    public HUDLogger(Field field, String logName, String def, String[] options, boolean strictOptions) {
+        super(field, logName, def, options, strictOptions);
+    }
+
+    @Deprecated
+    public HUDLogger(Field field, String logName, String def, String[] options) {
+        super(field, logName, def, options, false);
+    }
+
+    @Override
+    public void removePlayer(String playerName) {
+        ServerPlayer player = playerFromName(playerName);
+        if (player != null) HUDController.clearPlayer(player);
+        super.removePlayer(playerName);
+    }
+
+    @Override
+    public void sendPlayerMessage(ServerPlayer player, Component... messages) {
+        for (Component m : messages) HUDController.addMessage(player, m);
+    }
+
+
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/Logger.java b/src/main/java/org/leavesmc/lumina/carpet/logging/Logger.java
new file mode 100644
index 0000000000000000000000000000000000000000..dda544edd7a03113d68612118e2d347432b14e23
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/Logger.java
@@ -0,0 +1,227 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Supplier;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.player.Player;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.CarpetServer;
+
+public class Logger {
+    // The set of subscribed and online players.
+    private Map<String, String> subscribedOnlinePlayers;
+
+    // The set of subscribed and offline players.
+    private Map<String, String> subscribedOfflinePlayers;
+
+    // The logName of this log. Gets prepended to logged messages.
+    private String logName;
+
+    private String default_option;
+
+    private String[] options;
+
+    private Field acceleratorField;
+
+    private boolean strictOptions;
+
+    static Logger stardardLogger(String logName, String def, String[] options) {
+        return stardardLogger(logName, def, options, false);
+    }
+
+    static Logger stardardLogger(String logName, String def, String[] options, boolean strictOptions) {
+        try {
+            return new Logger(LoggerRegistry.class.getField("__" + logName), logName, def, options, strictOptions);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException("Failed to create logger " + logName);
+        }
+    }
+
+    @Deprecated
+    public Logger(Field acceleratorField, String logName, String def, String[] options) {
+        this(acceleratorField, logName, def, options, false);
+    }
+
+    public Logger(Field acceleratorField, String logName, String def, String[] options, boolean strictOptions) {
+        subscribedOnlinePlayers = new HashMap<>();
+        subscribedOfflinePlayers = new HashMap<>();
+        this.acceleratorField = acceleratorField;
+        this.logName = logName;
+        this.default_option = def;
+        this.options = options == null ? new String[0] : options;
+        this.strictOptions = strictOptions;
+        if (acceleratorField == null)
+            CarpetServer.LOGGER.error("[CM] Logger {} is missing a specified accelerator", getLogName());
+    }
+
+    public String getDefault() {
+        return default_option;
+    }
+
+    public String[] getOptions() {
+        return options;
+    }
+
+    public String getLogName() {
+        return logName;
+    }
+
+    /**
+     * Subscribes the player with the given logName to the logger.
+     */
+    public void addPlayer(String playerName, String option) {
+        if (playerFromName(playerName) != null) {
+            subscribedOnlinePlayers.put(playerName, option);
+        } else {
+            subscribedOfflinePlayers.put(playerName, option);
+        }
+        LoggerRegistry.setAccess(this);
+    }
+
+    /**
+     * Unsubscribes the player with the given logName from the logger.
+     */
+    public void removePlayer(String playerName) {
+        subscribedOnlinePlayers.remove(playerName);
+        subscribedOfflinePlayers.remove(playerName);
+        LoggerRegistry.setAccess(this);
+    }
+
+    /**
+     * Returns true if there are any online subscribers for this log.
+     */
+    public boolean hasOnlineSubscribers() {
+        return subscribedOnlinePlayers.size() > 0;
+    }
+
+    public void serverStopped() {
+        subscribedOnlinePlayers.clear();
+        subscribedOfflinePlayers.clear();
+    }
+
+    public Field getField() {
+        return acceleratorField;
+    }
+
+    /**
+     * serves messages to players fetching them from the promise
+     * will repeat invocation for players that share the same option
+     */
+    @FunctionalInterface
+    public interface lMessage {
+        Component[] get(String playerOption, Player player);
+    }
+
+    public void log(lMessage messagePromise) {
+        for (Map.Entry<String, String> en : subscribedOnlinePlayers.entrySet()) {
+            ServerPlayer player = playerFromName(en.getKey());
+            if (player != null) {
+                Component[] messages = messagePromise.get(en.getValue(), player);
+                if (messages != null)
+                    sendPlayerMessage(player, messages);
+            }
+        }
+    }
+
+    /**
+     * guarantees that each message for each option will be evaluated once from the promise
+     * and served the same way to all other players subscribed to the same option
+     */
+    @FunctionalInterface
+    public interface lMessageIgnorePlayer {
+        Component[] get(String playerOption);
+    }
+
+    public void log(lMessageIgnorePlayer messagePromise) {
+        Map<String, Component[]> cannedMessages = new HashMap<>();
+        for (Map.Entry<String, String> en : subscribedOnlinePlayers.entrySet()) {
+            ServerPlayer player = playerFromName(en.getKey());
+            if (player != null) {
+                String option = en.getValue();
+                if (!cannedMessages.containsKey(option)) {
+                    cannedMessages.put(option, messagePromise.get(option));
+                }
+                Component[] messages = cannedMessages.get(option);
+                if (messages != null)
+                    sendPlayerMessage(player, messages);
+            }
+        }
+    }
+
+    /**
+     * guarantees that message is evaluated once, so independent from the player and chosen option
+     */
+    public void log(Supplier<Component[]> messagePromise) {
+        Component[] cannedMessages = null;
+        for (Map.Entry<String, String> en : subscribedOnlinePlayers.entrySet()) {
+            ServerPlayer player = playerFromName(en.getKey());
+            if (player != null) {
+                if (cannedMessages == null) cannedMessages = messagePromise.get();
+                sendPlayerMessage(player, cannedMessages);
+            }
+        }
+    }
+
+    public void sendPlayerMessage(ServerPlayer player, Component... messages) {
+        Arrays.stream(messages).forEach(player::sendSystemMessage);
+    }
+
+    /**
+     * Gets the {@code PlayerEntity} instance for a player given their UUID. Returns null if they are offline.
+     */
+    protected ServerPlayer playerFromName(String name) {
+        return MinecraftServer.getServer().getPlayerList().getPlayerByName(name);
+    }
+
+    // ----- Event Handlers ----- //
+
+    public void onPlayerConnect(Player player, boolean firstTime) {
+        // If the player was subscribed to the log and offline, move them to the set of online subscribers.
+        String playerName = player.getName().getString();
+        if (subscribedOfflinePlayers.containsKey(playerName)) {
+            subscribedOnlinePlayers.put(playerName, subscribedOfflinePlayers.get(playerName));
+            subscribedOfflinePlayers.remove(playerName);
+        } else if (firstTime) {
+            Set<String> loggingOptions = new HashSet<>(Arrays.asList(CarpetConfig.configModule.defaultLoggers.split(",")));
+            String logName = getLogName();
+            for (String str : loggingOptions) {
+                String[] vars = str.split(" ", 2);
+                if (vars[0].equals(logName)) {
+                    LoggerRegistry.subscribePlayer(playerName, getLogName(), vars.length == 1 ? getDefault() : vars[1]);
+                    break;
+                }
+            }
+        }
+        LoggerRegistry.setAccess(this);
+    }
+
+    public void onPlayerDisconnect(Player player) {
+        // If the player was subscribed to the log, move them to the set of offline subscribers.
+        String playerName = player.getName().getString();
+        if (subscribedOnlinePlayers.containsKey(playerName)) {
+            subscribedOfflinePlayers.put(playerName, subscribedOnlinePlayers.get(playerName));
+            subscribedOnlinePlayers.remove(playerName);
+        }
+        LoggerRegistry.setAccess(this);
+    }
+
+    public String getAcceptedOption(String arg) {
+        if (Arrays.asList(this.getOptions()).contains(arg)) return arg;
+        return null;
+    }
+
+    public boolean isOptionValid(String option) {
+        if (strictOptions) {
+            return Arrays.asList(this.getOptions()).contains(option);
+        }
+        return option != null;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/LoggerRegistry.java b/src/main/java/org/leavesmc/lumina/carpet/logging/LoggerRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..f03b4d372f5f7f01b9e132e117cb4c9a442a11e9
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/LoggerRegistry.java
@@ -0,0 +1,156 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import org.leavesmc.lumina.carpet.CarpetServer;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.DyeColor;
+
+public class LoggerRegistry {
+    // Map from logger names to loggers.
+    private static final Map<String, Logger> loggerRegistry = new HashMap<>();
+    // Map from player names to the set of names of the logs that player is subscribed to.
+    private static final Map<String, Map<String, String>> playerSubscriptions = new HashMap<>();
+    //statics to quickly asses if its worth even to call each one
+    public static boolean __tnt;
+    public static boolean __projectiles;
+    public static boolean __fallingBlocks;
+    public static boolean __tps;
+    public static boolean __counter;
+    public static boolean __mobcaps;
+    public static boolean __packets;
+    public static boolean __pathfinding;
+    public static boolean __explosions;
+
+    public static void initLoggers() {
+        stopLoggers();
+        registerLoggers();
+        CarpetServer.registerExtensionLoggers();
+    }
+
+    public static void registerLoggers() {
+        registerLogger("tnt", Logger.stardardLogger("tnt", "brief", new String[]{"brief", "full"}, true));
+        registerLogger("projectiles", Logger.stardardLogger("projectiles", "brief", new String[]{"brief", "full"}));
+        registerLogger("fallingBlocks", Logger.stardardLogger("fallingBlocks", "brief", new String[]{"brief", "full"}));
+        registerLogger("pathfinding", Logger.stardardLogger("pathfinding", "20", new String[]{"2", "5", "10"}));
+        registerLogger("tps", HUDLogger.stardardHUDLogger("tps", null, null));
+        registerLogger("packets", HUDLogger.stardardHUDLogger("packets", null, null));
+        registerLogger("counter", HUDLogger.stardardHUDLogger("counter", "white", Arrays.stream(DyeColor.values()).map(Object::toString).toArray(String[]::new)));
+        registerLogger("mobcaps", HUDLogger.stardardHUDLogger("mobcaps", "dynamic", new String[]{"dynamic", "overworld", "nether", "end"}));
+        registerLogger("explosions", Logger.stardardLogger("explosions", "brief", new String[]{"brief", "full"}, true));
+
+    }
+
+    /**
+     * Gets the logger with the given name. Returns null if no such logger exists.
+     */
+    public static Logger getLogger(String name) {
+        return loggerRegistry.get(name);
+    }
+
+    /**
+     * Gets the set of logger names.
+     */
+    public static Set<String> getLoggerNames() {
+        return loggerRegistry.keySet();
+    }
+
+    /**
+     * Subscribes the player with name playerName to the log with name logName.
+     */
+    public static void subscribePlayer(String playerName, String logName, String option) {
+        if (!playerSubscriptions.containsKey(playerName)) playerSubscriptions.put(playerName, new HashMap<>());
+        Logger log = loggerRegistry.get(logName);
+        if (option == null) option = log.getDefault();
+        playerSubscriptions.get(playerName).put(logName, option);
+        log.addPlayer(playerName, option);
+    }
+
+    /**
+     * Unsubscribes the player with name playerName from the log with name logName.
+     */
+    public static void unsubscribePlayer(String playerName, String logName) {
+        if (playerSubscriptions.containsKey(playerName)) {
+            Map<String, String> subscriptions = playerSubscriptions.get(playerName);
+            subscriptions.remove(logName);
+            loggerRegistry.get(logName).removePlayer(playerName);
+            if (subscriptions.size() == 0) playerSubscriptions.remove(playerName);
+        }
+    }
+
+    /**
+     * If the player is not subscribed to the log, then subscribe them. Otherwise, unsubscribe them.
+     */
+    public static boolean togglePlayerSubscription(String playerName, String logName) {
+        if (playerSubscriptions.containsKey(playerName) && playerSubscriptions.get(playerName).containsKey(logName)) {
+            unsubscribePlayer(playerName, logName);
+            return false;
+        } else {
+            subscribePlayer(playerName, logName, null);
+            return true;
+        }
+    }
+
+    /**
+     * Get the set of logs the current player is subscribed to.
+     */
+    public static Map<String, String> getPlayerSubscriptions(String playerName) {
+        if (playerSubscriptions.containsKey(playerName)) {
+            return playerSubscriptions.get(playerName);
+        }
+        return null;
+    }
+
+    protected static void setAccess(Logger logger) {
+        boolean value = logger.hasOnlineSubscribers();
+        try {
+            Field f = logger.getField();
+            f.setBoolean(null, value);
+        } catch (IllegalAccessException e) {
+            CarpetServer.LOGGER.error("Cannot change logger quick access field");
+        }
+    }
+
+    /**
+     * Called when the server starts. Creates the logs used by Carpet mod.
+     */
+    public static void registerLogger(String name, Logger logger) {
+        loggerRegistry.put(name, logger);
+        setAccess(logger);
+    }
+
+    private final static Set<String> seenPlayers = new HashSet<>();
+
+    public static void stopLoggers() {
+        for (Logger log : loggerRegistry.values()) {
+            log.serverStopped();
+        }
+        seenPlayers.clear();
+        loggerRegistry.clear();
+        playerSubscriptions.clear();
+    }
+
+    public static void playerConnected(Player player) {
+        boolean firstTime = false;
+        if (!seenPlayers.contains(player.getName().getString())) {
+            seenPlayers.add(player.getName().getString());
+            firstTime = true;
+            //subscribe them to the defualt loggers
+        }
+        for (Logger log : loggerRegistry.values()) {
+            log.onPlayerConnect(player, firstTime);
+        }
+    }
+
+    public static void playerDisconnected(Player player) {
+        for (Logger log : loggerRegistry.values()) {
+            log.onPlayerDisconnect(player);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/ExplosionLogHelper.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/ExplosionLogHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..4415d3a342d3936cb0b05df4d5e6d3bd1207e03a
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/ExplosionLogHelper.java
@@ -0,0 +1,96 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.Explosion;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+import static org.leavesmc.lumina.carpet.utils.Messenger.c;
+
+public class ExplosionLogHelper {
+    private final boolean createFire;
+    private final Explosion.BlockInteraction blockDestructionType;
+    private final RegistryAccess regs;
+    public final Vec3 pos;
+    private final float power;
+    private boolean affectBlocks = false;
+    private final Object2IntMap<EntityChangedStatusWithCount> impactedEntities = new Object2IntOpenHashMap<>();
+
+    private static long lastGametime = 0;
+    private static int explosionCountInCurrentGT = 0;
+    private static boolean newTick;
+
+    public ExplosionLogHelper(double x, double y, double z, float power, boolean createFire, Explosion.BlockInteraction blockDestructionType, RegistryAccess regs) {
+        this.power = power;
+        this.pos = new Vec3(x, y, z);
+        this.createFire = createFire;
+        this.blockDestructionType = blockDestructionType;
+        this.regs = regs;
+    }
+
+    public void setAffectBlocks(boolean b) {
+        affectBlocks = b;
+    }
+
+    public void onExplosionDone(long gametime) {
+        newTick = false;
+        if (!(lastGametime == gametime)) {
+            explosionCountInCurrentGT = 0;
+            lastGametime = gametime;
+            newTick = true;
+        }
+        explosionCountInCurrentGT++;
+        LoggerRegistry.getLogger("explosions").log((option) -> {
+            List<Component> messages = new ArrayList<>();
+            if (newTick) messages.add(c("wb tick : ", "d " + gametime));
+            if ("brief".equals(option)) {
+                messages.add(c("d #" + explosionCountInCurrentGT, "gb ->",
+                        Messenger.dblt("l", pos.x, pos.y, pos.z), (affectBlocks) ? "m  (affects blocks)" : "m  (doesn't affect blocks)"));
+            }
+            if ("full".equals(option)) {
+                messages.add(c("d #" + explosionCountInCurrentGT, "gb ->", Messenger.dblt("l", pos.x, pos.y, pos.z)));
+                messages.add(c("w   affects blocks: ", "m " + this.affectBlocks));
+                messages.add(c("w   creates fire: ", "m " + this.createFire));
+                messages.add(c("w   power: ", "c " + this.power));
+                messages.add(c("w   destruction: ", "c " + this.blockDestructionType.name()));
+                if (impactedEntities.isEmpty()) {
+                    messages.add(c("w   affected entities: ", "m None"));
+                } else {
+                    messages.add(c("w   affected entities:"));
+                    impactedEntities.forEach((k, v) ->
+                    {
+                        messages.add(c((k.pos.equals(pos)) ? "r   - TNT" : "w   - ",
+                                Messenger.dblt((k.pos.equals(pos)) ? "r" : "y", k.pos.x, k.pos.y, k.pos.z), "w  dV",
+                                Messenger.dblt("d", k.accel.x, k.accel.y, k.accel.z),
+                                "w  " + regs.registryOrThrow(Registries.ENTITY_TYPE).getKey(k.type).getPath(), (v > 1) ? "l (" + v + ")" : ""
+                        ));
+                    });
+                }
+            }
+            return messages.toArray(new Component[0]);
+        });
+    }
+
+    public void onEntityImpacted(Entity entity, Vec3 accel) {
+        EntityChangedStatusWithCount ent = new EntityChangedStatusWithCount(entity, accel);
+        impactedEntities.put(ent, impactedEntities.getOrDefault(ent, 0) + 1);
+    }
+
+
+    public static record EntityChangedStatusWithCount(Vec3 pos, EntityType<?> type, Vec3 accel) {
+        public EntityChangedStatusWithCount(Entity e, Vec3 accel) {
+            this(e.position(), e.getType(), accel);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PacketCounter.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PacketCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..4be144181afab0e195f6b35d4453ded4b9a93ad9
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PacketCounter.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+public class PacketCounter {
+    public static long totalOut = 0;
+    public static long totalIn = 0;
+
+    public static void reset() {
+        totalIn = 0L;
+        totalOut = 0L;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PathfindingVisualizer.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PathfindingVisualizer.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf4111fd49530f21dd71dc380ae54637bbe529f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PathfindingVisualizer.java
@@ -0,0 +1,35 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.helpers.ParticleDisplay;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+
+public class PathfindingVisualizer {
+    public static void slowPath(Entity entity, Vec3 target, float miliseconds, boolean successful) {
+        if (!LoggerRegistry.__pathfinding) return;
+        LoggerRegistry.getLogger("pathfinding").log((option, player) ->
+        {
+            if (!(player instanceof ServerPlayer))
+                return null;
+            int minDuration;
+            try {
+                minDuration = Integer.parseInt(option);
+            } catch (NumberFormatException ignored) {
+                return null;
+            }
+            if (miliseconds < minDuration)
+                return null;
+            if (player.distanceToSqr(entity) > 1000 && player.distanceToSqr(target) > 1000)
+                return null;
+            if (minDuration < 1)
+                minDuration = 1;
+
+            String accent = successful ? "happy_villager" : "angry_villager";
+            String color = (miliseconds / minDuration < 2) ? "dust 1 1 0 1" : ((miliseconds / minDuration < 4) ? "dust 1 0.5 0 1" : "dust 1 0 0 1");
+            ParticleDisplay.drawParticleLine((ServerPlayer) player, entity.position(), target, color, accent, 5, 0.5);
+            return null;
+        });
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TNTLogHelper.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TNTLogHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..d9052a7f2fa4d66b8cfd832508c9a29b7ab5c5f4
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TNTLogHelper.java
@@ -0,0 +1,50 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+public class TNTLogHelper {
+    public boolean initialized;
+    private double primedX, primedY, primedZ;
+    private static long lastGametime = 0;
+    private static int tntCount = 0;
+    private Vec3 primedAngle;
+
+    /**
+     * Runs when the TNT is primed. Expects the position and motion angle of the TNT.
+     */
+    public void onPrimed(double x, double y, double z, Vec3 motion) {
+        primedX = x;
+        primedY = y;
+        primedZ = z;
+        primedAngle = motion;
+        initialized = true;
+    }
+
+    /**
+     * Runs when the TNT explodes. Expects the position of the TNT.
+     */
+    public void onExploded(double x, double y, double z, long gametime) {
+        if (!(lastGametime == gametime)) {
+            tntCount = 0;
+            lastGametime = gametime;
+        }
+        tntCount++;
+        LoggerRegistry.getLogger("tnt").log((option) -> switch (option) {
+            case "brief" -> new Component[]{Messenger.c(
+                    "l P ", Messenger.dblt("l", primedX, primedY, primedZ),
+                    "w  ", Messenger.dblt("l", primedAngle.x, primedAngle.y, primedAngle.z),
+                    "r  E ", Messenger.dblt("r", x, y, z))};
+            case "full" -> new Component[]{Messenger.c(
+                    "r #" + tntCount,
+                    "m @" + gametime,
+                    "g : ",
+                    "l P ", Messenger.dblf("l", primedX, primedY, primedZ),
+                    "w  ", Messenger.dblf("l", primedAngle.x, primedAngle.y, primedAngle.z),
+                    "r  E ", Messenger.dblf("r", x, y, z))};
+            default -> null;
+        });
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TrajectoryLogHelper.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TrajectoryLogHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..93c3c260737bf2e3ec5627c89f021eea3f847cfb
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TrajectoryLogHelper.java
@@ -0,0 +1,72 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import org.leavesmc.lumina.carpet.logging.Logger;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.phys.Vec3;
+
+/**
+ * A generic log helper for logging the trajectory of things like blocks and throwables.
+ */
+public class TrajectoryLogHelper {
+    private static final int MAX_TICKS_PER_LINE = 20;
+
+    private boolean doLog;
+    private final Logger logger;
+
+    private final ArrayList<Vec3> positions = new ArrayList<>();
+    private final ArrayList<Vec3> motions = new ArrayList<>();
+
+    public TrajectoryLogHelper(String logName) {
+        this.logger = LoggerRegistry.getLogger(logName);
+        this.doLog = this.logger.hasOnlineSubscribers();
+    }
+
+    public void onTick(double x, double y, double z, Vec3 velocity) {
+        if (!doLog) return;
+        positions.add(new Vec3(x, y, z));
+        motions.add(velocity);
+    }
+
+    public void onFinish() {
+        if (!doLog) return;
+        logger.log((option) -> {
+            List<Component> comp = new ArrayList<>();
+            switch (option) {
+                case "brief" -> {
+                    comp.add(Messenger.s(""));
+                    List<String> line = new ArrayList<>();
+                    for (int i = 0; i < positions.size(); i++) {
+                        Vec3 pos = positions.get(i);
+                        Vec3 mot = motions.get(i);
+                        line.add("w  x");
+                        line.add(String.format("^w Tick: %d\nx: %f\ny: %f\nz: %f\n------------\nmx: %f\nmy: %f\nmz: %f",
+                                i, pos.x, pos.y, pos.z, mot.x, mot.y, mot.z));
+                        if ((((i + 1) % MAX_TICKS_PER_LINE) == 0) || i == positions.size() - 1) {
+                            comp.add(Messenger.c(line.toArray(new Object[0])));
+                            line.clear();
+                        }
+                    }
+                }
+                case "full" -> {
+                    comp.add(Messenger.c("w ---------"));
+                    for (int i = 0; i < positions.size(); i++) {
+                        Vec3 pos = positions.get(i);
+                        Vec3 mot = motions.get(i);
+                        comp.add(Messenger.c(
+                                String.format("w tick: %3d pos", i), Messenger.dblt("w", pos.x, pos.y, pos.z),
+                                "w   mot", Messenger.dblt("w", mot.x, mot.y, mot.z)));
+                    }
+                }
+            }
+            return comp.toArray(new Component[0]);
+        });
+        doLog = false;
+    }
+}
+
diff --git a/src/main/java/org/leavesmc/lumina/carpet/patches/EntityPlayerMPFake.java b/src/main/java/org/leavesmc/lumina/carpet/patches/EntityPlayerMPFake.java
new file mode 100644
index 0000000000000000000000000000000000000000..d610f0e79265ecc1109bcfe1ca46920d64d79b26
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/patches/EntityPlayerMPFake.java
@@ -0,0 +1,223 @@
+package org.leavesmc.lumina.carpet.patches;
+
+import com.mojang.authlib.GameProfile;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundRotateHeadPacket;
+import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
+import net.minecraft.network.protocol.game.ServerboundClientCommandPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ClientInformation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.CommonListenerCookie;
+import net.minecraft.server.players.GameProfileCache;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.food.FoodData;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.block.entity.SkullBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+
+import static net.minecraft.world.level.block.entity.SkullBlockEntity.fetchGameProfile;
+
+@SuppressWarnings("EntityConstructor")
+public class EntityPlayerMPFake extends ServerPlayer {
+    public Runnable fixStartingPosition = () -> {
+    };
+    public boolean isAShadow;
+
+    // Returns true if it was successful, false if couldn't spawn due to the player not existing in Mojang servers
+    public static boolean createFake(String username, @NotNull MinecraftServer server, Location pos, double yaw, double pitch, World world, GameType gamemode, boolean flying) {
+        // prolly half of that crap is not necessary, but it works
+        GameProfileCache.setUsesAuthentication(false);
+        GameProfile gameprofile;
+        try { //noinspection DataFlowIssue
+            gameprofile = server.getProfileCache().get(username).orElse(null); // findByName  .orElse(null)
+        } finally {
+            GameProfileCache.setUsesAuthentication(server.isDedicatedServer() && server.usesAuthentication());
+        }
+        if (gameprofile == null) {
+            if (!CarpetConfig.configModule.allowSpawningOfflinePlayers) {
+                return false;
+            } else {
+                gameprofile = new GameProfile(UUIDUtil.createOfflinePlayerUUID(username), username);
+            }
+        }
+        GameProfile finalGameProfile = gameprofile;
+        // Bukkit.getAsyncScheduler().runNow(
+        //         CarpetServer.PLUGIN,
+        //         scheduledTask -> {
+        //             GameProfile current = SkullBlockEntity.fetchGameProfile(username).join().orElse(finalGameProfile); // TODO
+        ServerLevel worldIn = ((CraftWorld) world).getHandle().getLevel();
+        Bukkit.getRegionScheduler().run(CarpetServer.PLUGIN, pos, task -> {
+            EntityPlayerMPFake instance = new EntityPlayerMPFake(server, worldIn, finalGameProfile, ClientInformation.createDefault(), false);
+            instance.fixStartingPosition = () -> instance.moveTo(pos.getX(), pos.getY(), pos.getZ(), (float) yaw, (float) pitch);
+            server.getPlayerList().placeNewPlayer(new FakeClientConnection(PacketFlow.SERVERBOUND), instance, new CommonListenerCookie(finalGameProfile, 0, instance.clientInformation(), false), Optional.empty(), username, new Location(world, pos.getX(), pos.getY(), pos.getZ(), (float) yaw, (float) pitch));
+            instance.setHealth(20.0F);
+            instance.unsetRemoved();
+            //noinspection DataFlowIssue
+            instance.getAttribute(Attributes.STEP_HEIGHT).setBaseValue(0.6F);
+            instance.gameMode.changeGameModeForPlayer(gamemode);
+            server.getPlayerList().broadcastAll(new ClientboundRotateHeadPacket(instance, (byte) (instance.yHeadRot * 256 / 360)), worldIn.dimension());// instance.dimension);
+            server.getPlayerList().broadcastAll(new ClientboundTeleportEntityPacket(instance), worldIn.dimension());// instance.dimension);
+            // instance.world.getChunkManager(). updatePosition(instance);
+            instance.entityData.set(DATA_PLAYER_MODE_CUSTOMISATION, (byte) 0x7f); // show all model layers (incl. capes)
+            instance.getAbilities().flying = flying;
+        });
+        //         }
+        // );
+        return true;
+    }
+
+    private static @NotNull CompletableFuture<Optional<GameProfile>> fetchGameProfile(final String name) {
+        return SkullBlockEntity.fetchGameProfile(name);
+    }
+
+    public static @NotNull EntityPlayerMPFake createShadow(MinecraftServer server, @NotNull ServerPlayer player) {
+        //noinspection DataFlowIssue
+        player.getServer().getPlayerList().remove(player);
+        player.connection.disconnect(Component.translatable("multiplayer.disconnect.duplicate_login"), PlayerKickEvent.Cause.DUPLICATE_LOGIN);
+        ServerLevel worldIn = player.serverLevel();
+        GameProfile gameprofile = player.getGameProfile();
+        EntityPlayerMPFake playerShadow = new EntityPlayerMPFake(server, worldIn, gameprofile, player.clientInformation(), true);
+        //noinspection DataFlowIssue
+        playerShadow.setChatSession(player.getChatSession());
+        server.getPlayerList().placeNewPlayer(new FakeClientConnection(PacketFlow.SERVERBOUND), playerShadow, new CommonListenerCookie(gameprofile, 0, player.clientInformation(), true), Optional.empty(), player.getScoreboardName(), ((org.bukkit.entity.Player) player).getLocation());
+        playerShadow.setHealth(player.getHealth());
+        playerShadow.gameMode.changeGameModeForPlayer(player.gameMode.getGameModeForPlayer());
+        playerShadow.getActionPack().copyFrom(player.getActionPack());
+        // this might create problems if a player logs back in...
+        //noinspection DataFlowIssue
+        playerShadow.getAttribute(Attributes.STEP_HEIGHT).setBaseValue(0.6F);
+        playerShadow.entityData.set(DATA_PLAYER_MODE_CUSTOMISATION, player.getEntityData().get(DATA_PLAYER_MODE_CUSTOMISATION));
+        server.getPlayerList().broadcastAll(new ClientboundRotateHeadPacket(playerShadow, (byte) (player.yHeadRot * 256 / 360)), playerShadow.level().dimension());
+        server.getPlayerList().broadcastAll(new ClientboundPlayerInfoUpdatePacket(ClientboundPlayerInfoUpdatePacket.Action.ADD_PLAYER, playerShadow));
+        // player.world.getChunkManager().updatePosition(playerShadow);
+        playerShadow.getAbilities().flying = player.getAbilities().flying;
+        return playerShadow;
+    }
+
+    // in carpet this will inject to PlayerList, but maybe it isn't necessary
+    @Contract("_, _, _, _ -> new")
+    public static @NotNull EntityPlayerMPFake respawnFake(MinecraftServer server, ServerLevel level, GameProfile profile, ClientInformation cli) {
+        return new EntityPlayerMPFake(server, level, profile, cli, false);
+    }
+
+    private EntityPlayerMPFake(MinecraftServer server, ServerLevel worldIn, GameProfile profile, ClientInformation cli, boolean shadow) {
+        super(server, worldIn, profile, cli);
+        isAShadow = shadow;
+    }
+
+    @Override
+    public void onEquipItem(final @NotNull EquipmentSlot slot, final @NotNull ItemStack previous, final @NotNull ItemStack stack) {
+        if (!isUsingItem()) super.onEquipItem(slot, previous, stack);
+    }
+
+    @Override
+    public void kill() {
+        kill(Messenger.s("Killed"));
+    }
+
+    public void kill(@NotNull Component reason) {
+        shakeOff();
+
+        if (reason.getContents() instanceof TranslatableContents text && "multiplayer.disconnect.duplicate_login".equals(text.getKey())) {
+            this.connection.onDisconnect(reason);
+        } else {
+            this.getBukkitEntity().taskScheduler.schedule(
+                    (Consumer<? extends Entity>) scheduledTask -> this.connection.onDisconnect(reason),
+                    null,
+                    1
+            );
+            // this.server.tell(new TickTask(this.tickCount, () -> this.connection.onDisconnect(reason)));
+        }
+    }
+
+    @Override
+    public void tick() {
+        if (this.tickCount % 10 == 0) {
+            this.connection.resetPosition();
+            //noinspection resource
+            this.serverLevel().getChunkSource().move(this);
+        }
+        try {
+            super.tick();
+            this.doTick();
+        } catch (NullPointerException ignored) {
+            // happens with that paper port thingy - not sure what that would fix, but hey
+            // the game not gonna crash violently.
+        }
+
+
+    }
+
+    private void shakeOff() {
+        if (getVehicle() instanceof Player) stopRiding();
+        for (Entity passenger : getIndirectPassengers()) {
+            if (passenger instanceof Player) passenger.stopRiding();
+        }
+    }
+
+    @Override
+    public void die(@NotNull DamageSource cause) {
+        shakeOff();
+        super.die(cause);
+        setHealth(20);
+        this.foodData = new FoodData();
+        kill(this.getCombatTracker().getDeathMessage());
+    }
+
+    @Override
+    public @NotNull String getIpAddress() {
+        return "127.0.0.1";
+    }
+
+    @Override
+    public boolean allowsListing() {
+        return CarpetConfig.configModule.allowListingFakePlayers;
+    }
+
+    @Override
+    protected void checkFallDamage(double y, boolean onGround, @NotNull BlockState state, @NotNull BlockPos pos) {
+        doCheckFallDamage(0.0, y, 0.0, onGround);
+    }
+
+    @Override
+    public Entity changeDimension(@NotNull ServerLevel serverLevel) {
+        super.changeDimension(serverLevel);
+        if (wonGame) {
+            ServerboundClientCommandPacket p = new ServerboundClientCommandPacket(ServerboundClientCommandPacket.Action.PERFORM_RESPAWN);
+            connection.handleClientCommand(p);
+        }
+
+        // If above branch was taken, *this* has been removed and replaced, the new instance has been set
+        // on 'our' connection (which is now theirs, but we still have a ref).
+        if (connection.player.isChangingDimension()) {
+            connection.player.hasChangedDimension();
+        }
+        return connection.player;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/patches/FakeClientConnection.java b/src/main/java/org/leavesmc/lumina/carpet/patches/FakeClientConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..7df2dd9009f227f9cd8f87849475f7d1c83d4519
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/patches/FakeClientConnection.java
@@ -0,0 +1,32 @@
+package org.leavesmc.lumina.carpet.patches;
+
+import io.netty.channel.embedded.EmbeddedChannel;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketListener;
+import net.minecraft.network.ProtocolInfo;
+import net.minecraft.network.protocol.PacketFlow;
+
+public class FakeClientConnection extends Connection {
+    public FakeClientConnection(PacketFlow p) {
+        super(p);
+        // compat with adventure-platform-fabric. This does NOT trigger other vanilla handlers for establishing a channel
+        // also makes #isOpen return true, allowing enderpearls to teleport fake players
+        this.setChannel(new EmbeddedChannel());
+    }
+
+    @Override
+    public void setReadOnly() {
+    }
+
+    @Override
+    public void handleDisconnection() {
+    }
+
+    @Override
+    public void setListenerForServerboundHandshake(PacketListener packetListener) {
+    }
+
+    @Override
+    public <T extends PacketListener> void setupInboundProtocol(ProtocolInfo<T> protocolInfo, T packetListener) {
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/patches/NetHandlerPlayServerFake.java b/src/main/java/org/leavesmc/lumina/carpet/patches/NetHandlerPlayServerFake.java
new file mode 100644
index 0000000000000000000000000000000000000000..83c53a2021a34da59fc58354a212cab118a7d30a
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/patches/NetHandlerPlayServerFake.java
@@ -0,0 +1,49 @@
+package org.leavesmc.lumina.carpet.patches;
+
+import net.minecraft.network.Connection;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.CommonListenerCookie;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.world.entity.RelativeMovement;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Set;
+
+public class NetHandlerPlayServerFake extends ServerGamePacketListenerImpl {
+    public NetHandlerPlayServerFake(final MinecraftServer minecraftServer, final Connection connection, final ServerPlayer serverPlayer, final CommonListenerCookie i) {
+        super(minecraftServer, connection, serverPlayer, i);
+    }
+
+    @Override
+    public void send(final @NotNull Packet<?> packetIn) {
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void disconnect(@NotNull Component message) {
+        if (message.getContents() instanceof TranslatableContents text && (text.getKey().equals("multiplayer.disconnect.idling") || text.getKey().equals("multiplayer.disconnect.duplicate_login"))) {
+            ((EntityPlayerMPFake) player).kill(message);
+        }
+    }
+
+    @Override
+    public void disconnect(@NotNull Component message, PlayerKickEvent.@NotNull Cause cause) {
+        disconnect(message);
+    }
+
+    @SuppressWarnings("resource")
+    @Override
+    public void teleport(double d, double e, double f, float g, float h, @NotNull Set<RelativeMovement> set) {
+        super.teleport(d, e, f, g, h, set);
+        if (player.serverLevel().getPlayerByUUID(player.getUUID()) != null) {
+            resetPosition();
+            player.serverLevel().getChunkSource().move(player);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/script/utils/Colors.java b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Colors.java
new file mode 100644
index 0000000000000000000000000000000000000000..a85fc086dfd15b30d6066fd888fb17507dd0e26d
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Colors.java
@@ -0,0 +1,155 @@
+package org.leavesmc.lumina.carpet.script.utils;
+
+import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.material.MapColor;
+
+import java.util.Map;
+
+import static java.util.Map.entry;
+
+public class Colors {
+    public static final Map<SoundType, String> soundName = Map.<SoundType, String>ofEntries(
+            entry(SoundType.WOOD, "wood"),
+            entry(SoundType.GRAVEL, "gravel"),
+            entry(SoundType.GRASS, "grass"),
+            entry(SoundType.LILY_PAD, "lily_pad"),
+            entry(SoundType.STONE, "stone"),
+            entry(SoundType.METAL, "metal"),
+            entry(SoundType.GLASS, "glass"),
+            entry(SoundType.WOOL, "wool"),
+            entry(SoundType.SAND, "sand"),
+            entry(SoundType.SNOW, "snow"),
+            entry(SoundType.POWDER_SNOW, "powder_snow"),
+            entry(SoundType.LADDER, "ladder"),
+            entry(SoundType.ANVIL, "anvil"),
+            entry(SoundType.SLIME_BLOCK, "slime"),
+            entry(SoundType.HONEY_BLOCK, "honey"),
+            entry(SoundType.WET_GRASS, "sea_grass"),
+            entry(SoundType.CORAL_BLOCK, "coral"),
+            entry(SoundType.BAMBOO, "bamboo"),
+            entry(SoundType.BAMBOO_SAPLING, "shoots"),
+            entry(SoundType.SCAFFOLDING, "scaffolding"),
+            entry(SoundType.SWEET_BERRY_BUSH, "berry"),
+            entry(SoundType.CROP, "crop"),
+            entry(SoundType.HARD_CROP, "stem"),
+            entry(SoundType.VINE, "vine"),
+            entry(SoundType.NETHER_WART, "wart"),
+            entry(SoundType.LANTERN, "lantern"),
+            entry(SoundType.STEM, "fungi_stem"),
+            entry(SoundType.NYLIUM, "nylium"),
+            entry(SoundType.FUNGUS, "fungus"),
+            entry(SoundType.ROOTS, "roots"),
+            entry(SoundType.SHROOMLIGHT, "shroomlight"),
+            entry(SoundType.WEEPING_VINES, "weeping_vine"),
+            entry(SoundType.TWISTING_VINES, "twisting_vine"),
+            entry(SoundType.SOUL_SAND, "soul_sand"),
+            entry(SoundType.SOUL_SOIL, "soul_soil"),
+            entry(SoundType.BASALT, "basalt"),
+            entry(SoundType.WART_BLOCK, "wart"),
+            entry(SoundType.NETHERRACK, "netherrack"),
+            entry(SoundType.NETHER_BRICKS, "nether_bricks"),
+            entry(SoundType.NETHER_SPROUTS, "nether_sprouts"),
+            entry(SoundType.NETHER_ORE, "nether_ore"),
+            entry(SoundType.BONE_BLOCK, "bone"),
+            entry(SoundType.NETHERITE_BLOCK, "netherite"),
+            entry(SoundType.ANCIENT_DEBRIS, "ancient_debris"),
+            entry(SoundType.LODESTONE, "lodestone"),
+            entry(SoundType.CHAIN, "chain"),
+            entry(SoundType.NETHER_GOLD_ORE, "nether_gold_ore"),
+            entry(SoundType.GILDED_BLACKSTONE, "gilded_blackstone"),
+            entry(SoundType.CANDLE, "candle"),
+            entry(SoundType.AMETHYST, "amethyst"),
+            entry(SoundType.AMETHYST_CLUSTER, "amethyst_cluster"),
+            entry(SoundType.SMALL_AMETHYST_BUD, "small_amethyst_bud"),
+            entry(SoundType.MEDIUM_AMETHYST_BUD, "medium_amethyst_bud"),
+            entry(SoundType.LARGE_AMETHYST_BUD, "large_amethyst_bud"),
+
+            entry(SoundType.TUFF, "tuff"),
+            entry(SoundType.CALCITE, "calcite"),
+            entry(SoundType.DRIPSTONE_BLOCK, "dripstone"),
+            entry(SoundType.POINTED_DRIPSTONE, "pointed_dripstone"),
+            entry(SoundType.COPPER, "copper"),
+            entry(SoundType.CAVE_VINES, "cave_vine"),
+            entry(SoundType.SPORE_BLOSSOM, "spore_blossom"),
+            entry(SoundType.AZALEA, "azalea"),
+            entry(SoundType.FLOWERING_AZALEA, "flowering_azalea"),
+            entry(SoundType.MOSS_CARPET, "moss_carpet"),
+            entry(SoundType.MOSS, "moss"),
+            entry(SoundType.BIG_DRIPLEAF, "big_dripleaf"),
+            entry(SoundType.SMALL_DRIPLEAF, "small_dripleaf"),
+            entry(SoundType.ROOTED_DIRT, "rooted_dirt"),
+            entry(SoundType.HANGING_ROOTS, "hanging_roots"),
+            entry(SoundType.AZALEA_LEAVES, "azalea_leaves"),
+            entry(SoundType.SCULK_SENSOR, "sculk_sensor"),
+            entry(SoundType.GLOW_LICHEN, "glow_lichen"),
+            entry(SoundType.DEEPSLATE, "deepslate"),
+            entry(SoundType.DEEPSLATE_BRICKS, "deepslate_bricks"),
+            entry(SoundType.DEEPSLATE_TILES, "deepslate_tiles"),
+            entry(SoundType.POLISHED_DEEPSLATE, "polished_deepslate")
+    );
+
+    public static final Map<MapColor, String> mapColourName = Map.<MapColor, String>ofEntries(
+            entry(MapColor.NONE, "air"),
+            entry(MapColor.GRASS, "grass"),
+            entry(MapColor.SAND, "sand"),
+            entry(MapColor.WOOL, "wool"),
+            entry(MapColor.FIRE, "tnt"),
+            entry(MapColor.ICE, "ice"),
+            entry(MapColor.METAL, "iron"),
+            entry(MapColor.PLANT, "foliage"),
+            entry(MapColor.SNOW, "snow"),
+            entry(MapColor.CLAY, "clay"),
+            entry(MapColor.DIRT, "dirt"),
+            entry(MapColor.STONE, "stone"),
+            entry(MapColor.WATER, "water"),
+            entry(MapColor.WOOD, "wood"),
+            entry(MapColor.QUARTZ, "quartz"),
+            entry(MapColor.COLOR_ORANGE, "adobe"),
+            entry(MapColor.COLOR_MAGENTA, "magenta"),
+            entry(MapColor.COLOR_LIGHT_BLUE, "light_blue"),
+            entry(MapColor.COLOR_YELLOW, "yellow"),
+            entry(MapColor.COLOR_LIGHT_GREEN, "lime"),
+            entry(MapColor.COLOR_PINK, "pink"),
+            entry(MapColor.COLOR_GRAY, "gray"),
+            entry(MapColor.COLOR_LIGHT_GRAY, "light_gray"),
+            entry(MapColor.COLOR_CYAN, "cyan"),
+            entry(MapColor.COLOR_PURPLE, "purple"),
+            entry(MapColor.COLOR_BLUE, "blue"),
+            entry(MapColor.COLOR_BROWN, "brown"),
+            entry(MapColor.COLOR_GREEN, "green"),
+            entry(MapColor.COLOR_RED, "red"),
+            entry(MapColor.COLOR_BLACK, "black"),
+            entry(MapColor.GOLD, "gold"),
+            entry(MapColor.DIAMOND, "diamond"),
+            entry(MapColor.LAPIS, "lapis"),
+            entry(MapColor.EMERALD, "emerald"),
+            entry(MapColor.PODZOL, "obsidian"),
+            entry(MapColor.NETHER, "netherrack"), // TODO fix these
+            entry(MapColor.TERRACOTTA_WHITE, "white_terracotta"),
+            entry(MapColor.TERRACOTTA_ORANGE, "orange_terracotta"),
+            entry(MapColor.TERRACOTTA_MAGENTA, "magenta_terracotta"),
+            entry(MapColor.TERRACOTTA_LIGHT_BLUE, "light_blue_terracotta"),
+            entry(MapColor.TERRACOTTA_YELLOW, "yellow_terracotta"),
+            entry(MapColor.TERRACOTTA_LIGHT_GREEN, "lime_terracotta"),
+            entry(MapColor.TERRACOTTA_PINK, "pink_terracotta"),
+            entry(MapColor.TERRACOTTA_GRAY, "gray_terracotta"),
+            entry(MapColor.TERRACOTTA_LIGHT_GRAY, "light_gray_terracotta"),
+            entry(MapColor.TERRACOTTA_CYAN, "cyan_terracotta"),
+            entry(MapColor.TERRACOTTA_PURPLE, "purple_terracotta"),
+            entry(MapColor.TERRACOTTA_BLUE, "blue_terracotta"),
+            entry(MapColor.TERRACOTTA_BROWN, "brown_terracotta"),
+            entry(MapColor.TERRACOTTA_GREEN, "green_terracotta"),
+            entry(MapColor.TERRACOTTA_RED, "red_terracotta"),
+            entry(MapColor.TERRACOTTA_BLACK, "black_terracotta"),
+            entry(MapColor.CRIMSON_NYLIUM, "crimson_nylium"),
+            entry(MapColor.CRIMSON_STEM, "crimson_stem"),
+            entry(MapColor.CRIMSON_HYPHAE, "crimson_hyphae"),
+            entry(MapColor.WARPED_NYLIUM, "warped_nylium"),
+            entry(MapColor.WARPED_STEM, "warped_stem"),
+            entry(MapColor.WARPED_HYPHAE, "warped_hyphae"),
+            entry(MapColor.WARPED_WART_BLOCK, "warped_wart"),
+            entry(MapColor.DEEPSLATE, "deepslate"),
+            entry(MapColor.RAW_IRON, "raw_iron"),
+            entry(MapColor.GLOW_LICHEN, "glow_lichen")
+    );
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/script/utils/ParticleParser.java b/src/main/java/org/leavesmc/lumina/carpet/script/utils/ParticleParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..61d41fcfcb1351453a83926506d8fb5fef0072f7
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/script/utils/ParticleParser.java
@@ -0,0 +1,43 @@
+package org.leavesmc.lumina.carpet.script.utils;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.minecraft.commands.arguments.ParticleArgument;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.particles.ParticleOptions;
+
+import javax.annotation.Nullable;
+import java.util.HashMap;
+import java.util.Map;
+
+public class ParticleParser
+{
+    private static final Map<String, ParticleOptions> particleCache = new HashMap<>(); // we reset this on reloads, but probably need something better
+
+    private static ParticleOptions parseParticle(String name, RegistryAccess lookup)
+    {
+        try
+        {
+            return ParticleArgument.readParticle(new StringReader(name), lookup);
+        }
+        catch (CommandSyntaxException e)
+        {
+            throw new IllegalArgumentException("No such particle: " + name);
+        }
+    }
+
+    @Nullable
+    public static ParticleOptions getEffect(@Nullable String name, RegistryAccess lookup)
+    {
+        if (name == null)
+        {
+            return null;
+        }
+        return particleCache.computeIfAbsent(name, particle -> parseParticle(particle, lookup));
+    }
+
+    public static void resetCache()
+    {
+        particleCache.clear();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/script/utils/Tracer.java b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Tracer.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc9b7281eadf2ca97ded226c19559b0d3d5334b5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Tracer.java
@@ -0,0 +1,74 @@
+package org.leavesmc.lumina.carpet.script.utils;
+
+import java.util.Optional;
+import java.util.function.Predicate;
+
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+
+public class Tracer {
+    public static HitResult rayTrace(Entity source, float partialTicks, double reach, boolean fluids) {
+        BlockHitResult blockHit = rayTraceBlocks(source, partialTicks, reach, fluids);
+        double maxSqDist = reach * reach;
+        if (blockHit != null) {
+            maxSqDist = blockHit.getLocation().distanceToSqr(source.getEyePosition(partialTicks));
+        }
+        EntityHitResult entityHit = rayTraceEntities(source, partialTicks, reach, maxSqDist);
+        return entityHit == null ? blockHit : entityHit;
+    }
+
+    public static BlockHitResult rayTraceBlocks(Entity source, float partialTicks, double reach, boolean fluids) {
+        Vec3 pos = source.getEyePosition(partialTicks);
+        Vec3 rotation = source.getViewVector(partialTicks);
+        Vec3 reachEnd = pos.add(rotation.x * reach, rotation.y * reach, rotation.z * reach);
+        return source.level().clip(new ClipContext(pos, reachEnd, ClipContext.Block.OUTLINE, fluids ?
+                ClipContext.Fluid.ANY : ClipContext.Fluid.NONE, source));
+    }
+
+    public static EntityHitResult rayTraceEntities(Entity source, float partialTicks, double reach, double maxSqDist) {
+        Vec3 pos = source.getEyePosition(partialTicks);
+        Vec3 reachVec = source.getViewVector(partialTicks).scale(reach);
+        AABB box = source.getBoundingBox().expandTowards(reachVec).inflate(1);
+        return rayTraceEntities(source, pos, pos.add(reachVec), box, e -> !e.isSpectator() && e.isPickable(), maxSqDist);
+    }
+
+    public static EntityHitResult rayTraceEntities(Entity source, Vec3 start, Vec3 end, AABB box, Predicate<Entity> predicate, double maxSqDistance) {
+        Level world = source.level();
+        double targetDistance = maxSqDistance;
+        Entity target = null;
+        Vec3 targetHitPos = null;
+        for (Entity current : world.getEntities(source, box, predicate)) {
+            AABB currentBox = current.getBoundingBox().inflate(current.getPickRadius());
+            Optional<Vec3> currentHit = currentBox.clip(start, end);
+            if (currentBox.contains(start)) {
+                if (targetDistance >= 0) {
+                    target = current;
+                    targetHitPos = currentHit.orElse(start);
+                    targetDistance = 0;
+                }
+            } else if (currentHit.isPresent()) {
+                Vec3 currentHitPos = currentHit.get();
+                double currentDistance = start.distanceToSqr(currentHitPos);
+                if (currentDistance < targetDistance || targetDistance == 0) {
+                    if (current.getRootVehicle() == source.getRootVehicle()) {
+                        if (targetDistance == 0) {
+                            target = current;
+                            targetHitPos = currentHitPos;
+                        }
+                    } else {
+                        target = current;
+                        targetHitPos = currentHitPos;
+                        targetDistance = currentDistance;
+                    }
+                }
+            }
+        }
+        return target == null ? null : new EntityHitResult(target, targetHitPos);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/BlockInfo.java b/src/main/java/org/leavesmc/lumina/carpet/utils/BlockInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..029be60570be67ce8f85df7932e7d6945de43f96
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/BlockInfo.java
@@ -0,0 +1,112 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.leavesmc.lumina.carpet.script.utils.Colors;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MobSpawnType;
+import net.minecraft.world.entity.PathfinderMob;
+import net.minecraft.world.entity.ai.goal.RandomStrollGoal;
+import net.minecraft.world.entity.ai.util.DefaultRandomPos;
+import net.minecraft.world.entity.monster.ZombifiedPiglin;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.phys.Vec3;
+
+public class BlockInfo
+{
+    public static List<Component> blockInfo(BlockPos pos, ServerLevel world)
+    {
+        BlockState state = world.getBlockState(pos);
+        Block block = state.getBlock();
+        String metastring = "";
+        final Registry<Block> blocks = world.registryAccess().registryOrThrow(Registries.BLOCK);
+        for (net.minecraft.world.level.block.state.properties.Property<?> iproperty : state.getProperties())
+        {
+            metastring += ", "+iproperty.getName() + '='+state.getValue(iproperty);
+        }
+        List<Component> lst = new ArrayList<>();
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s("====================================="));
+        lst.add(Messenger.s(String.format("Block info for %s%s (id %d%s):", blocks.getKey(block),metastring, blocks.getId(block), metastring )));
+        lst.add(Messenger.s(String.format(" - Map colour: %s", Colors.mapColourName.get(state.getMapColor(world, pos)))));
+        lst.add(Messenger.s(String.format(" - Sound type: %s", Colors.soundName.get(state.getSoundType()))));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Full block: %s", state.isCollisionShapeFullBlock(world, pos)))); //  isFullCube() )));
+        lst.add(Messenger.s(String.format(" - Normal cube: %s", state.isRedstoneConductor(world, pos)))); //isNormalCube()))); isSimpleFullBlock
+        lst.add(Messenger.s(String.format(" - Is liquid: %s", state.is(Blocks.WATER) || state.is(Blocks.LAVA))));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Light in: %d, above: %d",
+                Math.max(world.getBrightness(LightLayer.BLOCK, pos),world.getBrightness(LightLayer.SKY, pos)) ,
+                Math.max(world.getBrightness(LightLayer.BLOCK, pos.above()),world.getBrightness(LightLayer.SKY, pos.above())))));
+        lst.add(Messenger.s(String.format(" - Brightness in: %.2f, above: %.2f", world.getLightLevelDependentMagicValue(pos), world.getLightLevelDependentMagicValue(pos.above()))));
+        lst.add(Messenger.s(String.format(" - Is opaque: %s", state.isSolid() )));
+        //lst.add(Messenger.s(String.format(" - Light opacity: %d", state.getOpacity(world,pos))));
+        //lst.add(Messenger.s(String.format(" - Emitted light: %d", state.getLightValue())));
+        //lst.add(Messenger.s(String.format(" - Picks neighbour light value: %s", state.useNeighborBrightness(world, pos))));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Causes suffocation: %s", state.isSuffocating(world, pos)))); //canSuffocate
+        lst.add(Messenger.s(String.format(" - Blocks movement on land: %s", !state.isPathfindable(PathComputationType.LAND))));
+        lst.add(Messenger.s(String.format(" - Blocks movement in air: %s", !state.isPathfindable(PathComputationType.AIR))));
+        lst.add(Messenger.s(String.format(" - Blocks movement in liquids: %s", !state.isPathfindable(PathComputationType.WATER))));
+        lst.add(Messenger.s(String.format(" - Can burn: %s", state.ignitedByLava())));
+        lst.add(Messenger.s(String.format(" - Hardness: %.2f", state.getDestroySpeed(world, pos))));
+        lst.add(Messenger.s(String.format(" - Blast resistance: %.2f", block.getExplosionResistance())));
+        lst.add(Messenger.s(String.format(" - Ticks randomly: %s", state.isRandomlyTicking())));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Can provide power: %s", state.isSignalSource())));
+        lst.add(Messenger.s(String.format(" - Strong power level: %d", world.getDirectSignalTo(pos))));
+        lst.add(Messenger.s(String.format(" - Redstone power level: %d", world.getBestNeighborSignal(pos))));
+        lst.add(Messenger.s(""));
+        lst.add(wander_chances(pos.above(), world));
+
+        return lst;
+    }
+
+    private static Component wander_chances(BlockPos pos, ServerLevel worldIn)
+    {
+        PathfinderMob creature = new ZombifiedPiglin(EntityType.ZOMBIFIED_PIGLIN, worldIn);
+        creature.finalizeSpawn(worldIn, worldIn.getCurrentDifficultyAt(pos), MobSpawnType.NATURAL, null);
+        creature.moveTo(pos, 0.0F, 0.0F);
+        RandomStrollGoal wander = new RandomStrollGoal(creature, 0.8D);
+        int success = 0;
+        for (int i=0; i<1000; i++)
+        {
+
+            Vec3 vec = DefaultRandomPos.getPos(creature, 10, 7); // TargetFinder.findTarget(creature, 10, 7);
+            if (vec == null)
+            {
+                continue;
+            }
+            success++;
+        }
+        long total_ticks = 0;
+        for (int trie=0; trie<1000; trie++)
+        {
+            int i;
+            for (i=1;i<30*20*60; i++) //*60 used to be 5 hours, limited to 30 mins
+            {
+                if (wander.canUse())
+                {
+                    break;
+                }
+            }
+            total_ticks += 3*i;
+        }
+        creature.discard(); // discarded // remove(Entity.RemovalReason.field_26999); // 2nd option - DISCARDED
+        long total_time = (total_ticks)/1000/20;
+        return Messenger.s(String.format(" - Wander chance above: %.1f%%\n - Average standby above: %s",
+                (100.0F*success)/1000,
+                ((total_time>5000)?"INFINITY":(total_time +" s"))
+        ));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/CarpetRulePrinter.java b/src/main/java/org/leavesmc/lumina/carpet/utils/CarpetRulePrinter.java
new file mode 100644
index 0000000000000000000000000000000000000000..1affe86d3db96ccf54f2f74741ef82e0e94c064d
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/CarpetRulePrinter.java
@@ -0,0 +1,63 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import joptsimple.OptionParser;
+import joptsimple.OptionSet;
+import joptsimple.OptionSpec;
+import joptsimple.util.PathConverter;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.lang.System;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Provides a command line interface to generate a dump with all rules
+ * in a pretty markdown format to a specified file, with an optional
+ * category filter
+ */
+public class CarpetRulePrinter {
+    public void onInitializeServer() {
+        // When launching, we use the "--" separator to prevent the game rejecting to launch because of unknown options
+        // Clear it in case it's present given else our option parser would also ignore them!
+        String[] args = new String[]{};
+        // Arrays.stream(FabricLoader.getInstance().getLaunchArguments(true)).filter(opt -> !opt.equals("--")).toArray(String[]::new); // TODO
+
+        // Prepare an OptionParser for our parameters
+        OptionParser parser = new OptionParser();
+        OptionSpec<Void> shouldDump = parser.accepts("carpetDumpRules");
+        OptionSpec<Path> pathSpec = parser.accepts("dumpPath").withRequiredArg().withValuesConvertedBy(new PathConverter());
+        OptionSpec<String> filterSpec = parser.accepts("dumpFilter").withRequiredArg();
+        parser.allowsUnrecognizedOptions(); // minecraft may need more stuff later that we don't want to special-case
+        OptionSet options = parser.parse(args);
+        // If our flag isn't set, continue regular launch
+        if (!options.has(shouldDump)) return;
+
+
+        Logger logger = LoggerFactory.getLogger("Carpet Rule Printer");
+        logger.info("Starting in rule dump mode...");
+        // at this point, onGameStarted() already ran given it as an entrypoint runs before
+        PrintStream outputStream;
+        try {
+            Path path = options.valueOf(pathSpec).toAbsolutePath();
+            logger.info("Printing rules to: " + path);
+            Files.createDirectories(path.getParent());
+            outputStream = new PrintStream(Files.newOutputStream(path));
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+        // Ensure translations fallbacks have been generated given we run before the validator that ensures that has.
+        // Remove after removing old setting system, given there'll be no fallbacks
+        Translations.updateLanguage();
+        String filter = options.valueOf(filterSpec);
+        if (filter != null) logger.info("Applying category filter: " + filter);
+        // CarpetServer.settingsManager.dumpAllRulesToStream(outputStream, filter); // TODO
+        outputStream.close();
+        logger.info("Rules have been printed");
+        System.exit(0);
+    }
+}
+
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/DistanceCalculator.java b/src/main/java/org/leavesmc/lumina/carpet/utils/DistanceCalculator.java
new file mode 100644
index 0000000000000000000000000000000000000000..c38c4d459eb10876cc0e9a8d9d0c4be52ba1240c
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/DistanceCalculator.java
@@ -0,0 +1,57 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.Vec3;
+
+public class DistanceCalculator {
+    public static final HashMap<String, Vec3> START_POINT_STORAGE = new HashMap<>();
+
+    public static boolean hasStartingPoint(CommandSourceStack source) {
+        return START_POINT_STORAGE.containsKey(source.getTextName());
+    }
+
+    public static List<Component> findDistanceBetweenTwoPoints(Vec3 pos1, Vec3 pos2) {
+        double dx = Mth.abs((float) pos1.x - (float) pos2.x);
+        double dy = Mth.abs((float) pos1.y - (float) pos2.y);
+        double dz = Mth.abs((float) pos1.z - (float) pos2.z);
+        double manhattan = dx + dy + dz;
+        double spherical = Math.sqrt(dx * dx + dy * dy + dz * dz);
+        double cylindrical = Math.sqrt(dx * dx + dz * dz);
+        List<Component> res = new ArrayList<>();
+        res.add(Messenger.c("w Distance between ",
+                Messenger.tp("c", pos1), "w  and ",
+                Messenger.tp("c", pos2), "w :"));
+        res.add(Messenger.c("w  - Spherical: ", String.format("wb %.2f", spherical)));
+        res.add(Messenger.c("w  - Cylindrical: ", String.format("wb %.2f", cylindrical)));
+        res.add(Messenger.c("w  - Manhattan: ", String.format("wb %.1f", manhattan)));
+        return res;
+    }
+
+    public static int distance(CommandSourceStack source, Vec3 pos1, Vec3 pos2) {
+        Messenger.send(source, findDistanceBetweenTwoPoints(pos1, pos2));
+        return 1;
+    }
+
+    public static int setStart(CommandSourceStack source, Vec3 pos) {
+        START_POINT_STORAGE.put(source.getTextName(), pos);
+        Messenger.m(source, "gi Initial point set to: ", Messenger.tp("g", pos));
+        return 1;
+    }
+
+    public static int setEnd(CommandSourceStack source, Vec3 pos) {
+        if (!hasStartingPoint(source)) {
+            START_POINT_STORAGE.put(source.getTextName(), pos);
+            Messenger.m(source, "gi There was no initial point for " + source.getTextName());
+            Messenger.m(source, "gi Initial point set to: ", Messenger.tp("g", pos));
+            return 0;
+        }
+        Messenger.send(source, findDistanceBetweenTwoPoints(START_POINT_STORAGE.get(source.getTextName()), pos));
+        return 1;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/EvictingQueue.java b/src/main/java/org/leavesmc/lumina/carpet/utils/EvictingQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..3da1c5a39484ae2e0b394ab02f48e0fac0872e15
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/EvictingQueue.java
@@ -0,0 +1,15 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public class EvictingQueue<K> extends LinkedHashMap<K, Integer> {
+    public void put(K key) {
+        super.put(key, 1);
+    }
+
+    @Override
+    protected boolean removeEldestEntry(Map.Entry<K, Integer> eldest) {
+        return this.size() > 10;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/Messenger.java b/src/main/java/org/leavesmc/lumina/carpet/utils/Messenger.java
new file mode 100644
index 0000000000000000000000000000000000000000..0eb66c8bd216e84e5ad946b9cc4c2507a4fd0702
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/Messenger.java
@@ -0,0 +1,307 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import net.minecraft.ChatFormatting;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.ClickEvent;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.command.CommandSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class Messenger {
+    public static final Logger LOG = LoggerFactory.getLogger("Messaging System");
+
+    private static final Pattern colorExtract = Pattern.compile("#([0-9a-fA-F]{6})");
+
+    public enum CarpetFormatting {
+        ITALIC('i', (s, f) -> s.withItalic(true)),
+        STRIKE('s', (s, f) -> s.applyFormat(ChatFormatting.STRIKETHROUGH)),
+        UNDERLINE('u', (s, f) -> s.applyFormat(ChatFormatting.UNDERLINE)),
+        BOLD('b', (s, f) -> s.withBold(true)),
+        OBFUSCATE('o', (s, f) -> s.applyFormat(ChatFormatting.OBFUSCATED)),
+
+        WHITE('w', (s, f) -> s.withColor(ChatFormatting.WHITE)),
+        YELLOW('y', (s, f) -> s.withColor(ChatFormatting.YELLOW)),
+        LIGHT_PURPLE('m', (s, f) -> s.withColor(ChatFormatting.LIGHT_PURPLE)), // magenta
+        RED('r', (s, f) -> s.withColor(ChatFormatting.RED)),
+        AQUA('c', (s, f) -> s.withColor(ChatFormatting.AQUA)), // cyan
+        GREEN('l', (s, f) -> s.withColor(ChatFormatting.GREEN)), // lime
+        BLUE('t', (s, f) -> s.withColor(ChatFormatting.BLUE)), // light blue, teal
+        DARK_GRAY('f', (s, f) -> s.withColor(ChatFormatting.DARK_GRAY)),
+        GRAY('g', (s, f) -> s.withColor(ChatFormatting.GRAY)),
+        GOLD('d', (s, f) -> s.withColor(ChatFormatting.GOLD)),
+        DARK_PURPLE('p', (s, f) -> s.withColor(ChatFormatting.DARK_PURPLE)), // purple
+        DARK_RED('n', (s, f) -> s.withColor(ChatFormatting.DARK_RED)),  // brown
+        DARK_AQUA('q', (s, f) -> s.withColor(ChatFormatting.DARK_AQUA)),
+        DARK_GREEN('e', (s, f) -> s.withColor(ChatFormatting.DARK_GREEN)),
+        DARK_BLUE('v', (s, f) -> s.withColor(ChatFormatting.DARK_BLUE)), // navy
+        BLACK('k', (s, f) -> s.withColor(ChatFormatting.BLACK)),
+
+        COLOR('#', (s, f) -> {
+            TextColor color;
+            try {
+                color = TextColor.parseColor("#" + f).getOrThrow(RuntimeException::new);
+            } catch (RuntimeException e) {
+                return s;
+            }
+            return color == null ? s : s.withColor(color);
+        }, s -> {
+            Matcher m = colorExtract.matcher(s);
+            return m.find() ? m.group(1) : null;
+        }),
+        ;
+
+        public char code;
+        public BiFunction<Style, String, Style> applier;
+        public Function<String, String> container;
+
+        CarpetFormatting(char code, BiFunction<Style, String, Style> applier) {
+            this(code, applier, s -> s.indexOf(code) >= 0 ? Character.toString(code) : null);
+        }
+
+        CarpetFormatting(char code, BiFunction<Style, String, Style> applier, Function<String, String> container) {
+            this.code = code;
+            this.applier = applier;
+            this.container = container;
+        }
+
+        public Style apply(String format, Style previous) {
+            String fmt;
+            if ((fmt = container.apply(format)) != null) return applier.apply(previous, fmt);
+            return previous;
+        }
+    }
+
+    ;
+
+    public static Style parseStyle(String style) {
+        Style myStyle = Style.EMPTY.withColor(ChatFormatting.WHITE);
+        for (CarpetFormatting cf : CarpetFormatting.values()) myStyle = cf.apply(style, myStyle);
+        return myStyle;
+    }
+
+    public static String heatmap_color(double actual, double reference) {
+        String color = "g";
+        if (actual >= 0.0D) color = "e";
+        if (actual > 0.5D * reference) color = "y";
+        if (actual > 0.8D * reference) color = "r";
+        if (actual > reference) color = "m";
+        return color;
+    }
+
+    public static String creatureTypeColor(MobCategory type) {
+        return switch (type) {
+            case MONSTER -> "n";
+            case CREATURE -> "e";
+            case AMBIENT -> "f";
+            case WATER_CREATURE -> "v";
+            case WATER_AMBIENT -> "q";
+            default -> "w"; // missing MISC and UNDERGROUND_WATER_CREATURE
+        };
+    }
+
+    private static MutableComponent getChatComponentFromDesc(String message, MutableComponent previousMessage) {
+        if (message.equalsIgnoreCase("")) {
+            return Component.literal("");
+        }
+        if (Character.isWhitespace(message.charAt(0))) {
+            message = "w" + message;
+        }
+        int limit = message.indexOf(' ');
+        String desc = message;
+        String str = "";
+        if (limit >= 0) {
+            desc = message.substring(0, limit);
+            str = message.substring(limit + 1);
+        }
+        if (previousMessage == null) {
+            MutableComponent text = Component.literal(str);
+            text.setStyle(parseStyle(desc));
+            return text;
+        }
+        Style previousStyle = previousMessage.getStyle();
+        MutableComponent ret = previousMessage;
+        previousMessage.setStyle(switch (desc.charAt(0)) {
+            case '?' ->
+                    previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, message.substring(1)));
+            case '!' ->
+                    previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, message.substring(1)));
+            case '^' ->
+                    previousStyle.withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, c(message.substring(1))));
+            case '@' -> previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, message.substring(1)));
+            case '&' ->
+                    previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, message.substring(1)));
+            default -> { // Create a new component
+                ret = Component.literal(str);
+                ret.setStyle(parseStyle(desc));
+                yield previousStyle; // no op for the previous style
+            }
+        });
+        return ret;
+    }
+
+    public static Component tp(String desc, Vec3 pos) {
+        return tp(desc, pos.x, pos.y, pos.z);
+    }
+
+    public static Component tp(String desc, BlockPos pos) {
+        return tp(desc, pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    public static Component tp(String desc, double x, double y, double z) {
+        return tp(desc, (float) x, (float) y, (float) z);
+    }
+
+    public static Component tp(String desc, float x, float y, float z) {
+        return getCoordsTextComponent(desc, x, y, z, false);
+    }
+
+    public static Component tp(String desc, int x, int y, int z) {
+        return getCoordsTextComponent(desc, x, y, z, true);
+    }
+
+    /// to be continued
+    public static Component dbl(String style, double double_value) {
+        return c(String.format("%s %.1f", style, double_value), String.format("^w %f", double_value));
+    }
+
+    public static Component dbls(String style, double... doubles) {
+        StringBuilder str = new StringBuilder(style + " [ ");
+        String prefix = "";
+        for (double dbl : doubles) {
+            str.append(String.format("%s%.1f", prefix, dbl));
+            prefix = ", ";
+        }
+        str.append(" ]");
+        return c(str.toString());
+    }
+
+    public static Component dblf(String style, double... doubles) {
+        StringBuilder str = new StringBuilder(style + " [ ");
+        String prefix = "";
+        for (double dbl : doubles) {
+            str.append(String.format("%s%f", prefix, dbl));
+            prefix = ", ";
+        }
+        str.append(" ]");
+        return c(str.toString());
+    }
+
+    public static Component dblt(String style, double... doubles) {
+        List<Object> components = new ArrayList<>();
+        components.add(style + " [ ");
+        String prefix = "";
+        for (double dbl : doubles) {
+
+            components.add(String.format("%s %s%.1f", style, prefix, dbl));
+            components.add("?" + dbl);
+            components.add("^w " + dbl);
+            prefix = ", ";
+        }
+        // components.remove(components.size()-1);
+        components.add(style + "  ]");
+        return c(components.toArray(new Object[0]));
+    }
+
+    private static Component getCoordsTextComponent(String style, float x, float y, float z, boolean isInt) {
+        String text;
+        String command;
+        if (isInt) {
+            text = String.format("%s [ %d, %d, %d ]", style, (int) x, (int) y, (int) z);
+            command = String.format("!/tp %d %d %d", (int) x, (int) y, (int) z);
+        } else {
+            text = String.format("%s [ %.1f, %.1f, %.1f]", style, x, y, z);
+            command = String.format("!/tp %.3f %.3f %.3f", x, y, z);
+        }
+        return c(text, command);
+    }
+
+    // message source
+    public static void m(CommandSourceStack source, Object... fields) {
+        if (source != null)
+            source.sendSuccess(() -> Messenger.c(fields), source.getServer() != null && source.getServer().overworld() != null);
+    }
+
+    public static void m(Player player, Object... fields) {
+        player.sendSystemMessage(Messenger.c(fields));
+    }
+
+    /*
+    composes single line, multicomponent message, and returns as one chat messagge
+     */
+    public static Component c(Object... fields) {
+        MutableComponent message = Component.literal("");
+        MutableComponent previousComponent = null;
+        for (Object o : fields) {
+            if (o instanceof MutableComponent) {
+                message.append((MutableComponent) o);
+                previousComponent = (MutableComponent) o;
+                continue;
+            }
+            String txt = o.toString();
+            MutableComponent comp = getChatComponentFromDesc(txt, previousComponent);
+            if (comp != previousComponent) message.append(comp);
+            previousComponent = comp;
+        }
+        return message;
+    }
+
+    // simple text
+
+    public static Component s(String text) {
+        return s(text, "");
+    }
+
+    public static Component s(String text, String style) {
+        MutableComponent message = Component.literal(text);
+        message.setStyle(parseStyle(style));
+        return message;
+    }
+
+
+    public static void send(Player player, Collection<Component> lines) {
+        lines.forEach(message -> player.sendSystemMessage(message));
+    }
+
+    public static void send(CommandSourceStack source, Collection<Component> lines) {
+        lines.stream().forEachOrdered((s) -> source.sendSuccess(() -> s, false));
+    }
+
+
+    public static void print_server_message(MinecraftServer server, String message) {
+        if (server == null)
+            LOG.error("Message not delivered: " + message);
+        server.sendSystemMessage(Component.literal(message));
+        Component txt = c("gi " + message);
+        for (Player entityplayer : server.getPlayerList().getPlayers()) {
+            entityplayer.sendSystemMessage(txt);
+        }
+    }
+
+    public static void print_server_message(MinecraftServer server, Component message) {
+        if (server == null)
+            LOG.error("Message not delivered: " + message.getString());
+        server.sendSystemMessage(message);
+        for (Player entityplayer : server.getPlayerList().getPlayers()) {
+            entityplayer.sendSystemMessage(message);
+        }
+    }
+}
+
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/MobAI.java b/src/main/java/org/leavesmc/lumina/carpet/utils/MobAI.java
new file mode 100644
index 0000000000000000000000000000000000000000..37f872e12f345f7342dde52fa0c6083a2564afbb
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/MobAI.java
@@ -0,0 +1,74 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import com.google.common.collect.Sets;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Stream;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+
+public class MobAI {
+    private static Map<EntityType<?>, Set<TrackingType>> aiTrackers = new HashMap<>();
+
+    public static void resetTrackers() {
+        aiTrackers.clear();
+    }
+
+    public static boolean isTracking(Entity e, TrackingType type) {
+        if (e.getCommandSenderWorld().isClientSide())
+            return false;
+        Set<TrackingType> currentTrackers = aiTrackers.get(e.getType());
+        if (currentTrackers == null)
+            return false;
+        return currentTrackers.contains(type);
+    }
+
+    public static void clearTracking(final MinecraftServer server, EntityType<? extends Entity> etype) {
+        aiTrackers.remove(etype);
+        for (ServerLevel world : server.getAllLevels()) {
+            for (Entity e : world.getEntities(etype, Entity::hasCustomName)) {
+                e.setCustomNameVisible(false);
+                e.setCustomName(null);
+            }
+        }
+    }
+
+    public static void startTracking(EntityType<?> e, TrackingType type) {
+        aiTrackers.putIfAbsent(e, Sets.newHashSet());
+        aiTrackers.get(e).add(type);
+    }
+
+    public static Stream<String> availbleTypes(CommandSourceStack source) {
+        Set<EntityType<?>> types = new HashSet<>();
+        for (TrackingType type : TrackingType.values()) {
+            types.addAll(type.types);
+        }
+        return types.stream().map(t -> source.registryAccess().registryOrThrow(Registries.ENTITY_TYPE).getKey(t).getPath());
+    }
+
+    public static Stream<String> availableFor(EntityType<?> entityType) {
+        Set<TrackingType> availableOptions = new HashSet<>();
+        for (TrackingType type : TrackingType.values())
+            if (type.types.contains(entityType))
+                availableOptions.add(type);
+        return availableOptions.stream().map(t -> t.name().toLowerCase());
+    }
+
+    public enum TrackingType {
+        IRON_GOLEM_SPAWNING(Set.of(EntityType.VILLAGER)),
+        BREEDING(Set.of(EntityType.VILLAGER));
+        public final Set<EntityType<?>> types;
+
+        TrackingType(Set<EntityType<?>> applicableTypes) {
+            types = applicableTypes;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/PerimeterDiagnostics.java b/src/main/java/org/leavesmc/lumina/carpet/utils/PerimeterDiagnostics.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3668806d79a47fe4bc04a464d6b1a581fcfad0e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/PerimeterDiagnostics.java
@@ -0,0 +1,161 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.world.entity.AgeableMob;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.entity.MobSpawnType;
+import net.minecraft.world.entity.SpawnPlacements;
+import net.minecraft.world.entity.ambient.AmbientCreature;
+import net.minecraft.world.entity.animal.WaterAnimal;
+import net.minecraft.world.entity.monster.Enemy;
+import net.minecraft.world.level.NaturalSpawner;
+import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+
+public class PerimeterDiagnostics {
+    public static class Result {
+        public int liquid;
+        public int ground;
+        public int specific;
+        public List<BlockPos> samples;
+
+        Result() {
+            samples = new ArrayList<>();
+        }
+    }
+
+    private MobSpawnSettings.SpawnerData sle;
+    private ServerLevel worldServer;
+    private MobCategory ctype;
+    private Mob el;
+
+    private PerimeterDiagnostics(ServerLevel server, MobCategory ctype, Mob el) {
+        this.sle = null;
+        this.worldServer = server;
+        this.ctype = ctype;
+        this.el = el;
+    }
+
+    public static Result countSpots(ServerLevel worldserver, BlockPos epos, Mob el) {
+        BlockPos pos;
+        // List<BlockPos> samples = new ArrayList<BlockPos>();
+        // if (el != null) CarpetSettings.LOG.error(String.format("Got %s to check",el.toString()));
+        int eY = epos.getY();
+        int eX = epos.getX();
+        int eZ = epos.getZ();
+        Result result = new Result();
+
+        // int ground_spawns = 0;
+        // int liquid_spawns = 0;
+        // int specific_spawns = 0;
+        boolean add_water = false;
+        boolean add_ground = false;
+        MobCategory ctype = null;
+
+        if (el != null) {
+            if (el instanceof WaterAnimal) {
+                add_water = true;
+                ctype = MobCategory.WATER_CREATURE;
+            } else if (el instanceof AgeableMob) {
+                add_ground = true;
+                ctype = MobCategory.CREATURE;
+            } else if (el instanceof Enemy) {
+                add_ground = true;
+                ctype = MobCategory.MONSTER;
+            } else if (el instanceof AmbientCreature) {
+                ctype = MobCategory.AMBIENT;
+            }
+        }
+        PerimeterDiagnostics diagnostic = new PerimeterDiagnostics(worldserver, ctype, el);
+        EntityType<?> type = EntityType.ZOMBIE;
+        if (el != null) type = el.getType();
+        int minY = worldserver.getMinBuildHeight();
+        int maxY = worldserver.getMaxBuildHeight();
+        for (int x = -128; x <= 128; ++x) {
+            for (int z = -128; z <= 128; ++z) {
+                if (x * x + z * z > 128 * 128) // cut out a cyllinder first
+                {
+                    continue;
+                }
+                for (int y = minY; y < maxY; ++y) {
+                    if ((Math.abs(y - eY) > 128)) {
+                        continue;
+                    }
+                    int distsq = (x) * (x) + (eY - y) * (eY - y) + (z) * (z);
+                    if (distsq > 128 * 128 || distsq < 24 * 24) {
+                        continue;
+                    }
+                    pos = new BlockPos(eX + x, y, eZ + z);
+
+                    BlockState iblockstate = worldserver.getBlockState(pos);
+                    BlockState iblockstate_down = worldserver.getBlockState(pos.below());
+                    BlockState iblockstate_up = worldserver.getBlockState(pos.above());
+
+                    if (iblockstate.getFluidState().is(FluidTags.WATER) && !iblockstate_up.isRedstoneConductor(worldserver, pos)) // isSimpleFUllBLock
+                    {
+                        result.liquid++;
+                        if (add_water && diagnostic.check_entity_spawn(pos)) {
+                            result.specific++;
+                            if (result.samples.size() < 10) {
+                                result.samples.add(pos);
+                            }
+                        }
+                    } else {
+                        if (iblockstate_down.isRedstoneConductor(worldserver, pos)) // isSimpleFUllBLock
+                        {
+                            Block block = iblockstate_down.getBlock();
+                            boolean flag = block != Blocks.BEDROCK && block != Blocks.BARRIER;
+                            if (flag && NaturalSpawner.isValidEmptySpawnBlock(worldserver, pos, iblockstate, iblockstate.getFluidState(), type) && NaturalSpawner.isValidEmptySpawnBlock(worldserver, pos.above(), iblockstate_up, iblockstate_up.getFluidState(), type)) {
+                                result.ground++;
+                                if (add_ground && diagnostic.check_entity_spawn(pos)) {
+                                    result.specific++;
+                                    if (result.samples.size() < 10) {
+                                        result.samples.add(pos);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // ashMap<String,Integer> result= new HashMap<>();
+        // result.put("Potential in-water spawning spaces", liquid_spawns);
+        // result.put("Potential on-ground spawning spaces", ground_spawns);
+        // if (el != null) result.put(String.format("%s spawning spaces",el.getDisplayName().getUnformattedText()),specific_spawns);
+        return result;
+    }
+
+
+    private boolean check_entity_spawn(BlockPos pos) {
+        if (sle == null || !worldServer.getChunkSource().getGenerator().getMobsAt(worldServer.getBiome(pos), worldServer.structureManager(), ctype, pos).unwrap().contains(sle)) {
+            sle = null;
+            for (MobSpawnSettings.SpawnerData sle : worldServer.getChunkSource().getGenerator().getMobsAt(worldServer.getBiome(pos), worldServer.structureManager(), ctype, pos).unwrap()) {
+                if (el.getType() == sle.type) {
+                    this.sle = sle;
+                    break;
+                }
+            }
+            if (sle == null || !worldServer.getChunkSource().getGenerator().getMobsAt(worldServer.getBiome(pos), worldServer.structureManager(), ctype, pos).unwrap().contains(sle)) {
+                return false;
+            }
+        }
+
+        if (SpawnPlacements.isSpawnPositionOk(sle.type, worldServer, pos)) {
+            el.moveTo(pos.getX() + 0.5F, pos.getY(), pos.getZ() + 0.5F, 0.0F, 0.0F);
+            return el.checkSpawnObstruction(worldServer) && el.checkSpawnRules(worldServer, MobSpawnType.NATURAL) &&
+                    SpawnPlacements.checkSpawnRules(el.getType(), (ServerLevel) el.getCommandSenderWorld(), MobSpawnType.NATURAL, el.blockPosition(), el.getCommandSenderWorld().random) &&
+                    worldServer.noCollision(el); // check collision rules once they stop fiddling with them after 1.14.1
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnOverrides.java b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnOverrides.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0d49e695f7f37873ee1f079e5266587f717909f
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnOverrides.java
@@ -0,0 +1,99 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.random.WeightedRandomList;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
+import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
+import net.minecraft.world.level.levelgen.structure.Structure;
+import net.minecraft.world.level.levelgen.structure.StructureSpawnOverride;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.levelgen.structure.StructureType;
+import org.apache.commons.lang3.tuple.Pair;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.BooleanSupplier;
+
+public class SpawnOverrides {
+    final private static Map<Pair<MobCategory, ResourceKey<Structure>>, Pair<BooleanSupplier, StructureSpawnOverride>> carpetOverrides = new HashMap<>();
+
+    static {
+        addOverride(() -> CarpetConfig.configModule.huskSpawningInTemples, MobCategory.MONSTER, BuiltinStructures.DESERT_PYRAMID, StructureSpawnOverride.BoundingBoxType.STRUCTURE,
+                WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.HUSK, 1, 1, 1))
+        );
+        addOverride(() -> CarpetConfig.configModule.shulkerSpawningInEndCities, MobCategory.MONSTER, BuiltinStructures.END_CITY, StructureSpawnOverride.BoundingBoxType.PIECE,
+                WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.SHULKER, 10, 4, 4))
+        );
+        addOverride(() -> CarpetConfig.configModule.piglinsSpawningInBastions, MobCategory.MONSTER, BuiltinStructures.BASTION_REMNANT, StructureSpawnOverride.BoundingBoxType.PIECE,
+                WeightedRandomList.create(
+                        new MobSpawnSettings.SpawnerData(EntityType.PIGLIN_BRUTE, 5, 1, 2),
+                        new MobSpawnSettings.SpawnerData(EntityType.PIGLIN, 10, 2, 4),
+                        new MobSpawnSettings.SpawnerData(EntityType.HOGLIN, 2, 1, 2)
+                )
+        );
+
+    }
+
+    public static void addOverride(BooleanSupplier when, MobCategory cat, ResourceKey<Structure> poo,
+                                   StructureSpawnOverride.BoundingBoxType type, WeightedRandomList<MobSpawnSettings.SpawnerData> spawns) {
+        carpetOverrides.put(Pair.of(cat, poo), Pair.of(when, new StructureSpawnOverride(type, spawns)));
+    }
+
+    public static WeightedRandomList<MobSpawnSettings.SpawnerData> test(StructureManager structureFeatureManager, LongSet foo,
+                                                                        MobCategory cat, Structure confExisting, BlockPos where) {
+        ResourceLocation resource = structureFeatureManager.registryAccess().registryOrThrow(Registries.STRUCTURE).getKey(confExisting);
+        ResourceKey<Structure> key = ResourceKey.create(Registries.STRUCTURE, resource);
+        final Pair<BooleanSupplier, StructureSpawnOverride> spawnData = carpetOverrides.get(Pair.of(cat, key));
+        if (spawnData == null || !spawnData.getKey().getAsBoolean()) return null;
+        StructureSpawnOverride override = spawnData.getRight();
+        if (override.boundingBox() == StructureSpawnOverride.BoundingBoxType.STRUCTURE) {
+            if (structureFeatureManager.getStructureAt(where, confExisting).isValid())
+                return override.spawns();
+        } else {
+            List<StructureStart> starts = new ArrayList<>(1);
+            structureFeatureManager.fillStartsForStructure(confExisting, foo, starts::add);
+            for (StructureStart start : starts) {
+                if (start != null && start.isValid() && structureFeatureManager.structureHasPieceAt(where, start)) {
+                    return override.spawns();
+                }
+            }
+        }
+        return null;
+    }
+
+    public static boolean isStructureAtPosition(ServerLevel level, ResourceKey<Structure> structureKey, BlockPos pos)
+    {
+        final Structure fortressFeature = level.registryAccess().registryOrThrow(Registries.STRUCTURE).get(structureKey);
+        if (fortressFeature == null) {
+            return false;
+        }
+        return level.structureManager().getStructureAt(pos, fortressFeature).isValid();
+    }
+
+    public static List<StructureStart> startsForFeature(ServerLevel level, SectionPos sectionPos, StructureType<?> structure) {
+        Map<Structure, LongSet> allrefs = level.getChunk(sectionPos.x(), sectionPos.z(), ChunkStatus.STRUCTURE_REFERENCES).getAllReferences();
+        List<StructureStart> result = new ArrayList<>();
+        for (var entry: allrefs.entrySet())
+        {
+            Structure existing = entry.getKey();
+            if (existing.type() == structure)
+            {
+                level.structureManager().fillStartsForStructure(existing, entry.getValue(), result::add);
+            }
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnReporter.java b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnReporter.java
new file mode 100644
index 0000000000000000000000000000000000000000..a2829333c30f90e09941815b360a87526b962083
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnReporter.java
@@ -0,0 +1,436 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2LongMap;
+import it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.entity.MobSpawnType;
+import net.minecraft.world.entity.SpawnPlacements;
+import net.minecraft.world.entity.animal.Ocelot;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.NaturalSpawner;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.entity.EntityTypeTest;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure;
+import org.apache.commons.lang3.tuple.Pair;
+import org.jetbrains.annotations.Nullable;
+import org.leavesmc.lumina.carpet.CarpetServer;
+
+import static net.minecraft.world.entity.MobCategory.*;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+
+public class SpawnReporter {
+    private static final MobCategory[] CACHED_MOBCATEGORY_VALUES = MobCategory.values();
+    public static boolean mockSpawns = false;
+
+    public static final HashMap<ResourceKey<Level>, Integer> chunkCounts = new HashMap<>();
+
+    public static final HashMap<Pair<ResourceKey<Level>, MobCategory>, Object2LongOpenHashMap<EntityType<?>>> spawn_stats = new HashMap<>();
+    public static double mobcap_exponent = 0.0D;
+
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_attempts = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> overall_spawn_ticks = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_full = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_fail = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_succ = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_spawns = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_cap_count = new Object2LongOpenHashMap<>();
+    public static final HashMap<Pair<ResourceKey<Level>, MobCategory>, EvictingQueue<Pair<EntityType<?>, BlockPos>>> spawned_mobs = new HashMap<>();
+    public static final HashMap<MobCategory, Integer> spawn_tries = new HashMap<>();
+
+    private static int spawnTrackingStartTime = 0;
+    private static BoundingBox trackedSpawningArea = null;
+    // in case game gets each thread for each world - these need to belong to workd.
+    public static Object2LongOpenHashMap<MobCategory> local_spawns = null; // per world
+    public static HashSet<MobCategory> first_chunk_marker = null;
+
+    public static void registerSpawn(Mob mob, MobCategory cat, BlockPos pos) {
+        if (trackedSpawningArea != null && !trackedSpawningArea.isInside(pos)) {
+            return;
+        }
+        Pair<ResourceKey<Level>, MobCategory> key = Pair.of(mob.level().dimension(), cat);
+        spawn_stats.get(key).addTo(mob.getType(), 1);
+        spawned_mobs.get(key).put(Pair.of(mob.getType(), pos));
+        if (!local_spawns.containsKey(cat)) {
+            CarpetServer.LOGGER.error("Rogue spawn detected for category " + cat.getName() + " for mob " + mob.getType().getDescription().getString() + ". If you see this message let carpet peeps know about it on github issues.");
+            local_spawns.put(cat, 0L);
+        }
+        local_spawns.addTo(cat, 1);
+    }
+
+    public static final int MAGIC_NUMBER = (int) Math.pow(17.0D, 2.0D);
+    /*public static double currentMagicNumber()
+    {
+        return MAGIC_NUMBER / (Math.pow(2.0,(SpawnReporter.mobcap_exponent/4)));
+    }*/
+
+    public static List<Component> printMobcapsForDimension(ServerLevel world, boolean multiline) {
+        ResourceKey<Level> dim = world.dimension();
+        String name = dim.location().getPath();
+        List<Component> lst = new ArrayList<>();
+        if (multiline)
+            lst.add(Messenger.s(String.format("Mobcaps for %s:", name)));
+        NaturalSpawner.SpawnState lastSpawner = world.getChunkSource().getLastSpawnState();
+        Object2IntMap<MobCategory> dimCounts = lastSpawner.getMobCategoryCounts();
+        int chunkcount = chunkCounts.getOrDefault(dim, -1);
+        if (dimCounts == null || chunkcount < 0) {
+            lst.add(Messenger.c("g   --UNAVAILABLE--"));
+            return lst;
+        }
+
+        List<String> shortCodes = new ArrayList<>();
+        for (MobCategory category : cachedMobCategories()) {
+            int cur = dimCounts.getOrDefault(category, -1);
+            int max = (int) (chunkcount * ((double) category.getMaxInstancesPerChunk() / MAGIC_NUMBER)); // from ServerChunkManager.CHUNKS_ELIGIBLE_FOR_SPAWNING
+            String color = Messenger.heatmap_color(cur, max);
+            String mobColor = Messenger.creatureTypeColor(category);
+            if (multiline) {
+                int rounds = spawn_tries.get(category);
+                lst.add(Messenger.c(String.format("w   %s: ", category.getName()),
+                        (cur < 0) ? "g -" : (color + " " + cur), "g  / ", mobColor + " " + max,
+                        (rounds == 1) ? "w " : String.format("gi  (%d rounds/tick)", spawn_tries.get(category))
+                ));
+            } else {
+                shortCodes.add(color + " " + ((cur < 0) ? "-" : cur));
+                shortCodes.add("g /");
+                shortCodes.add(mobColor + " " + max);
+                shortCodes.add("g ,");
+            }
+        }
+        if (!multiline) {
+            if (shortCodes.size() > 0) {
+                shortCodes.remove(shortCodes.size() - 1);
+                lst.add(Messenger.c(shortCodes.toArray(new Object[0])));
+            } else {
+                lst.add(Messenger.c("g   --UNAVAILABLE--"));
+            }
+
+        }
+        return lst;
+    }
+
+    public static List<Component> getRecentSpawns(Level world, MobCategory category) {
+        List<Component> lst = new ArrayList<>();
+        if (!trackingSpawns()) {
+            lst.add(Messenger.s("Spawn tracking not started"));
+            return lst;
+        }
+        String categoryName = category.getName();
+
+        lst.add(Messenger.s(String.format("Recent %s spawns:", categoryName)));
+        for (Pair<EntityType<?>, BlockPos> pair : spawned_mobs.get(Pair.of(world.dimension(), category)).keySet()) {
+            lst.add(Messenger.c(
+                    "w  - ",
+                    Messenger.tp("wb", pair.getRight()),
+                    String.format("w : %s", pair.getLeft().getDescription().getString())
+            ));
+        }
+
+        if (lst.size() == 1) {
+            lst.add(Messenger.s(" - Nothing spawned yet, sorry."));
+        }
+        return lst;
+
+    }
+
+    public static List<Component> handleWoolAction(BlockPos pos, ServerLevel worldIn) {
+        DyeColor under = WoolTool.getWoolColorAtPosition(worldIn, pos.below());
+        if (under == null) {
+            if (trackingSpawns()) {
+                return makeTrackingReport(worldIn);
+            } else {
+                return printMobcapsForDimension(worldIn, true);
+            }
+        }
+        MobCategory category = getCategoryFromWoolColor(under);
+        if (category != null) {
+            if (trackingSpawns()) {
+                return getRecentSpawns(worldIn, category);
+            } else {
+                return printEntitiesByType(category, worldIn, true);
+
+            }
+
+        }
+        if (trackingSpawns()) {
+            return makeTrackingReport(worldIn);
+        } else {
+            return printMobcapsForDimension(worldIn, true);
+        }
+
+    }
+
+    public static MobCategory getCategoryFromWoolColor(DyeColor color) {
+        return switch (color) {
+            case RED -> MONSTER;
+            case GREEN -> CREATURE;
+            case BLUE -> WATER_CREATURE;
+            case BROWN -> AMBIENT;
+            case CYAN -> WATER_AMBIENT;
+            default -> null;
+        };
+    }
+
+    public static List<Component> printEntitiesByType(MobCategory cat, ServerLevel worldIn, boolean all) {
+        List<Component> lst = new ArrayList<>();
+        lst.add(Messenger.s(String.format("Loaded entities for %s category:", cat)));
+        for (Entity entity : worldIn.getEntities(EntityTypeTest.forClass(Entity.class), (e) -> e.getType().getCategory() == cat)) {
+            boolean persistent = entity instanceof Mob mob && (mob.isPersistenceRequired() || mob.requiresCustomPersistence());
+            if (!all && persistent)
+                continue;
+
+            EntityType<?> type = entity.getType();
+            BlockPos pos = entity.blockPosition();
+            lst.add(Messenger.c(
+                    "w  - ",
+                    Messenger.tp(persistent ? "gb" : "wb", pos),
+                    String.format(persistent ? "g : %s" : "w : %s", type.getDescription().getString())
+            ));
+
+        }
+        if (lst.size() == 1) {
+            lst.add(Messenger.s(" - Empty."));
+        }
+        return lst;
+    }
+
+    public static void initializeMocking() {
+        mockSpawns = true;
+    }
+
+    public static void stopMocking() {
+        mockSpawns = false;
+    }
+
+    public static void resetSpawnStats(MinecraftServer server, boolean full) {
+        if (full) {
+            for (MobCategory category : cachedMobCategories())
+                spawn_tries.put(category, 1);
+        }
+        overall_spawn_ticks.clear();
+        spawn_attempts.clear();
+        spawn_ticks_full.clear();
+        spawn_ticks_fail.clear();
+        spawn_ticks_succ.clear();
+        spawn_ticks_spawns.clear();
+        spawn_cap_count.clear();
+
+        // can't fast-path to clear given different worlds could have different amount of worlds
+        for (MobCategory category : cachedMobCategories()) {
+            for (ResourceKey<Level> world : server.levelKeys()) {
+                Pair<ResourceKey<Level>, MobCategory> key = Pair.of(world, category);
+                spawn_stats.put(key, new Object2LongOpenHashMap<>());
+                spawned_mobs.put(key, new EvictingQueue<>());
+            }
+        }
+        spawnTrackingStartTime = 0;
+    }
+
+    public static MobCategory[] cachedMobCategories() {
+        return CACHED_MOBCATEGORY_VALUES;
+    }
+
+    public static boolean trackingSpawns() {
+        return spawnTrackingStartTime != 0L;
+    }
+
+    public static void startTracking(MinecraftServer server, BoundingBox trackedArea) {
+        resetSpawnStats(server, false);
+        spawnTrackingStartTime = server.getTickCount();
+        trackedSpawningArea = trackedArea;
+    }
+
+    public static void stopTracking(MinecraftServer server) {
+        resetSpawnStats(server, false);
+        SpawnReporter.spawnTrackingStartTime = 0;
+        trackedSpawningArea = null;
+    }
+
+    private static String getWorldCode(ResourceKey<Level> world) {
+        if (world == Level.OVERWORLD) return "";
+        return "(" + Character.toUpperCase(world.location().getPath().charAt("THE_".length())) + ")";
+    }
+
+    public static List<Component> makeTrackingReport(Level worldIn) {
+        List<Component> report = new ArrayList<>();
+        if (!trackingSpawns()) {
+            report.add(Messenger.c(
+                    "w Spawn tracking is disabled, type '",
+                    "wi /spawn tracking start", "/spawn tracking start",
+                    "w ' to enable"));
+            return report;
+        }
+        int duration = worldIn.getServer().getTickCount() - spawnTrackingStartTime;
+        report.add(Messenger.c("bw --------------------"));
+        String simulated = mockSpawns ? "[SIMULATED] " : "";
+        String location = (trackedSpawningArea != null) ? String.format("[in (%d, %d, %d)x(%d, %d, %d)]",
+                trackedSpawningArea.minX(), trackedSpawningArea.minY(), trackedSpawningArea.minZ(),
+                trackedSpawningArea.maxX(), trackedSpawningArea.maxY(), trackedSpawningArea.maxZ()) : "";
+        report.add(Messenger.s(String.format("%sSpawn statistics %s: for %.1f min", simulated, location, (duration / 72000.0) * 60)));
+
+        for (MobCategory category : cachedMobCategories()) {
+            for (ResourceKey<Level> dim : worldIn.getServer().levelKeys()) {
+                Pair<ResourceKey<Level>, MobCategory> key = Pair.of(dim, category);
+                if (spawn_ticks_spawns.getLong(key) > 0L) {
+                    double hours = overall_spawn_ticks.getLong(key) / 72000.0;
+                    long spawnAttemptsForCategory = spawn_attempts.getLong(key);
+                    report.add(Messenger.s(String.format(" > %s%s (%.1f min), %.1f m/t, %%{%.1fF %.1f- %.1f+}; %.2f s/att",
+                            category.getName().substring(0, 3), getWorldCode(dim),
+                            60 * hours,
+                            (1.0D * spawn_cap_count.getLong(key)) / spawnAttemptsForCategory,
+                            (100.0D * spawn_ticks_full.getLong(key)) / spawnAttemptsForCategory,
+                            (100.0D * spawn_ticks_fail.getLong(key)) / spawnAttemptsForCategory,
+                            (100.0D * spawn_ticks_succ.getLong(key)) / spawnAttemptsForCategory,
+                            (1.0D * spawn_ticks_spawns.getLong(key)) / (spawn_ticks_fail.getLong(key) + spawn_ticks_succ.getLong(key))
+                    )));
+                    for (Object2LongMap.Entry<EntityType<?>> entry : spawn_stats.get(key).object2LongEntrySet()) {
+                        report.add(Messenger.s(String.format("   - %s: %d spawns, %d per hour",
+                                entry.getKey().getDescription().getString(),
+                                entry.getLongValue(),
+                                (72000 * entry.getLongValue() / duration))));
+                    }
+                }
+            }
+        }
+        return report;
+    }
+
+    public static void killEntity(LivingEntity entity) {
+        if (entity.isPassenger()) {
+            entity.getVehicle().discard();
+        }
+        if (entity.isVehicle()) {
+            for (Entity e : entity.getPassengers()) {
+                e.discard();
+            }
+        }
+        if (entity instanceof Ocelot) {
+            for (Entity e : entity.getCommandSenderWorld().getEntities(entity, entity.getBoundingBox())) {
+                e.discard();
+            }
+        }
+        entity.discard();
+    }
+
+    // yeeted from NaturalSpawner - temporary access fix
+    private static List<MobSpawnSettings.SpawnerData> getSpawnEntries(ServerLevel serverLevel, StructureManager structureManager, ChunkGenerator chunkGenerator, MobCategory mobCategory, BlockPos blockPos, @Nullable Holder<Biome> holder) {
+        return NaturalSpawner.isInNetherFortressBounds(blockPos, serverLevel, mobCategory, structureManager) ? NetherFortressStructure.FORTRESS_ENEMIES.unwrap() : chunkGenerator.getMobsAt(holder != null ? holder : serverLevel.getBiome(blockPos), structureManager, mobCategory, blockPos).unwrap();
+    }
+
+    public static List<Component> report(BlockPos pos, ServerLevel worldIn) {
+        List<Component> rep = new ArrayList<>();
+        int x = pos.getX();
+        int y = pos.getY();
+        int z = pos.getZ();
+        ChunkAccess chunk = worldIn.getChunk(pos);
+        int lc = chunk.getHeight(Heightmap.Types.WORLD_SURFACE, x, z) + 1;
+        String relativeHeight = (y == lc) ? "right at it." : String.format("%d blocks %s it.", Mth.abs(y - lc), (y >= lc) ? "above" : "below");
+        rep.add(Messenger.s(String.format("Maximum spawn Y value for (%+d, %+d) is %d. You are " + relativeHeight, x, z, lc)));
+        rep.add(Messenger.s("Spawns:"));
+        for (MobCategory category : cachedMobCategories()) {
+            String categoryCode = String.valueOf(category).substring(0, 3);
+            List<MobSpawnSettings.SpawnerData> lst = getSpawnEntries(worldIn, worldIn.structureManager(), worldIn.getChunkSource().getGenerator(), category, pos, worldIn.getBiome(pos));
+            if (lst != null && !lst.isEmpty()) {
+                for (MobSpawnSettings.SpawnerData spawnEntry : lst) {
+                    if (SpawnPlacements.getPlacementType(spawnEntry.type) == null)
+                        continue; // vanilla bug
+                    boolean canSpawn = SpawnPlacements.isSpawnPositionOk(spawnEntry.type, worldIn, pos);
+                    int willSpawn = -1;
+                    boolean fits = false;
+
+                    Mob mob;
+                    try {
+                        mob = (Mob) spawnEntry.type.create(worldIn);
+                    } catch (Exception e) {
+                        CarpetServer.LOGGER.warn("Exception while creating mob for spawn reporter", e);
+                        return rep;
+                    }
+
+                    if (canSpawn) {
+                        willSpawn = 0;
+                        for (int attempt = 0; attempt < 50; ++attempt) {
+                            float f = x + 0.5F;
+                            float f1 = z + 0.5F;
+                            mob.moveTo(f, y, f1, worldIn.random.nextFloat() * 360.0F, 0.0F);
+                            fits = worldIn.noCollision(mob);
+                            EntityType<?> etype = mob.getType();
+
+                            for (int i = 0; i < 20; ++i) {
+                                if (
+                                        SpawnPlacements.checkSpawnRules(etype, worldIn, MobSpawnType.NATURAL, pos, worldIn.random) &&
+                                                SpawnPlacements.isSpawnPositionOk(etype, worldIn, pos) &&
+                                                mob.checkSpawnRules(worldIn, MobSpawnType.NATURAL)
+                                    // && mob.canSpawn(worldIn) // entity collisions // mostly - except ocelots
+                                ) {
+                                    if (etype == EntityType.OCELOT) {
+                                        BlockState blockState = worldIn.getBlockState(pos.below());
+                                        if ((pos.getY() < worldIn.getSeaLevel()) || !(blockState.is(Blocks.GRASS_BLOCK) || blockState.is(BlockTags.LEAVES))) {
+                                            continue;
+                                        }
+                                    }
+                                    willSpawn += 1;
+                                }
+                            }
+                            mob.finalizeSpawn(worldIn, worldIn.getCurrentDifficultyAt(mob.blockPosition()), MobSpawnType.NATURAL, null);
+                            // the code invokes onInitialSpawn after getCanSpawHere
+                            fits = fits && worldIn.noCollision(mob);
+
+                            killEntity(mob);
+
+                            try {
+                                mob = (Mob) spawnEntry.type.create(worldIn);
+                            } catch (Exception e) {
+                                CarpetServer.LOGGER.warn("Exception while creating mob for spawn reporter", e);
+                                return rep;
+                            }
+                        }
+                    }
+
+                    String mobTypeName = mob.getType().getDescription().getString();
+                    // String pack_size = Integer.toString(mob.getMaxSpawnClusterSize());//String.format("%d-%d", animal.minGroupCount, animal.maxGroupCount);
+                    int weight = spawnEntry.getWeight().asInt();
+                    if (canSpawn) {
+                        String color = (fits && willSpawn > 0) ? "e" : "gi";
+                        rep.add(Messenger.c(
+                                String.format("%s %s: %s (%d:%d-%d/%d), can: ", color, categoryCode, mobTypeName, weight, spawnEntry.minCount, spawnEntry.maxCount, mob.getMaxSpawnClusterSize()),
+                                "l YES",
+                                color + " , fit: ",
+                                (fits ? "l YES" : "r NO"),
+                                color + " , will: ",
+                                ((willSpawn > 0) ? "l " : "r ") + Math.round((double) willSpawn) / 10 + "%"
+                        ));
+                    } else {
+                        rep.add(Messenger.c(String.format("gi %s: %s (%d:%d-%d/%d), can: ", categoryCode, mobTypeName, weight, spawnEntry.minCount, spawnEntry.maxCount, mob.getMaxSpawnClusterSize()), "n NO"));
+                    }
+                    killEntity(mob);
+                }
+            }
+        }
+        return rep;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/TranslationKeys.java b/src/main/java/org/leavesmc/lumina/carpet/utils/TranslationKeys.java
new file mode 100644
index 0000000000000000000000000000000000000000..284086d7deea77d43a6e3fa541e88f4a24cfdfe5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/TranslationKeys.java
@@ -0,0 +1,31 @@
+package org.leavesmc.lumina.carpet.utils;
+
+/**
+ * This is not public API!
+ */
+public final class TranslationKeys {
+    public static final String BASE_RULE_NAMESPACE = "%s.rule.";
+    public static final String BASE_RULE_PATTERN   = BASE_RULE_NAMESPACE + "%s."; // [settingsManager].rule.[name]
+    public static final String RULE_NAME_PATTERN   = BASE_RULE_PATTERN + "name";
+    public static final String RULE_DESC_PATTERN   = BASE_RULE_PATTERN + "desc";
+    public static final String RULE_EXTRA_PREFIX_PATTERN = BASE_RULE_PATTERN + "extra.";
+    public static final String CATEGORY_PATTERN    = "%s.category.%s"; //[settingsManager].category.[name]
+
+    // Settings command
+    private static final String SETTINGS_BASE           = "carpet.settings.command.";
+    public static final String BROWSE_CATEGORIES        = SETTINGS_BASE + "browse_categories";
+    public static final String VERSION                  = SETTINGS_BASE + "version";
+    public static final String LIST_ALL_CATEGORY        = SETTINGS_BASE + "list_all_category";
+    public static final String CURRENT_SETTINGS_HEADER  = SETTINGS_BASE + "current_settings_header";
+    public static final String SWITCH_TO                = SETTINGS_BASE + "switch_to";
+    public static final String UNKNOWN_RULE             = SETTINGS_BASE + "unknown_rule";
+    public static final String CURRENT_FROM_FILE_HEADER = SETTINGS_BASE + "current_from_file_header";
+    public static final String MOD_SETTINGS_MATCHING    = SETTINGS_BASE + "mod_settings_matching";
+    public static final String ALL_MOD_SETTINGS         = SETTINGS_BASE + "all_mod_settings";
+    public static final String TAGS                     = SETTINGS_BASE + "tags";
+    public static final String CHANGE_PERMANENTLY       = SETTINGS_BASE + "change_permanently";
+    public static final String CHANGE_PERMANENTLY_HOVER = SETTINGS_BASE + "change_permanently_tooltip";
+    public static final String DEFAULT_SET              = SETTINGS_BASE + "default_set";
+    public static final String DEFAULT_REMOVED          = SETTINGS_BASE + "default_removed";
+    public static final String CURRENT_VALUE            = SETTINGS_BASE + "current_value";
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/Translations.java b/src/main/java/org/leavesmc/lumina/carpet/utils/Translations.java
new file mode 100644
index 0000000000000000000000000000000000000000..631ef5461d28da8136d136006e395c89b0006d01
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/Translations.java
@@ -0,0 +1,119 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.CarpetServer;
+// import org.leavesmc.lumina.carpet.CarpetSettings; // TODO
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class Translations {
+    private static Map<String, String> translationMap = Collections.emptyMap();
+
+    public static String tr(String key) {
+        return translationMap.getOrDefault(key, key);
+    }
+
+    public static String trOrNull(String key) {
+        return translationMap.get(key);
+    }
+
+    public static String tr(String key, String str) {
+        return translationMap.getOrDefault(key, str);
+    }
+
+    public static boolean hasTranslations() {
+        return !translationMap.isEmpty();
+    }
+
+    public static boolean hasTranslation(String key) {
+        return translationMap.containsKey(key);
+    }
+
+    public static Map<String, String> getTranslationFromResourcePath(String path) {
+        InputStream langFile = Translations.class.getClassLoader().getResourceAsStream(path);
+        if (langFile == null) {
+            // we don't have that language
+            return Collections.emptyMap();
+        }
+        Gson gson = new GsonBuilder().setLenient().create();
+        return gson.fromJson(new InputStreamReader(langFile, StandardCharsets.UTF_8),
+                new TypeToken<Map<String, String>>() {
+                });
+    }
+
+    public static void updateLanguage() {
+        Map<String, String> translations = new HashMap<>();
+        translations.putAll(getTranslationFromResourcePath(String.format("assets/carpet/lang/%s.json", CarpetConfig.configModule.language)));
+
+        // for (CarpetExtension ext : CarpetServer.extensions)
+        // {
+        //     Map<String, String> extMappings = ext.canHasTranslations(CarpetSettings.language);
+        //     if (extMappings == null) continue; // would be nice to get rid of this, but too many extensions return null where they don't know they do
+        //     boolean warned = false;
+        //     for (var entry : extMappings.entrySet()) {
+        //         var key = entry.getKey();
+        //         // Migrate the old format
+        //         if (!key.startsWith("carpet.")) {
+        //             if (key.startsWith("rule.")) {
+        //                 // default to carpet's settings manager. Custom managers are really uncommon and the known ones don't provide translations anyway
+        //                 key = TranslationKeys.BASE_RULE_NAMESPACE.formatted("carpet") + key.substring(5);
+        //             } else if (key.startsWith("category.")) {
+        //                 key = TranslationKeys.CATEGORY_PATTERN.formatted("carpet", key.substring(9));
+        //             }
+        //             if (!warned && key != entry.getKey()) {
+        //                 CarpetSettings.LOG.warn("""
+        //                         Found outdated translation keys in extension '%s'!
+        //                         These won't be supported in a later Carpet version!
+        //                         Carpet will now try to map them to the correct keys in a best-effort basis""".formatted(ext.getClass().getName()));
+        //                 warned = true;
+        //             }
+        //         }
+        //         translations.putIfAbsent(key, entry.getValue());
+        //     }
+        // }
+        translations.keySet().removeIf(e -> {
+            if (e.startsWith("//")) {
+                CarpetServer.LOGGER.warn("""
+                        Found translation key starting with // while preparing translations!
+                        Doing this is deprecated and may cause issues in later versions! Consider settings GSON to "lenient" mode and
+                        using regular comments instead!
+                        Translation key is '%s'""".formatted(e));
+                return true;
+            } else
+                return false;
+        });
+        // Remove after deprecated settings api is removed
+        addFallbacksTo(translations);
+        translationMap = translations;
+    }
+
+    public static boolean isValidLanguage(String newValue) {
+        // will put some validations for availble languages at some point
+        return true;
+    }
+
+    // fallbacks for old rules that don't define rule descriptions or stuff in language files yet
+    // to be removed when old settings system is removed and translation refactor is finished
+
+    private static final Map<String, String> FALLBACKS = new HashMap<>();
+
+    /**
+     * @deprecated if you compile against this method I'll steal your kneecaps
+     */
+    @Deprecated(forRemoval = true)
+    public static void registerFallbackTranslation(String key, String description) {
+        FALLBACKS.put(key, description);
+    }
+
+    private static void addFallbacksTo(Map<String, String> translationMap) {
+        FALLBACKS.forEach(translationMap::putIfAbsent);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/WoolTool.java b/src/main/java/org/leavesmc/lumina/carpet/utils/WoolTool.java
new file mode 100644
index 0000000000000000000000000000000000000000..029554341653efaceb38e5120cd9cdc01a7938f0
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/WoolTool.java
@@ -0,0 +1,127 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.Vec3;
+
+import javax.annotation.Nullable;
+
+import static java.util.Map.entry;
+
+/**
+ * A series of utility functions and variables for dealing predominantly with hopper counters and determining which counter
+ * to add their items to, as well as helping dealing with carpet functionality.
+ */
+public class WoolTool
+{
+    /**
+     * A map from a wool {@link Block} to its {@link DyeColor} which is used in {@link WoolTool#getWoolColorAtPosition}
+     * to get the colour of wool at a position.
+     */
+    private static final Map<Block, DyeColor> WOOL_BLOCK_TO_DYE = Map.ofEntries(
+            entry(Blocks.WHITE_WOOL, DyeColor.WHITE),
+            entry(Blocks.ORANGE_WOOL, DyeColor.ORANGE),
+            entry(Blocks.MAGENTA_WOOL, DyeColor.MAGENTA),
+            entry(Blocks.LIGHT_BLUE_WOOL, DyeColor.LIGHT_BLUE),
+            entry(Blocks.YELLOW_WOOL, DyeColor.YELLOW),
+            entry(Blocks.LIME_WOOL, DyeColor.LIME),
+            entry(Blocks.PINK_WOOL, DyeColor.PINK),
+            entry(Blocks.GRAY_WOOL, DyeColor.GRAY),
+            entry(Blocks.LIGHT_GRAY_WOOL, DyeColor.LIGHT_GRAY),
+            entry(Blocks.CYAN_WOOL, DyeColor.CYAN),
+            entry(Blocks.PURPLE_WOOL, DyeColor.PURPLE),
+            entry(Blocks.BLUE_WOOL, DyeColor.BLUE),
+            entry(Blocks.BROWN_WOOL, DyeColor.BROWN),
+            entry(Blocks.GREEN_WOOL, DyeColor.GREEN),
+            entry(Blocks.RED_WOOL, DyeColor.RED),
+            entry(Blocks.BLACK_WOOL, DyeColor.BLACK)
+    );
+
+    /**
+     * The method which gets triggered when a player places a carpet, and decides what to do based on the carpet's colour:
+     * <ul>
+     *     <li>Red - Resets the counter of the colour of wool underneath the carpet (if there is no wool, then nothing happens)</li>
+     *     <li>Green - Prints the contents of the counter of the colour of wool underneath the carpet</li>
+     * </ul>
+     */
+    public static void carpetPlacedAction(DyeColor color, Player placer, BlockPos pos, ServerLevel worldIn)
+    {
+        if (!CarpetConfig.configModule.carpets)
+        {
+            return;
+        }
+        switch (color)
+        {
+            case PINK:
+                if (!CarpetConfig.configModule.commandSpawn)
+                    Messenger.send(placer, SpawnReporter.report(pos, worldIn));
+
+                break;
+            case BLACK:
+                if (!CarpetConfig.configModule.commandSpawn)
+                    Messenger.send(placer, SpawnReporter.handleWoolAction(pos, worldIn));
+                break;
+            case BROWN:
+                if (!CarpetConfig.configModule.commandDistance)
+                {
+                    CommandSourceStack source = placer.createCommandSourceStack();
+                    if (!DistanceCalculator.hasStartingPoint(source) || placer.isShiftKeyDown()) {
+                        DistanceCalculator.setStart(source, Vec3.atLowerCornerOf(pos) ); // zero padded pos
+                    }
+                    else {
+                        DistanceCalculator.setEnd(source, Vec3.atLowerCornerOf(pos));
+                    }
+                }
+                break;
+            case GRAY:
+                if (!CarpetConfig.configModule.commandInfo)
+                    Messenger.send(placer, BlockInfo.blockInfo(pos.below(), worldIn));
+                break;
+            case GREEN:
+                if (CarpetConfig.configModule.hopperCounters)
+                {
+                    DyeColor under = getWoolColorAtPosition(worldIn, pos.below());
+                    if (under == null) return;
+                    HopperCounter counter = HopperCounter.getCounter(under);
+                    Messenger.send(placer, counter.format(worldIn.getServer(), false, false));
+                }
+                break;
+            case RED:
+                if (CarpetConfig.configModule.hopperCounters)
+                {
+                    DyeColor under = getWoolColorAtPosition(worldIn, pos.below());
+                    if (under == null) return;
+                    HopperCounter counter = HopperCounter.getCounter(under);
+                    counter.reset(placer.getServer());
+                    List<Component> res = new ArrayList<>();
+                    res.add(Messenger.s(String.format("%s counter reset",under.toString())));
+                    Messenger.send(placer, res);
+                }
+                break;
+        }
+    }
+
+    /**
+     * Gets the colour of wool at the position, for hoppers to be able to decide whether to add their items to the global counter.
+     */
+    @Nullable
+    public static DyeColor getWoolColorAtPosition(Level worldIn, BlockPos pos)
+    {
+        BlockState state = worldIn.getBlockState(pos);
+        return WOOL_BLOCK_TO_DYE.get(state.getBlock());
+    }
+}
