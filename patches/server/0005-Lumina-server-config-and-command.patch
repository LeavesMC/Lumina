From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7studio@foxmail.com>
Date: Thu, 11 Apr 2024 22:58:15 +0800
Subject: [PATCH] Lumina server config and command


diff --git a/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java b/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
index e3228efcb0d85c0c43cd4e52fe0b877414a5ebe5..bdc35ec969486f6f026f6fb9bb0b9c22b947c414 100644
--- a/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
+++ b/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
@@ -25,19 +25,12 @@ import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Predicate;
@@ -190,6 +183,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.ScoreHolder;
 import org.bukkit.loot.LootTable;
 import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.utils.ReflectTargetField;
 
 // Mojang-Mapped reflection
 
@@ -222,8 +216,10 @@ public class NMS_1_20_R4 extends NMS_Common {
         // entitySelectorUsesSelector = EntitySelector::usesSelector;
         Field usesSelector = null;
         for (Field field : EntitySelector.class.getFields()) {
-            if (field.getType().equals(boolean.class) && Modifier.isPublic(field.getModifiers())) {
-                usesSelector = CommandAPIHandler.getField(EntitySelector.class, field.getName(), "");
+            for (Annotation annotation : field.getAnnotations()) {
+                if (annotation instanceof ReflectTargetField) {
+                    usesSelector = CommandAPIHandler.getField(EntitySelector.class, field.getName(), "");
+                }
             }
         }
         entitySelectorUsesSelector = usesSelector;
diff --git a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
index 8302e4bedc03795c4cda526466fa4dc279b2dd21..17351285d16956d22eca0d5dce336699b485e42f 100644
--- a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -53,7 +53,8 @@ public class EntitySelector {
     @Nullable
     private final UUID entityUUID;
     private final EntityTypeTest<Entity, ?> type;
-    public final boolean usesSelector; // Lumina - Command API
+    @org.leavesmc.lumina.utils.ReflectTargetField // Lumina - Command API
+    private final boolean usesSelector;
 
     public EntitySelector(int count, boolean includesNonPlayers, boolean localWorldOnly, Predicate<Entity> basePredicate, MinMaxBounds.Doubles distance, Function<Vec3, Vec3> positionOffset, @Nullable AABB box, BiConsumer<Vec3, List<? extends Entity>> sorter, boolean senderOnly, @Nullable String playerName, @Nullable UUID uuid, @Nullable EntityType<?> type, boolean usesAt) {
         this.maxResults = count;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index f01863e33b7407c14e8bcd2a44e63bed01afe838..a37c35fd271ac815bd67a40ceaca95ff895ffd9e 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -222,6 +222,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.paperConfigurations.initializeGlobalConfiguration(this.registryAccess());
         this.paperConfigurations.initializeWorldDefaultsConfiguration(this.registryAccess());
         // Paper end - initialize global and world-defaults configuration
+        org.leavesmc.lumina.config.LuminaConfig.setup(); //Lumina - load config file
         // Paper start - fix converting txt to json file; convert old users earlier after PlayerList creation but before file load/save
         if (this.convertOldUsers()) {
             this.getProfileCache().save(false); // Paper
@@ -290,6 +291,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         );
         dev.jorel.commandapi.CommandAPI.onEnable();
         // Lumina end - enable CommandAPI
+        org.leavesmc.lumina.LuminaCommand.INSTANCE.registerCommands(); // Lumina - register commands
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // Spigot - moved up
         this.server.loadPlugins();
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
index 66bdac50130f523f9dc4379b103b7a469f9ca36b..fef188c644ea1974cc5cd4b7044b6f9502965273 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -24,10 +24,16 @@ public class MinecraftInternalPlugin extends PluginBase {
     private final String pluginName;
     private PluginDescriptionFile pdf;
 
+    // Lumina start
     public MinecraftInternalPlugin() {
-        this.pluginName = "Minecraft";
+        this("MinecraftInternalPlugin");
+    }
+
+    public MinecraftInternalPlugin(String pluginName) {
+        this.pluginName = pluginName;
         pdf = new PluginDescriptionFile(pluginName, "1.0", "nms");
     }
+    // Lumina end
 
     public void setEnabled(boolean enabled) {
         this.enabled = enabled;
diff --git a/src/main/java/org/leavesmc/lumina/LuminaCommand.java b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b40980e4cf227242f957720c0296759d13bbbd5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
@@ -0,0 +1,224 @@
+package org.leavesmc.lumina;
+
+import com.mojang.logging.LogUtils;
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.config.ConfigNodeInfo;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.leavesmc.lumina.config.Validator;
+import org.slf4j.Logger;
+
+import java.util.Arrays;
+
+public class LuminaCommand {
+    private LuminaCommand() {
+    }
+
+    public static LuminaCommand INSTANCE = new LuminaCommand();
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public void registerCommands() {
+        registerLuminaCommand();
+        CarpetServer.registerCarpetCommands(); // TODO: move to CarpetServer later
+    }
+
+    private void registerLuminaCommand() {
+        String[] configNodes = LuminaConfig.nodeInfos.keySet().toArray(new String[0]);
+        new CommandAPICommand("lumina")
+                .withSubcommand(new CommandAPICommand("config")
+                        .withSubcommand(new CommandAPICommand("set")
+                                .withPermission("lumina.config.set")
+                                .withArguments(new StringArgument("node")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                                ).withArguments(new GreedyStringArgument("value")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(info -> {
+                                            String node = (String) info.previousArgs().get("node");
+                                            ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                            if (node == null || node.isEmpty() || nodeInfo == null) {
+                                                return new String[]{};
+                                            }
+                                            return nodeInfo.suggestions();
+                                        }))
+                                ).executes((sender, args) -> {
+                                    String node = (String) args.get("node");
+                                    ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                    if (node == null || nodeInfo == null) {
+                                        sendError(sender, "No config node specified.");
+                                        return;
+                                    }
+                                    String value = (String) args.get("value");
+                                    Class<?> type = nodeInfo.type();
+                                    Object parent = nodeInfo.parent();
+                                    if (value == null || value.isEmpty()) {
+                                        sendError(sender, "No value specified, expected: " + type.getSimpleName());
+                                        return;
+                                    }
+                                    try {
+                                        boolean save = LuminaConfig.configModule.misc.saveConfigAfterSet;
+                                        if (type.isEnum()) {
+                                            @SuppressWarnings({"unchecked", "rawtypes"})
+                                            Class<? extends Enum> enumType = (Class<? extends Enum>) type;
+                                            try {
+                                                @SuppressWarnings("unchecked")
+                                                Object enumValue = Enum.valueOf(enumType, value);
+                                                nodeInfo.field().set(parent, enumValue);
+                                            } catch (IllegalArgumentException ignored) {
+                                                sendError(sender, "Expected enum " + Arrays.toString(nodeInfo.suggestions()) + ", but entered: " + value);
+                                            }
+                                        } else {
+                                            switch (type.getSimpleName()) {
+                                                case "boolean" -> {
+                                                    boolean newValue;
+                                                    if ("true".equals(value)) {
+                                                        newValue = true;
+                                                    } else if ("false".equals(value)) {
+                                                        newValue = false;
+                                                    } else {
+                                                        sendError(sender, "Expected boolean, but entered: " + value);
+                                                        return;
+                                                    }
+                                                    Validator.ValidationResult result = Validator.validateBoolean(nodeInfo, newValue);
+                                                    if (result.type() != Validator.ValidationResultType.PASS) {
+                                                        sendError(sender, result.message());
+                                                        return;
+                                                    }
+                                                    nodeInfo.field().setBoolean(parent, newValue);
+                                                }
+                                                case "int" -> {
+                                                    try {
+                                                        int newValue = Integer.parseInt(value);
+                                                        Validator.ValidationResult result = Validator.validateInteger(nodeInfo, newValue);
+                                                        if (result.type() != Validator.ValidationResultType.PASS) {
+                                                            sendError(sender, result.message());
+                                                            return;
+                                                        }
+                                                        nodeInfo.field().setInt(parent, newValue);
+                                                    } catch (NumberFormatException ignored) {
+                                                        sendError(sender, "Expected int, but entered: " + value);
+                                                    }
+                                                }
+                                                case "long" -> {
+                                                    try {
+                                                        long newValue = Long.parseLong(value);
+                                                        Validator.ValidationResult result = Validator.validateLong(nodeInfo, newValue);
+                                                        if (result.type() != Validator.ValidationResultType.PASS) {
+                                                            sendError(sender, result.message());
+                                                            return;
+                                                        }
+                                                        nodeInfo.field().setLong(parent, newValue);
+                                                    } catch (NumberFormatException ignored) {
+                                                        sendError(sender, "Expected long, but entered: " + value);
+                                                    }
+                                                }
+                                                case "double" -> {
+                                                    try {
+                                                        double newValue = Double.parseDouble(value);
+                                                        Validator.ValidationResult result = Validator.validateDouble(nodeInfo, newValue);
+                                                        if (result.type() != Validator.ValidationResultType.PASS) {
+                                                            sendError(sender, result.message());
+                                                            return;
+                                                        }
+                                                        nodeInfo.field().setDouble(parent, newValue);
+                                                    } catch (NumberFormatException ignored) {
+                                                        sendError(sender, "Expected double, but entered: " + value);
+                                                    }
+                                                }
+                                                case "String" -> {
+                                                    Validator.ValidationResult result = Validator.validateString(nodeInfo, value);
+                                                    if (result.type() != Validator.ValidationResultType.PASS) {
+                                                        sendError(sender, result.message());
+                                                        return;
+                                                    }
+                                                    nodeInfo.field().set(parent, value);
+                                                }
+                                                default ->
+                                                        throw new IllegalStateException("Please report this to Lumina developers: unexpected config field type " + type.getName());
+                                            }
+                                        }
+                                        sendSuccess(sender, "Already set " + node + " to " + value);
+                                        if (save) {
+                                            LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                                                LOGGER.info("Saved Lumina config after setting {} to {}", node, value);
+                                                return null;
+                                            });
+                                        }
+                                    } catch (IllegalAccessException e) {
+                                        throw new RuntimeException("Please report this to Lumina developers: " + e);
+                                    }
+                                })
+                        ).withSubcommand(new CommandAPICommand("get")
+                                .withPermission("lumina.config.get")
+                                .withArguments(new StringArgument("node")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes))
+                                ).executes((sender, args) -> {
+                                    String node = (String) args.get("node");
+                                    ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                    if (node == null || nodeInfo == null) {
+                                        sendError(sender, "No config node specified.");
+                                        return;
+                                    }
+                                    try {
+                                        sendInfo(sender, "The value of " + node + " is " + nodeInfo.field().get(nodeInfo.parent()));
+                                    } catch (IllegalAccessException e) {
+                                        throw new RuntimeException("Please report this to Lumina developers: " + e);
+                                    }
+                                })
+                        ).withSubcommand(new CommandAPICommand("reload")
+                                .withPermission("lumina.config.reload")
+                                .executes((sender, args) -> {
+                                    sendSuccess(sender, "Reloading Lumina config...");
+                                    if (!(sender instanceof ConsoleCommandSender)) {
+                                        LOGGER.info("Reloading Lumina config...");
+                                    }
+                                    LuminaConfig.reloadAsync().thenApply((Void ignored) -> {
+                                        sendSuccess(sender, "Lumina config reloaded.");
+                                        if (!(sender instanceof ConsoleCommandSender)) {
+                                            LOGGER.info("Lumina config reloaded.");
+                                        }
+                                        return null;
+                                    });
+                                })
+                        ).withSubcommand(new CommandAPICommand("save"))
+                        .withPermission("lumina.config.set") // Cause `set` also called save, so use the same permission node
+                        .executes((sender, args) -> {
+                            sendSuccess(sender, "Saving Lumina config...");
+                            if (!(sender instanceof ConsoleCommandSender)) {
+                                LOGGER.info("Saving Lumina config...");
+                            }
+                            LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                                sendSuccess(sender, "Lumina config saved.");
+                                if (!(sender instanceof ConsoleCommandSender)) {
+                                    LOGGER.info("Lumina config saved.");
+                                }
+                                return null;
+                            });
+                        })
+                ).register();
+    }
+
+    public static void sendError(@NotNull CommandSender sender, String message) {
+        sendMessage(sender, message, NamedTextColor.RED);
+    }
+
+    public static void sendSuccess(@NotNull CommandSender sender, String message) {
+        sendMessage(sender, message, NamedTextColor.DARK_GREEN);
+    }
+
+    public static void sendInfo(@NotNull CommandSender sender, String message) {
+        sendMessage(sender, message, NamedTextColor.WHITE);
+    }
+
+    public static void sendMessage(@NotNull CommandSender sender, String message, TextColor color) {
+        sender.sendMessage(Component
+                .empty()
+                .color(color)
+                .append(Component.text(message)));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f7f258f8ddcde9f050691371662e18cb5f305a5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/ConfigNodeInfo.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config;
+
+import java.lang.reflect.Field;
+
+public record ConfigNodeInfo(
+        String[] suggestions,
+        Class<?> type,
+        Field field, Object parent,
+        Validator<?> validator) {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/ConfigUtils.java b/src/main/java/org/leavesmc/lumina/config/ConfigUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb991c96f88429099a42b43a9de2cf1825f2d89b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/ConfigUtils.java
@@ -0,0 +1,87 @@
+package org.leavesmc.lumina.config;
+
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.annotations.Suggestion;
+import org.leavesmc.lumina.config.annotations.Validate;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+
+public class ConfigUtils {
+    static final Set<Class<?>> CONFIG_FIELD_TYPES = new HashSet<>(Arrays.asList(
+            String.class,
+            boolean.class,
+            int.class,
+            long.class,
+            double.class));
+    static final MinecraftInternalPlugin INTERNAL_PLUGIN = new MinecraftInternalPlugin("LuminaConfigSystem");
+
+    @Contract("_ -> new")
+    public static @NotNull CompletableFuture<Void> runAsync(Runnable runnable) {
+        return CompletableFuture.runAsync(runnable, task -> Bukkit.getGlobalRegionScheduler().run(ConfigUtils.INTERNAL_PLUGIN, scheduled -> task.run()));
+    }
+
+    public static void generateNodeInfos(Map<String, ConfigNodeInfo> nodeInfoMap, @NotNull Class<?> clazz, String parentKey, @NotNull Object parent) throws IllegalAccessException {
+        for (Field field : clazz.getFields()) {
+            String fieldName = field.getName();
+            Class<?> fieldType = field.getType();
+            String key = parentKey == null ? toHyphen(fieldName) : parentKey + "." + toHyphen(fieldName);
+            boolean haveSuggestions = false;
+            String[] suggestions = null;
+            Validator<?> validator = new Validator<>();
+            for (Annotation annotation : field.getAnnotations()) {
+                if (annotation instanceof Suggestion value) {
+                    haveSuggestions = true;
+                    suggestions = value.value();
+                } else if (annotation instanceof Validate value) {
+                    try {
+                        validator = value.value().getDeclaredConstructor().newInstance();
+                    } catch (InstantiationException | InvocationTargetException | NoSuchMethodException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+            if (!haveSuggestions) {
+                if ("boolean".equals(fieldType.getSimpleName())) {
+                    suggestions = new String[]{"true", "false"};
+                    haveSuggestions = true;
+                } else if (ConfigUtils.CONFIG_FIELD_TYPES.contains(fieldType)) {
+                    suggestions = new String[]{field.get(parent).toString()};
+                    haveSuggestions = true;
+                } else if (fieldType.isEnum()) {
+                    suggestions = Arrays.stream(fieldType.getEnumConstants()).map(Object::toString).toArray(String[]::new);
+                    haveSuggestions = true;
+                }
+            }
+            if (haveSuggestions) {
+                nodeInfoMap.put(key, new ConfigNodeInfo(suggestions, fieldType, field, parent, validator));
+            } else {
+                generateNodeInfos(nodeInfoMap, fieldType, key, field.get(parent));
+            }
+        }
+    }
+
+    private static @NotNull String toHyphen(String input) {
+        if (input == null || input.isEmpty()) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < input.length(); i++) {
+            char ch = input.charAt(i);
+            if (Character.isUpperCase(ch) && i > 0) {
+                sb.append('-');
+            }
+            sb.append(Character.toLowerCase(ch));
+        }
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..48734da792646a8e690a4c8aba114e0b9cdf896e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
@@ -0,0 +1,91 @@
+package org.leavesmc.lumina.config;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+import org.spongepowered.configurate.loader.ConfigurationLoader;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+
+public class LuminaConfig {
+    public static LuminaConfigModule configModule;
+    private static ConfigurationLoader<CommentedConfigurationNode> loader;
+    private static CommentedConfigurationNode node;
+    public static Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+
+    public static void setup() {
+        Path hoconConfigPath = Path.of("lumina.conf");
+        boolean useHocon = Boolean.getBoolean("lumina.config.style.hocon") || Files.exists(hoconConfigPath);
+        boolean jsonStyle = Boolean.getBoolean("lumina.config.style.json");
+        if (useHocon || jsonStyle) {
+            loader = HoconConfigurationLoader.builder()
+                    .emitComments(true)
+                    .emitJsonCompatible(jsonStyle)
+                    .prettyPrinting(true)
+                    .path(hoconConfigPath)
+                    .build();
+        } else {
+            loader = YamlConfigurationLoader.builder()
+                    .nodeStyle(NodeStyle.BLOCK)
+                    .indent(2)
+                    .path(Path.of("lumina.yml"))
+                    .build();
+        }
+
+        loadConfig();
+        saveConfig();
+
+        try {
+            ConfigUtils.generateNodeInfos(nodeInfos, LuminaConfigModule.class, null, LuminaConfig.configModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void reload() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        loadConfig();
+    }
+
+    private static void loadConfig() {
+        try {
+            node = loader.load();
+            configModule = node.get(LuminaConfigModule.class);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void save() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        saveConfig();
+    }
+
+    private static void saveConfig() {
+        try {
+            node.set(LuminaConfigModule.class, configModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> reloadAsync() {
+        return ConfigUtils.runAsync(LuminaConfig::reload);
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> saveAsync() {
+        return ConfigUtils.runAsync(LuminaConfig::save);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c2bf30ef6035575e56c8743f1abee8ac8b8d558
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfigModule.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config;
+
+import org.leavesmc.lumina.config.modules.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LuminaConfigModule {
+    public String configVersion = "1";
+    public Fix fix = new Fix();
+    public Protocol protocol = new Protocol();
+    public Performance performance = new Performance();
+    public Modify modify = new Modify();
+    public Misc misc = new Misc();
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/Validator.java b/src/main/java/org/leavesmc/lumina/config/Validator.java
new file mode 100644
index 0000000000000000000000000000000000000000..18cc13bccf468ae730402449be0bd5303a39ee39
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/Validator.java
@@ -0,0 +1,121 @@
+package org.leavesmc.lumina.config;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+public class Validator<T> {
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public boolean validate(T newValue, T oldValue) {
+        return true;
+    }
+
+    public String getErrorMessage(T newValue) {
+        return "Invalid value: " + newValue;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateString(@NotNull ConfigNodeInfo nodeInfo, String newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<String> validator = (Validator<String>) nodeInfo.validator();
+                if (!validator.validate(newValue, (String) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateBoolean(@NotNull ConfigNodeInfo nodeInfo, Boolean newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Boolean> validator = (Validator<Boolean>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Boolean) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateInteger(@NotNull ConfigNodeInfo nodeInfo, Integer newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Integer> validator = (Validator<Integer>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Integer) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateLong(@NotNull ConfigNodeInfo nodeInfo, Long newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Long> validator = (Validator<Long>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Long) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static ValidationResult validateDouble(@NotNull ConfigNodeInfo nodeInfo, Double newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<Double> validator = (Validator<Double>) nodeInfo.validator();
+                if (!validator.validate(newValue, (Double) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <E> ValidationResult validate(@NotNull ConfigNodeInfo nodeInfo, E newValue) {
+        if (nodeInfo.validator() != null) {
+            try {
+                Validator<E> validator = (Validator<E>) nodeInfo.validator();
+                if (!validator.validate(newValue, (E) nodeInfo.field().get(nodeInfo.parent()))) {
+                    return ValidationResult.failed(validator.getErrorMessage(newValue));
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return ValidationResult.pass();
+    }
+
+    public enum ValidationResultType {
+        PASS, FAILED
+    }
+
+    public record ValidationResult(ValidationResultType type, String message) {
+        @Contract(" -> new")
+        public static @NotNull ValidationResult pass() {
+            return new ValidationResult(ValidationResultType.PASS, null);
+        }
+
+        @Contract("_ -> new")
+        public static @NotNull ValidationResult failed(String message) {
+            return new ValidationResult(ValidationResultType.FAILED, message);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7a2e319e7dbc733b9ec9f9b67ec4ddf182dc6df
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Suggestion.java
@@ -0,0 +1,15 @@
+package org.leavesmc.lumina.config.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * 在用户使用命令修改Config时提供常量字符串列表建议
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Suggestion {
+    String[] value() default {};
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fff13fd26a134118dac8949ee061c92055fdbde
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/annotations/Validate.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.annotations;
+
+import org.leavesmc.lumina.config.Validator;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Validate {
+    Class<? extends Validator> value() default Validator.class;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Fix.java b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
new file mode 100644
index 0000000000000000000000000000000000000000..4df98b3dd4a42068c43a98c399b8ebbfe3157119
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.fix.FixFoliaEntityMovingFixConfig;
+import org.leavesmc.lumina.config.modules.fix.FixFoliaTeleportAsyncConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Fix {
+    public FixFoliaEntityMovingFixConfig fixFoliaEntityMoving = new FixFoliaEntityMovingFixConfig();
+    public FixFoliaTeleportAsyncConfig fixFoliaTeleportAsync = new FixFoliaTeleportAsyncConfig();
+    public boolean fixFoliaSpectorTeleport = true;
+    public boolean allowUnsafeTeleportation = true;
+    public boolean fixVoidTrading = true;
+    public boolean useVanillaRandomSourceForPlayers = true;
+    public boolean fixFoliaPoiAccessOffRegion = true;
+    public boolean mc2025 = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Misc.java b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6f41a391d597655d799249a17445dda22c83f03
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
@@ -0,0 +1,20 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.misc.RegionFormatConfig;
+import org.leavesmc.lumina.config.modules.misc.WatchdogConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Misc {
+    public boolean mojangChatSign = true;
+    public boolean allowInorderChat = true;
+    public boolean offlineModeWarning = true;
+    public String serverModName = "Lumina";
+    public boolean fakeVanilla = false;
+    public boolean checkUsername = true;
+    public boolean alternativeKeepAlive = true;
+    public boolean saveConfigAfterSet = true;
+    public boolean verifyPublicKeyOnlyInOnlineMode = false;
+    public WatchdogConfig watchdog = new WatchdogConfig();
+    public RegionFormatConfig regionFormat = new RegionFormatConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Modify.java b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
new file mode 100644
index 0000000000000000000000000000000000000000..b22fa9a59a6a26788a26ba217ac6e8847c71d9f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Modify.java
@@ -0,0 +1,7 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Modify {
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
new file mode 100644
index 0000000000000000000000000000000000000000..4739bdb828be18d9bec7ae2d6c6b332de879acee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.performance.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Performance {
+    public PetalReduceSensorWorkConfig petalReduceSensorWork = new PetalReduceSensorWorkConfig();
+    public ProjectileChunkReduceConfig projectileChunkReduce = new ProjectileChunkReduceConfig();
+    public DynamicEntityActivationRangeConfig dynamicEntityActivationRange = new DynamicEntityActivationRangeConfig();
+    public boolean entityGoalSelectorInactiveTick = false;
+    public boolean allowLoadChunksToActiveClimbingEntities = false;
+    public boolean optimizeSuffocation = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d91f7ea07e768c6e2c60386e143242fc20e9152
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.protocol.LeavesBladerenProtocolConfig;
+import org.leavesmc.lumina.config.modules.protocol.PcaSyncProtocolConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Protocol {
+    public boolean carpetProtocol = false;
+    public boolean jadeProtocol = false;
+    public boolean bborProtocol = false;
+    public PcaSyncProtocolConfig pcaSyncProtocol = new PcaSyncProtocolConfig();
+    public LeavesBladerenProtocolConfig leavesBladerenProtocol = new LeavesBladerenProtocolConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abda15610a48676d145ef26bae7a7340b88b0ee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaEntityMovingFixConfig {
+    public boolean enabled = false;
+    public boolean warnOnDetected = true;
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..b043bf36de0604028cb7bdd166d000d2dec76360
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaTeleportAsyncConfig {
+    public boolean enabled = false;
+    public boolean throwOnDetected = true;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..35aed045ceb1f7647de4b0efbf7c609f62c402d8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.stupidcraft.linearpaper.region.EnumRegionFileExtension;
+
+@ConfigSerializable
+public class RegionFormatConfig {
+    public EnumRegionFileExtension format = EnumRegionFileExtension.MCA;
+    public int linearCompressionLevel = 1;
+    public int linearFlushFrequency = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e79b3e1dfa56896c20e3b7e9c9d0cc37257af05
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class WatchdogConfig {
+    public boolean enabled = false;
+    public long warnPeriodTicks = 5 * 20;
+    public long timeOutTicks = 30 * 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..92334d8b7617616f3991fd58949e3714d159eeed
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+
+@ConfigSerializable
+public class DynamicEntityActivationRangeConfig {
+    public boolean enabled = false;
+    public int startDistanceSquared = 144;
+    public int maximumActivationPriority = 20;
+    public int activationDistanceMod = 8;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..db160578fa0d35a275f953e88f04340c20d08942
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
@@ -0,0 +1,8 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LoadChunksToActiveClimbingEntitiesConfig {
+    public boolean allow = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..eed3fe3a9a7d5aa6eeeb3c2c3a40d73eafdd3f3f
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PetalReduceSensorWorkConfig {
+    public boolean enabled = true;
+    public int delayTicks = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb64dd4c224c9246fa8d999c8217096f7bebe89b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class ProjectileChunkReduceConfig {
+    public int maxProjectileLoadsPerTick;
+    public int maxProjectileLoadsPerProjectile;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..75352347781b590ddef6680bd8816bdc06631640
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/LeavesBladerenProtocolConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LeavesBladerenProtocolConfig {
+    public boolean enableBaseProtocol = false;
+    public boolean msptSyncProtocol = false;
+    public int msptSyncTickInterval = 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..119b50c12f08c548e7a56dd983805324526fc35e
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/protocol/PcaSyncProtocolConfig.java
@@ -0,0 +1,17 @@
+package org.leavesmc.lumina.config.modules.protocol;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PcaSyncProtocolConfig {
+    public boolean enabled = false;
+    public SyncOption sync = SyncOption.OPS;
+
+    public enum SyncOption {
+        NOBODY,
+        BOT,
+        OPS,
+        OPS_AND_SELF,
+        EVERYONE
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ReflectTargetField.java b/src/main/java/org/leavesmc/lumina/utils/ReflectTargetField.java
new file mode 100644
index 0000000000000000000000000000000000000000..4deb7ca3c09a03faf0ddf2b49d0a0581a9682c75
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ReflectTargetField.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.utils;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface ReflectTargetField {
+}
