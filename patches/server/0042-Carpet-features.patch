From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7@outlook.com>
Date: Fri, 20 Sep 2024 15:15:02 +0800
Subject: [PATCH] Carpet features

This patch is Powered by Leaves(https://github.com/LeavesMC/Leaves) and fabric-carpet(https://github.com/gnembon/fabric-carpet)
Licenses:
- GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html) (https://github.com/LeavesMC/Leaves?tab=License-1-ov-file)
- MIT license (https://github.com/gnembon/fabric-carpet?tab=MIT-1-ov-file#readme)

diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 811479551bad422123ad1b09329e6fc8e12c7c4e..b8211313f823f0b6bdae43ad43819302e9c097ea 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -80,7 +80,7 @@ public final class ChunkHolderManager {
     private static final long PROBE_MARKER = Long.MIN_VALUE + 1;
     public final ReentrantAreaLock ticketLockArea;
 
-    private final ConcurrentLong2ReferenceChainedHashTable<SortedArraySet<Ticket<?>>> tickets = new ConcurrentLong2ReferenceChainedHashTable<>();
+    public final ConcurrentLong2ReferenceChainedHashTable<SortedArraySet<Ticket<?>>> tickets = new ConcurrentLong2ReferenceChainedHashTable<>(); // Lumina - private -> public
     private final ConcurrentLong2ReferenceChainedHashTable<Long2IntOpenHashMap> sectionToChunkToExpireCount = new ConcurrentLong2ReferenceChainedHashTable<>();
     final ChunkUnloadQueue unloadQueue;
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionShutdownThread.java b/src/main/java/io/papermc/paper/threadedregions/RegionShutdownThread.java
index 261b3019878c31a9e44e56b6611899de6c00ebee..3b6c3b45425f7325a3b9c0ed96a0c7bc730b566e 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionShutdownThread.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionShutdownThread.java
@@ -160,6 +160,7 @@ public final class RegionShutdownThread extends ca.spottedleaf.moonrise.common.u
             TickRegions.getScheduler().dumpAliveThreadTraces("Did not shut down in time");
         }
 
+        org.leavesmc.lumina.carpet.CarpetServer.onServerClosed(MinecraftServer.getServer()); // Lumina - Porting Carpet's features - call onServerClosed
         MinecraftServer.getServer().stopServer(); // stop part 1: most logic, kicking players, plugins, etc
         // halt all chunk systems first so that any in-progress chunk generation stops
         LOGGER.info("Halting chunk systems...");
diff --git a/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java b/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
index 6dd6e90dc0eea7fd15ece7088e23c4e334c95589..256b592c2cf57334c5ce3cb68a8857ba219667e3 100644
--- a/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
+++ b/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
@@ -59,7 +59,7 @@ public class BlockInput implements Predicate<BlockInWorld> {
     }
 
     public boolean place(ServerLevel world, BlockPos pos, int flags) {
-        BlockState blockState = Block.updateFromNeighbourShapes(this.state, world, pos);
+        BlockState blockState = (org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) ? this.state : Block.updateFromNeighbourShapes(this.state, world, pos); // Lumina - Porting Carpet's features - fill updates
         if (blockState.isAir()) {
             blockState = this.state;
         }
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index 928f38fd6beb00753c92ae9f4678f7507519a39b..3681897ce089693133b6bc86c7ed34b0c097eb16 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -128,8 +128,25 @@ public enum Direction implements StringRepresentable, ca.spottedleaf.moonrise.pa
     }
 
     public static Direction[] orderedByNearest(Entity entity) {
-        float f = entity.getViewXRot(1.0F) * (float) (Math.PI / 180.0);
-        float g = -entity.getViewYRot(1.0F) * (float) (Math.PI / 180.0);
+        // Lumina start - Porting Carpet's features
+        float pitch = entity.getViewXRot(1.0F);
+        if (org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(entity)) {
+            pitch = -pitch;
+        }
+        float f = pitch * (float) (Math.PI / 180.0);
+        float yaw;
+        if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().placementRotationFix) {
+            yaw = entity.getViewYRot(1.0F);
+        }
+        else {
+            yaw = entity.getMainYaw(1.0F);
+        }
+        if (org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(entity))
+        {
+            yaw += 180f;
+        }
+        float g = -yaw * (float) (Math.PI / 180.0);
+        // Lumina end - Porting Carpet's features
         float h = Mth.sin(f);
         float i = Mth.cos(f);
         float j = Mth.sin(g);
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 30e3d0d7b0ca8cfa30efb60eefa73d94c65c4690..f24ad290d7d1c14e5ff1dbc92ccc40d68360372e 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -104,7 +104,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     @Nullable
     private volatile PacketListener disconnectListener;
     @Nullable
-    private volatile PacketListener packetListener;
+    protected volatile PacketListener packetListener; // Lumina - Porting Carpet's features - fakeplayer
     @Nullable
     private DisconnectionDetails disconnectionDetails;
     private boolean encrypted;
@@ -156,6 +156,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.setReadOnly();
         this.stopReadingPackets = true;
     }
+    // Lumina start - Porting Carpet's features
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+    // Lumina end - Porting Carpet's features
     // Paper end - packet limiter
     @Nullable public SocketAddress haProxyAddress; // Paper - Add API to get player's proxy address
 
@@ -272,6 +277,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     protected void channelRead0(ChannelHandlerContext channelhandlercontext, Packet<?> packet) {
+        org.leavesmc.lumina.carpet.logging.logHelpers.PacketCounter.totalIn++; // Lumina - Porting Carpet's features
         if (this.channel.isOpen()) {
             PacketListener packetlistener = this.packetListener;
 
@@ -517,6 +523,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks, boolean flush) {
+        org.leavesmc.lumina.carpet.logging.logHelpers.PacketCounter.totalOut++; // Lumina - Porting Carpet's features
         ++this.sentPackets;
         if (this.channel.eventLoop().inEventLoop()) {
             this.doSendPacket(packet, callbacks, flush);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 5ee586507dc07552266902722a757353bfeb3114..1350aad84f37671a58a85b73331fb6b849322b28 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -548,6 +548,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     protected abstract boolean initServer() throws IOException;
 
     protected void loadLevel(String s) { // CraftBukkit
+        org.leavesmc.lumina.carpet.CarpetServer.onServerLoaded(this); // Lumina - Porting Carpet's features - call onServerLoaded
         if (!JvmProfiler.INSTANCE.isRunning()) {
             ;
         }
@@ -568,7 +569,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 MinecraftServer.LOGGER.warn("Failed to stop JFR profiling", throwable);
             }
         }
-
+        org.leavesmc.lumina.carpet.CarpetServer.onServerLoadedWorlds(this); // Lumina - Porting Carpet's features - call onServerLoadedWorlds
     }
 
     protected void forceDifficulty() {}
diff --git a/src/main/java/net/minecraft/server/ServerFunctionLibrary.java b/src/main/java/net/minecraft/server/ServerFunctionLibrary.java
index fa5d4bfd52eb36e48fc811dbbdc1341204cf171d..3bc25d167a34aa57741a5fc6ceecbd754a3f25e0 100644
--- a/src/main/java/net/minecraft/server/ServerFunctionLibrary.java
+++ b/src/main/java/net/minecraft/server/ServerFunctionLibrary.java
@@ -44,6 +44,7 @@ public class ServerFunctionLibrary implements PreparableReloadListener {
     );
     private volatile Map<ResourceLocation, List<CommandFunction<CommandSourceStack>>> tags = Map.of();
     private final int functionCompilationLevel;
+    @org.leavesmc.lumina.utils.ReflectTargetField // Lumina - Command API
     private final CommandDispatcher<CommandSourceStack> dispatcher;
 
     public Optional<CommandFunction<CommandSourceStack>> getFunction(ResourceLocation id) {
diff --git a/src/main/java/net/minecraft/server/commands/CloneCommands.java b/src/main/java/net/minecraft/server/commands/CloneCommands.java
index 4ef85ed8bf47650fba433c57ffd342d9f42239d5..784be19faa8d3e8acddc602186cf4695f708079d 100644
--- a/src/main/java/net/minecraft/server/commands/CloneCommands.java
+++ b/src/main/java/net/minecraft/server/commands/CloneCommands.java
@@ -321,7 +321,7 @@ public class CloneCommands {
                 }
 
                 for (CloneCommands.CloneBlockInfo cloneBlockInfo4 : list5) {
-                    serverLevel2.blockUpdated(cloneBlockInfo4.pos, cloneBlockInfo4.state.getBlock());
+                    if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().fillUpdates) serverLevel2.blockUpdated(cloneBlockInfo4.pos, cloneBlockInfo4.state.getBlock()); // Lumina - Porting Carpet's features - fill updates
                 }
 
                 serverLevel2.getBlockTicks().copyAreaFrom(serverLevel.getBlockTicks(), boundingBox, blockPos5);
diff --git a/src/main/java/net/minecraft/server/commands/FillCommand.java b/src/main/java/net/minecraft/server/commands/FillCommand.java
index d52a31656f2ade6d860cee6bc2f7d92a0588d643..c438e708d83443bf345c44bf3e29803afee4e5b0 100644
--- a/src/main/java/net/minecraft/server/commands/FillCommand.java
+++ b/src/main/java/net/minecraft/server/commands/FillCommand.java
@@ -197,7 +197,7 @@ public class FillCommand {
 
             for (BlockPos blockPos2 : list) {
                 Block block2 = serverLevel.getBlockState(blockPos2).getBlock();
-                serverLevel.blockUpdated(blockPos2, block2);
+                if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().fillUpdates)  serverLevel.blockUpdated(blockPos2, block2); // Lumina - Porting Carpet's features - fill updates
             }
 
             if (k == 0) {
diff --git a/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java b/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
index 87275b46c4411fd51d6572ec7b3f924e347d4ed7..171adc513e936375b27f6a3e68000c6a8579c478 100644
--- a/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
+++ b/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
@@ -183,8 +183,10 @@ public class ForceLoadCommand {
             int o = SectionPos.blockToSectionCoord(k);
             int p = SectionPos.blockToSectionCoord(l);
             long q = ((long)(o - m) + 1L) * ((long)(p - n) + 1L);
-            if (q > 256L) {
-                throw ERROR_TOO_MANY_CHUNKS.create(256, q);
+            // Lumina start - Porting Carpet's features - forceload limit
+            if (q > (long)org.leavesmc.lumina.carpet.CarpetConfig.configModule().forceloadLimit) {
+                throw ERROR_TOO_MANY_CHUNKS.create(org.leavesmc.lumina.carpet.CarpetConfig.configModule().forceloadLimit, q);
+                // Lumina end - Porting Carpet's features - forceload limit
             } else {
                 ServerLevel serverLevel = source.getLevel();
                 ResourceKey<Level> resourceKey = serverLevel.dimension();
diff --git a/src/main/java/net/minecraft/server/commands/SetBlockCommand.java b/src/main/java/net/minecraft/server/commands/SetBlockCommand.java
index ea13a3b409b8a4a6a77071c700b4dd0a33b02716..ecb531866ce828d641e76f77c6649257e5dcd188 100644
--- a/src/main/java/net/minecraft/server/commands/SetBlockCommand.java
+++ b/src/main/java/net/minecraft/server/commands/SetBlockCommand.java
@@ -111,7 +111,7 @@ public class SetBlockCommand {
             if (bl && !block.place(serverLevel, pos, 2)) {
                 throw ERROR_FAILED.create();
             } else {
-                serverLevel.blockUpdated(pos, block.getState().getBlock());
+                if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().fillUpdates) serverLevel.blockUpdated(pos, block.getState().getBlock()); // Lumina - Porting Carpet's features - fill updates
                 source.sendSuccess(() -> Component.translatable("commands.setblock.success", pos.getX(), pos.getY(), pos.getZ()), true);
                 return; // Folia - region threading
             }
diff --git a/src/main/java/net/minecraft/server/commands/SummonCommand.java b/src/main/java/net/minecraft/server/commands/SummonCommand.java
index fb80b635d279a18758c6b0ce99858326bcade38e..a94f79ad50617af7128c27747a24a96688e54a83 100644
--- a/src/main/java/net/minecraft/server/commands/SummonCommand.java
+++ b/src/main/java/net/minecraft/server/commands/SummonCommand.java
@@ -45,6 +45,26 @@ public class SummonCommand {
         })))));
     }
 
+    // Lumina start - Porting Carpet's features - lighting
+    private static BlockPos blockPosAddRiders(Entity entity) {
+        // [CM] SummonNaturalLightning - if statement around
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().summonNaturalLightning && entity instanceof net.minecraft.world.entity.LightningBolt && !entity.getCommandSenderWorld().isClientSide) {
+            ServerLevel world = (ServerLevel) entity.getCommandSenderWorld();
+            BlockPos at = entity.blockPosition();
+            net.minecraft.world.DifficultyInstance localDifficulty_1 =  world.getCurrentDifficultyAt(at);
+            boolean boolean_2 = world.getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_DOMOBSPAWNING) && world.random.nextDouble() < (double)localDifficulty_1.getEffectiveDifficulty() * 0.01D;
+            if (boolean_2) {
+                net.minecraft.world.entity.animal.horse.SkeletonHorse skeletonHorseEntity_1 = EntityType.SKELETON_HORSE.create(world, EntitySpawnReason.EVENT);
+                skeletonHorseEntity_1.setTrap(true);
+                skeletonHorseEntity_1.setAge(0);
+                skeletonHorseEntity_1.setPos(entity.getX(), entity.getY(), entity.getZ());
+                world.addFreshEntity(skeletonHorseEntity_1);
+            }
+        }
+        return entity.blockPosition();
+    }
+    // Lumina end - Porting Carpet's features - lighting
+
     public static Entity createEntity(CommandSourceStack source, Holder.Reference<EntityType<?>> entityType, Vec3 pos, CompoundTag nbt, boolean initialize) throws CommandSyntaxException {
         BlockPos blockposition = BlockPos.containing(pos);
 
@@ -68,7 +88,7 @@ public class SummonCommand {
                 io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
                     worldserver, entity.chunkPosition().x, entity.chunkPosition().z, () -> {
                         if (initialize && entity instanceof Mob) {
-                            ((Mob) entity).finalizeSpawn(source.getLevel(), source.getLevel().getCurrentDifficultyAt(entity.blockPosition()), EntitySpawnReason.COMMAND, (SpawnGroupData) null);
+                            ((Mob) entity).finalizeSpawn(source.getLevel(), source.getLevel().getCurrentDifficultyAt(blockPosAddRiders(entity)), EntitySpawnReason.COMMAND, (SpawnGroupData) null); // Lumina - Porting Carpet's features - lighting
                         }
                         worldserver.tryAddFreshEntityWithPassengers(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.COMMAND);
                     }
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index d55a3f3636cd86977f6db6966139e6a6ae721a72..15e9f30ec0c43e70419a9f930b2b877f7aebceb1 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -294,6 +294,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         );
         dev.jorel.commandapi.CommandAPI.onEnable();
         // Lumina end - enable CommandAPI
+        org.leavesmc.lumina.carpet.CarpetServer.onGameStarted(); // Lumina - Implementation Carpet features
         org.leavesmc.lumina.LuminaCommand.INSTANCE.registerCommands(); // Lumina - register commands
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // Spigot - moved up
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 044d1787481eecdf41eaa932e418d748920ebef3..0f722f1ff4ccea02bc0e903509bc15c1ecfae4bf 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -796,6 +796,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private boolean skipPlayer(ServerPlayer player) {
+        if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().creativePlayersLoadChunks && player.isCreative()) return true; // Lumina - Porting Carpet's features - creative players load chunks
         return player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
     }
 
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index f6015f2ac77aeddbd900226d183bf24c93112b21..0bbebffc858e01f0275d1c9db5db7532dc3d8fcd 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -36,6 +36,37 @@ import org.slf4j.Logger;
 
 public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemDistanceManager, ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager { // Paper - rewrite chunk system // Paper - chunk tick iteration optimisation
 
+    // Lumina start - Porting Carpet's features - spawn chunks
+    public void changeSpawnChunks(ChunkPos chunkPos,  int distance)
+    {
+        long pos = chunkPos.toLong();
+        SortedArraySet<Ticket<?>> set = moonrise$getChunkHolderManager().tickets.get(pos);
+        Ticket<?> existingTicket = null;
+        if (set != null)
+        {
+            Iterator<Ticket<?>> iter = set.iterator();
+            while(iter.hasNext())
+            {
+                Ticket<?> ticket = iter.next();
+                if (ticket.getType() == TicketType.START)
+                {
+                    existingTicket = ticket;
+                    iter.remove();
+                }
+            }
+            set.add(existingTicket);
+        }
+        // the reason we are removing the ticket this way is that there are sideeffects of removal
+        if (existingTicket != null)
+        {
+            removeTicket(pos, existingTicket);
+        }
+        // set optionally new spawn ticket
+        if (distance > 0)
+            addRegionTicket(TicketType.START, chunkPos, distance, net.minecraft.util.Unit.INSTANCE);
+    }
+    // Lumina end - Porting Carpet's features - spawn chunks
+
     static final Logger LOGGER = LogUtils.getLogger();
     static final int PLAYER_TICKET_LEVEL = ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING);
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index ca47a512452ae425160e30dc7c4a79f40aa97a26..679dc34019331b83ff03e0aa56645412cebccc1b 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -525,6 +525,39 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             this.broadcastChangedChunks(gameprofilerfiller);
             } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); } // Folia - profiler
             gameprofilerfiller.pop();
+            // Lumina start - Porting Carpet's features
+            net.minecraft.world.level.storage.LevelData levelData = this.level.getLevelData(); // levelProperies class
+            boolean boolean_3 = levelData.getGameTime() % 400L == 0L;
+            if (org.leavesmc.lumina.carpet.utils.SpawnReporter.trackingSpawns() && org.leavesmc.lumina.carpet.utils.SpawnReporter.local_spawns != null)
+            {
+                for (net.minecraft.world.entity.MobCategory cat: org.leavesmc.lumina.carpet.utils.SpawnReporter.cachedMobCategories())
+                {
+                    net.minecraft.resources.ResourceKey<Level> dim = level.dimension(); // getDimensionType;
+                    org.apache.commons.lang3.tuple.Pair<net.minecraft.resources.ResourceKey<Level>, net.minecraft.world.entity.MobCategory> key = org.apache.commons.lang3.tuple.Pair.of(dim, cat);
+                    int spawnTries = org.leavesmc.lumina.carpet.utils.SpawnReporter.spawn_tries.get(cat);
+                    if (!org.leavesmc.lumina.carpet.utils.SpawnReporter.local_spawns.containsKey(cat)) {
+                        if (!cat.isPersistent() || boolean_3) { // isAnimal
+                            // fill mobcaps for that category so spawn got cancelled
+                            org.leavesmc.lumina.carpet.utils.SpawnReporter.spawn_ticks_full.addTo(key, spawnTries);
+                        }
+
+                    } else if (org.leavesmc.lumina.carpet.utils.SpawnReporter.local_spawns.getLong(cat) > 0) {
+                        // tick spawned mobs for that type
+                        org.leavesmc.lumina.carpet.utils.SpawnReporter.spawn_ticks_succ.addTo(key, spawnTries);
+                        org.leavesmc.lumina.carpet.utils.SpawnReporter.spawn_ticks_spawns.addTo(key, org.leavesmc.lumina.carpet.utils.SpawnReporter.local_spawns.getLong(cat));
+                        // this will be off comparing to 1.13 as that would succeed if
+                        // ANY tries in that round were successful.
+                        // there will be much more difficult to mix in
+                        // considering spawn tries to remove, as with warp
+                        // there is little need for them anyways.
+                    } else {// spawn no mobs despite trying
+                        //tick didn's spawn mobs of that type
+                        org.leavesmc.lumina.carpet.utils.SpawnReporter.spawn_ticks_fail.addTo(key, spawnTries);
+                    }
+                }
+            }
+            org.leavesmc.lumina.carpet.utils.SpawnReporter.local_spawns = null;
+            // Lumina end - Porting Carpet's features
         }
     }
 
@@ -573,7 +606,22 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
         final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle foliaProfiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         profiler.popPush("naturalSpawnCount");
-        int j = this.distanceManager.getNaturalSpawnChunkCount();
+        // Lumina start - Porting Carpet's features
+        int j = distanceManager.getNaturalSpawnChunkCount();
+        net.minecraft.resources.ResourceKey<Level> dim = this.level.dimension();
+        org.leavesmc.lumina.carpet.utils.SpawnReporter.chunkCounts.put(dim, j);
+
+        if (org.leavesmc.lumina.carpet.utils.SpawnReporter.trackingSpawns()) {
+            //local spawns now need to be tracked globally cause each calll is just for chunk
+            org.leavesmc.lumina.carpet.utils.SpawnReporter.local_spawns = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
+            org.leavesmc.lumina.carpet.utils.SpawnReporter.first_chunk_marker = new java.util.HashSet<>();
+            for (net.minecraft.world.entity.MobCategory cat : org.leavesmc.lumina.carpet.utils.SpawnReporter.cachedMobCategories())
+            {
+                org.apache.commons.lang3.tuple.Pair<net.minecraft.resources.ResourceKey<Level>, net.minecraft.world.entity.MobCategory> key = org.apache.commons.lang3.tuple.Pair.of(dim, cat);
+                org.leavesmc.lumina.carpet.utils.SpawnReporter.overall_spawn_ticks.addTo(key, org.leavesmc.lumina.carpet.utils.SpawnReporter.spawn_tries.get(cat));
+            }
+        }
+        // Lumina end - Porting Carpet's features
         // Paper start - Optional per player mob spawns
         final int naturalSpawnChunkCount = j;
         NaturalSpawner.SpawnState spawnercreature_d; // moved down
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index fa5ed398ae1c74775e93eb3b80abde324a1d2b9d..8ca98b4b4854294a1659ec2a9f7f55733685d8aa 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -316,7 +316,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.EntityDataController entityDataController;
     private final ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.PoiDataController poiDataController;
     private final ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController chunkDataController;
-    private final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler;
+    public final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler; // Lumina - private -> public
     private long lastMidTickFailure;
     private long tickedBlocksOrFluids;
     // Folia - region threading - move to regionized data
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index ad8da6726b4113068b200426ab1ac1e24a061942..a085af3507147e4d3549f20d4bc5d10328e95ae4 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -584,8 +584,7 @@ public class ServerPlayerGameMode {
             InteractionResult enuminteractionresult;
 
             if (!flag1) {
-                InteractionResult enuminteractionresult1 = iblockdata.useItemOn(player.getItemInHand(hand), world, player, hand, hitResult);
-
+                InteractionResult enuminteractionresult1 = (org.leavesmc.lumina.carpet.helpers.BlockRotator.flipBlockWithCactus(iblockdata, world, player, hand, hitResult)) ? InteractionResult.SUCCESS : iblockdata.useItemOn(player.getItemInHand(hand), world, player, hand, hitResult); // Lumina - Porting Carpet's features - cactus block rotation
                 if (enuminteractionresult1.consumesAction()) {
                     CriteriaTriggers.ITEM_USED_ON_BLOCK.trigger(player, blockposition, itemstack1);
                     return enuminteractionresult1;
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index 52a6cb54186a4d66e7eb1afb0aeb7e3536edc4bb..fa1d9e76e9d2e0efbec4421dc156828facf92611 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -126,6 +126,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     }
     public void onDisconnect(DisconnectionDetails info, @Nullable net.kyori.adventure.text.Component quitMessage) {
         // Paper end - Fix kick event leave message not being sent
+        org.leavesmc.lumina.carpet.CarpetServer.onPlayerLoggedOut(this.player, quitMessage); // Lumina - Porting Carpet's features
         // Folia start - region threading
         if (this.handledDisconnect) {
             // avoid retiring scheduler twice
@@ -147,6 +148,12 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         this.server.reportPacketHandlingException(exception, packet.type());
     }
 
+    // Lumina start - Porting Carpet's features
+    public Connection getConnection() {
+        return connection;
+    }
+    // Lumina end - Porting Carpet's features
+
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
         // Purpur start
@@ -291,7 +298,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         long elapsedTime = currentTime - this.keepAliveTime;
 
         // Purpur start
-        if (org.leavesmc.lumina.config.LuminaConfig.configModule().misc.alternativeKeepAlive) {
+        if (org.leavesmc.lumina.config.LuminaConfig.configModule().misc.alternativeKeepAlive){
             if (elapsedTime >= 1000L) { // 1 second
                 if (this.keepAlivePending && !this.processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
                     LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName());
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 7783e023e84ab84e3903fc0371aad08a82cf69d0..becf13d3fd2637350625343f1f432d76fc8b81fe 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -353,6 +353,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     @Override
     public void tick() {
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled) {
+            if (aboveGroundTickCount > 70) aboveGroundTickCount--;
+            if (aboveGroundVehicleTickCount > 70) aboveGroundVehicleTickCount--;
+        }
+        // Lumina end - Porting Carpet's features
         // Folia start - region threading
         this.keepConnectionAlive();
         if (this.processedDisconnect || this.player.wonGame) {
@@ -599,7 +605,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 }
                 // Paper end - Prevent moving into unloaded chunks
 
-                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) {
+                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !(this.isSingleplayerOwner() || org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled)) { // Lumina - Porting Carpet's features - disable anticheat
                 // CraftBukkit end
                     ServerGamePacketListenerImpl.LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", new Object[]{entity.getName().getString(), this.player.getName().getString(), d6, d7, d8});
                     this.send(ClientboundMoveVehiclePacket.fromEntity(entity));
@@ -1518,7 +1524,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 }
                                 // Paper end - Prevent moving into unloaded chunks
 
-                                if (this.shouldCheckPlayerMovement(flag)) {
+                                if (!(org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled) && this.shouldCheckPlayerMovement(flag)) { // Lumina - Porting Carpet's features - disable anticheat
                                     float f2 = flag ? 300.0F : 100.0F;
 
                                     if (d10 - d9 > Math.max(f2, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2))) {
@@ -1597,7 +1603,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             d10 = d6 * d6 + d7 * d7 + d8 * d8;
                             boolean movedWrongly = false; // Paper - Add fail move event; rename
 
-                            if (!this.player.isChangingDimension() && d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) { // Spigot
+                            if (!(org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled || this.player.isChangingDimension()) && d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) { // Spigot // Lumina - Porting Carpet's features - disable anticheat
                                 // Paper start - Add fail move event
                                 io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_WRONGLY,
                                     toX, toY, toZ, toYaw, toPitch, true);
@@ -1973,7 +1979,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 this.player.gameMode.capturedBlockEntity = false;
                 this.player.gameMode.captureSentBlockEntities = true;
                 // Paper end - Send block entities after destroy prediction
+                        if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().interactionUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(true); // Lumina - Porting Carpet's features - interaction updates
                     this.player.gameMode.handleBlockBreakAction(blockposition, packetplayinblockdig_enumplayerdigtype, packet.getDirection(), this.player.level().getMaxY(), packet.getSequence());
+                    if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().interactionUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(false); // Lumina - Porting Carpet's features - interaction updates
                     this.player.connection.ackBlockChangesUpTo(packet.getSequence());
                 // Paper start - Send block entities after destroy prediction
                 this.player.gameMode.captureSentBlockEntities = false;
@@ -2062,7 +2070,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                         if (blockposition.getY() <= i) {
                         if (this.awaitingPositionFromClient == null && (worldserver.mayInteract(this.player, blockposition) || (worldserver.paperConfig().spawn.allowUsingSignsInsideSpawnProtection && worldserver.getBlockState(blockposition).getBlock() instanceof net.minecraft.world.level.block.SignBlock))) { // Paper - Allow using signs inside spawn protection
                                 this.player.stopUsingItem(); // CraftBukkit - SPIGOT-4706
-                                InteractionResult enuminteractionresult = this.player.gameMode.useItemOn(this.player, worldserver, itemstack, enumhand, movingobjectpositionblock);
+                            if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().interactionUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(true); // Lumina - Porting Carpet's features - interaction updates
+InteractionResult enuminteractionresult = this.player.gameMode.useItemOn(this.player, worldserver, itemstack, enumhand, movingobjectpositionblock);
+                            if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().interactionUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(false); // Lumina - Porting Carpet's features - interaction updates
 
                                 if (enuminteractionresult.consumesAction()) {
                                     CriteriaTriggers.ANY_BLOCK_USE.trigger(this.player, movingobjectpositionblock.getBlockPos(), itemstack.copy());
@@ -2158,7 +2168,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     return;
                 }
                 // CraftBukkit end
+                if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().interactionUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(true); // Lumina - Porting Carpet's features - interaction updates
                 InteractionResult enuminteractionresult = this.player.gameMode.useItem(this.player, worldserver, itemstack, enumhand);
+                if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().interactionUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(false); // Lumina - Porting Carpet's features - interaction updates
 
                 if (enuminteractionresult instanceof InteractionResult.Success) {
                     InteractionResult.Success enuminteractionresult_d = (InteractionResult.Success) enuminteractionresult;
@@ -2210,6 +2222,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void onDisconnect(DisconnectionDetails info, @Nullable net.kyori.adventure.text.Component quitMessage) {
         // Paper end - Fix kick event leave message not being sent
+        org.leavesmc.lumina.carpet.CarpetServer.onPlayerLoggedOut(this.player, quitMessage); // Lumina - Porting Carpet's features - call onPlayerLoggedOut
         // CraftBukkit start - Rarely it would send a disconnect line twice
         if (this.processedDisconnect) {
             return;
@@ -3602,7 +3615,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             }
 
             boolean flag1 = packet.slotNum() >= 1 && packet.slotNum() <= 45;
-            boolean flag2 = itemstack.isEmpty() || itemstack.getCount() <= itemstack.getMaxStackSize();
+            boolean flag2 = itemstack.isEmpty() || itemstack.getCount() <= org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack); // Leaves - stackable shulker boxes
             if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.slotNum()).getItem(), packet.itemStack()))) { // Insist on valid slot
                 // CraftBukkit start - Call click event
                 InventoryView inventory = this.player.inventoryMenu.getBukkitView();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 446c3b1174bcd652a60ae16487826a2391efbad9..8273b710e83dcf29763ffd83a04bee56f93bfa50 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -524,6 +524,7 @@ public abstract class PlayerList {
             );
         }
         // Paper end - Send empty chunk
+        org.leavesmc.lumina.carpet.CarpetServer.onPlayerLoggedIn(player); // Lumina - Porting Carpet's features
     }
 
     public void updateEntireScoreboard(ServerScoreboard scoreboard, ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/world/Container.java b/src/main/java/net/minecraft/world/Container.java
index 5db5ba026462ca642dcee718af732f80fadabef5..bca47bc78a444011b7e549aba949fea799e50c99 100644
--- a/src/main/java/net/minecraft/world/Container.java
+++ b/src/main/java/net/minecraft/world/Container.java
@@ -35,6 +35,12 @@ public interface Container extends Clearable {
         return Math.min(this.getMaxStackSize(), stack.getMaxStackSize());
     }
 
+    // Leaves start - stackable shulker boxes
+    default int getMaxStackLeaves(ItemStack stack) {
+        return Math.min(this.getMaxStackSize(), org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack));
+    }
+    // Leaves end - stackable shulker boxes
+
     void setChanged();
 
     boolean stillValid(Player player);
diff --git a/src/main/java/net/minecraft/world/SimpleContainer.java b/src/main/java/net/minecraft/world/SimpleContainer.java
index 7ed52b887c4d766c23220a8809914d5d80f12ea4..8f8ae3f27be586de1413013db3ffca254f93f4eb 100644
--- a/src/main/java/net/minecraft/world/SimpleContainer.java
+++ b/src/main/java/net/minecraft/world/SimpleContainer.java
@@ -222,7 +222,7 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
     @Override
     public void setItem(int slot, ItemStack stack) {
         this.items.set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack));
         this.setChanged();
     }
 
@@ -318,7 +318,7 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
     }
 
     private void moveItemsBetweenStacks(ItemStack source, ItemStack target) {
-        int i = this.getMaxStackSize(target);
+        int i = this.getMaxStackLeaves(target); // Leaves - stackable shulker boxes
         int j = Math.min(source.getCount(), i - target.getCount());
 
         if (j > 0) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 52b8ec3fc7bc18d3f4b3f74db8e8d3165f737ddd..1998d2133d68e9aaa2881688e765bfe0157a39b6 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -185,6 +185,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
     }
 
+    // Lumina start - Porting Carpet's features
+    public float getMainYaw(float partialTicks) {
+        return partialTicks == 1.0F ? this.yRot : Mth.lerp(partialTicks, this.yRotO, this.yRot);
+    }
+    // Lumina end - Porting Carpet's features
+
     // Paper start - Share random for entities to make them more random
     public static RandomSource SHARED_RANDOM = io.papermc.paper.threadedregions.util.ThreadLocalRandomSource.INSTANCE; // Folia - region threading
     // Paper start - replace random
@@ -269,7 +275,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     protected int boardingCooldown;
     @Nullable
     private Entity vehicle;
-    private Level level;
+    public Level level; // Lumina - private -> public
     public double xo;
     public double yo;
     public double zo;
@@ -5529,6 +5535,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public boolean isControlledByLocalInstance() {
+        if (getControllingPassenger() instanceof org.leavesmc.leaves.bot.ServerBot) return !level.isClientSide; // Lumina - fakeplayer
         net.minecraft.world.entity.LivingEntity entityliving = this.getControllingPassenger();
 
         if (entityliving instanceof Player entityhuman) {
diff --git a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
index 23b47d90fd35659d9eaa661e808a7f89b29614cf..ce01ad03b00f4bdb5a80a1070259ed1d98e6017e 100644
--- a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
+++ b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
@@ -334,6 +334,19 @@ public class ExperienceOrb extends Entity {
     @Override
     public void playerTouch(Player player) {
         if (player instanceof ServerPlayer entityplayer) {
+            // Lumina start - Porting Carpet's features - xp no cooldown
+            if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().xpNoCooldown && !level().isClientSide) {
+                player.takeXpDelay = 0;
+                // reducing the count to 1 and leaving vanilla to deal with it
+                while (this.count > 1) {
+                    int remainder = this.repairPlayerItems(entityplayer, this.value);
+                    if (remainder > 0) {
+                        player.giveExperiencePoints(remainder);
+                    }
+                    this.count--;
+                }
+            }
+            // Lumina end - Porting Carpet's features - xp no cooldown
             if (player.takeXpDelay == 0 && new com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent(entityplayer.getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) this.getBukkitEntity()).callEvent()) { // Paper - PlayerPickupExperienceEvent
                 player.takeXpDelay = CraftEventFactory.callPlayerXpCooldownEvent(player, 2, PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entityhuman.takeXpDelay = 2;
                 player.take(this, 1);
diff --git a/src/main/java/net/minecraft/world/entity/MobCategory.java b/src/main/java/net/minecraft/world/entity/MobCategory.java
index c9482fc669cb7326d4a22467e6fcb5e6b4747e9d..510017d57f4f6fecf85212994400022f06a1bf5d 100644
--- a/src/main/java/net/minecraft/world/entity/MobCategory.java
+++ b/src/main/java/net/minecraft/world/entity/MobCategory.java
@@ -39,7 +39,7 @@ public enum MobCategory implements StringRepresentable {
     }
 
     public int getMaxInstancesPerChunk() {
-        return this.max;
+        return ((int) ((double)max*(Math.pow(2.0,(org.leavesmc.lumina.carpet.utils.SpawnReporter.mobcap_exponent/4))))); // Lumina - Porting Carpet's features - mob spawn
     }
 
     public boolean isFriendly() {
diff --git a/src/main/java/net/minecraft/world/entity/SpawnPlacements.java b/src/main/java/net/minecraft/world/entity/SpawnPlacements.java
index 3f1b8edca02737a607b7720bc574ae55ccf8438b..6c5bbb435add8f19b2fc93f436f4755b7acb384a 100644
--- a/src/main/java/net/minecraft/world/entity/SpawnPlacements.java
+++ b/src/main/java/net/minecraft/world/entity/SpawnPlacements.java
@@ -57,6 +57,11 @@ public class SpawnPlacements {
     }
 
     public static SpawnPlacementType getPlacementType(EntityType<?> type) {
+        // Lumina start - Porting Carpet's features - piglins spawning in bastions
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().piglinsSpawningInBastions && type == EntityType.PIGLIN_BRUTE) {
+             return SpawnPlacementTypes.ON_GROUND;
+        }
+        // Lumina end - Porting Carpet's features - piglins spawning in bastions
         SpawnPlacements.Data data = DATA_BY_TYPE.get(type);
         return data == null ? SpawnPlacementTypes.NO_RESTRICTIONS : data.placement;
     }
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index 71885b8b3f491fbe644efef02aebdd8b9f03a10b..99ced1b033b8dd5a5d687af0c4ecebe29d9cca23 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -130,7 +130,17 @@ public abstract class PathNavigation {
     }
     @Nullable
     public Path createPath(BlockPos target, @Nullable Entity entity, int distance) {
-        return this.createPath(ImmutableSet.of(target), entity, 8, false, distance);
+        // Lumina start - Porting Carpet's features - log pathfinding
+        if (!org.leavesmc.lumina.carpet.logging.LoggerRegistry.__pathfinding)
+            return this.createPath(ImmutableSet.of(target), entity, 8, false, distance);
+        Set<BlockPos> set_1 = ImmutableSet.of(target);
+        long start = System.nanoTime();
+        Path path = createPath(set_1, entity, 8, false, distance);
+        long finish = System.nanoTime();
+        float duration = (1.0F*((finish - start)/1000))/1000;
+        set_1.forEach(b -> org.leavesmc.lumina.carpet.logging.logHelpers.PathfindingVisualizer.slowPath(mob, Vec3.atBottomCenterOf(b), duration, path != null)); // ground centered position
+        return path;
+        // Lumina end - Porting Carpet's features - log pathfinding
         // Paper end - EntityPathfindEvent
     }
 
@@ -141,7 +151,17 @@ public abstract class PathNavigation {
 
     @Nullable
     public Path createPath(Entity entity, int distance) {
-        return this.createPath(ImmutableSet.of(entity.blockPosition()), entity, 16, true, distance); // Paper - EntityPathfindEvent
+        // Lumina start - Porting Carpet's features - log pathfinding
+        if (!org.leavesmc.lumina.carpet.logging.LoggerRegistry.__pathfinding)
+            return this.createPath(ImmutableSet.of(entity.blockPosition()), entity, 16, true, distance); // Paper - EntityPathfindEvent
+        Set<BlockPos> set_1 = ImmutableSet.of(entity.blockPosition());
+        long start = System.nanoTime();
+        Path path = createPath(set_1, entity, 16, true, distance);
+        long finish = System.nanoTime();
+        float duration = (1.0F*((finish - start)/1000))/1000;
+        set_1.forEach(b -> org.leavesmc.lumina.carpet.logging.logHelpers.PathfindingVisualizer.slowPath(mob, Vec3.atBottomCenterOf(b), duration, path != null));
+        return path;
+        // Lumina end - Porting Carpet's features - log pathfinding
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 2ce65ef77e4b28e1fd5ac7bd6a304cc115b8aca2..d89c3578f505499786b65c56f0c31e1d976bd9b0 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -471,7 +471,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     }
 
     private void performRangedAttack(int headIndex, LivingEntity target) {
-        this.performRangedAttack(headIndex, target.getX(), target.getY() + (double) target.getEyeHeight() * 0.5D, target.getZ(), headIndex == 0 && this.random.nextFloat() < 0.001F);
+        this.performRangedAttack(headIndex, target.getX(), target.getY() + (double) target.getEyeHeight() * 0.5D, target.getZ(), headIndex == 0 && ((org.leavesmc.lumina.carpet.CarpetConfig.configModule().moreBlueSkulls) ? random.nextFloat()/100 : this.random.nextFloat()) < 0.001F); // Lumina - Porting Carpet's features - more blue skulls
     }
 
     private void performRangedAttack(int headIndex, double targetX, double targetY, double targetZ, boolean charged) {
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index a498cdbe42df3161c35b2a1652dfa63693366bd6..3231c36b07d72437ada261596f15e11bcd9c30e2 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -58,7 +58,7 @@ import org.bukkit.event.entity.EntityRemoveEvent;
 // CraftBukkit end
 
 public class FallingBlockEntity extends Entity {
-
+    private org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper logHelper; // Lumina - Porting Carpet's features
     private static final Logger LOGGER = LogUtils.getLogger();
     public BlockState blockState;
     public int time;
@@ -78,6 +78,10 @@ public class FallingBlockEntity extends Entity {
         this.blockState = Blocks.SAND.defaultBlockState();
         this.dropItem = true;
         this.fallDamageMax = 40;
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__fallingBlocks && !world.isClientSide)
+            logHelper = new org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper("fallingBlocks");
+        // Lumina end - Porting Carpet's features
     }
 
     public FallingBlockEntity(Level world, double x, double y, double z, BlockState block) {
@@ -149,8 +153,20 @@ public class FallingBlockEntity extends Entity {
         return 0.04D;
     }
 
+    // Lumina start - Porting Carpet's features
+    public void remove(Entity.RemovalReason arg) {
+        super.remove(arg);
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__fallingBlocks && logHelper != null)
+            logHelper.onFinish();
+    }
+    // Lumina end - Porting Carpet's features
+
     @Override
     public void tick() {
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__fallingBlocks && logHelper != null)
+            logHelper.onTick(getX(), getY(), getZ(), getDeltaMovement());
+        // Lumina end - Porting Carpet's features
         if (this.blockState.isAir()) {
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index c81360b6cba1904ccd325c17da76d3ac223c88b8..b33e0488606202371f662a23140f003a3be5a3d1 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -97,6 +97,22 @@ public class ItemEntity extends Entity implements TraceableEntity {
         this.bobOffs = entity.bobOffs;
     }
 
+    // Lumina start - Porting Carpet's features - lighting kills items
+    public void thunderHit(ServerLevel world, net.minecraft.world.entity.LightningBolt lightning) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().lightningKillsDropsFix) {
+            if (this.age > 8) { //Only kill item if it's older than 8 ticks
+                super.thunderHit(world, lightning);
+            }
+        } else {
+            super.thunderHit(world, lightning);
+        }
+    }
+
+    public int getPickupDelayCM() {
+        return this.pickupDelay;
+    }
+    // Lumina end - Porting Carpet's features - lighting kills items
+
     @Override
     public boolean dampensVibrations() {
         return this.getItem().is(ItemTags.DAMPENS_VIBRATIONS);
diff --git a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
index 09edb09cf6beacc8e7960d5d78fe88647525e257..f54fe29bcc1511b94bcb388438206408ad1ff224 100644
--- a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
@@ -59,10 +59,17 @@ public class PrimedTnt extends Entity implements TraceableEntity {
     public float explosionPower;
     public boolean isIncendiary = false; // CraftBukkit - add field
 
+    // Lumina start - Porting Carpet's features - TNT log helper
+    private org.leavesmc.lumina.carpet.logging.logHelpers.TNTLogHelper logHelper;
+    private boolean mergeBool = false;
+    private int mergedTNT = 1;
+    // Lumina end - Porting Carpet's features - TNT log helper
+
     public PrimedTnt(EntityType<? extends PrimedTnt> type, Level world) {
         super(type, world);
         this.explosionPower = 4.0F;
         this.blocksBuilding = true;
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__tnt && !world.isClientSide) logHelper = new org.leavesmc.lumina.carpet.logging.logHelpers.TNTLogHelper(); // Lumina - Porting Carpet's features - TNT log helper
     }
 
     public PrimedTnt(Level world, double x, double y, double z, @Nullable LivingEntity igniter) {
@@ -76,6 +83,8 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         this.yo = y;
         this.zo = z;
         this.owner = igniter;
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().hardcodeTNTangle != -1.0D) setDeltaMovement(-Math.sin(org.leavesmc.lumina.carpet.CarpetConfig.configModule().hardcodeTNTangle) * 0.02, 0.2, -Math.cos(org.leavesmc.lumina.carpet.CarpetConfig.configModule().hardcodeTNTangle) * 0.02); // Lumina - Porting Carpet's features - hardcode TNT angle
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().tntPrimerMomentumRemoved) this.setDeltaMovement(new net.minecraft.world.phys.Vec3(0.0, 0.20000000298023224D, 0.0)); // Porting Carpet's features - remove TNT primer momentum
     }
 
     @Override
@@ -99,8 +108,15 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         return 0.04D;
     }
 
+    // Lumina start - Porting Carpet's features - merge TNT
+    public int getMergedTNT() {
+        return mergedTNT;
+    }
+    // Lumina end - Porting Carpet's features - merge TNT
+
     @Override
     public void tick() {
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__tnt && logHelper != null && !logHelper.initialized) logHelper.onPrimed(getX(), getY(), getZ(), getDeltaMovement()); // Lumina - Porting Carpet's features - TNT log helper
         if (this.level().spigotConfig.maxTntTicksPerTick > 0 && ++this.level().getCurrentWorldData().currentPrimedTnt > this.level().spigotConfig.maxTntTicksPerTick) { return; } // Spigot // Folia - region threading
         //this.handlePortal(); // Folia - region threading
         this.applyGravity();
@@ -114,11 +130,37 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         // Paper end - Configurable TNT height nerf
         this.setDeltaMovement(this.getDeltaMovement().scale(0.98D));
         if (this.onGround()) {
+            // Lumina start - Porting Carpet's features - merge TNT
+            if(org.leavesmc.lumina.carpet.CarpetConfig.configModule().mergeTNT){
+                net.minecraft.world.phys.Vec3 velocity = getDeltaMovement();
+                if(!level().isClientSide && mergeBool && velocity.x == 0 && velocity.y == 0 && velocity.z == 0){
+                    mergeBool = false;
+                    for(Entity entity : level().getEntities(this, this.getBoundingBox())){
+                        if(entity instanceof PrimedTnt && !entity.isRemoved()){
+                            PrimedTnt entityTNTPrimed = (PrimedTnt)entity;
+                            net.minecraft.world.phys.Vec3 tntVelocity = entityTNTPrimed.getDeltaMovement();
+                            if(tntVelocity.x == 0 && tntVelocity.y == 0 && tntVelocity.z == 0
+                                    && this.getX() == entityTNTPrimed.getX() && this.getZ() == entityTNTPrimed.getZ() && this.getY() == entityTNTPrimed.getY()
+                                    && getFuse() == entityTNTPrimed.getFuse()){
+                                mergedTNT += entityTNTPrimed.getMergedTNT();
+                                entityTNTPrimed.discard(); // discard remove();
+                            }
+                        }
+                    }
+                }
+            }
+            // Lumina end - Porting Carpet's features - merge TNT
             this.setDeltaMovement(this.getDeltaMovement().multiply(0.7D, -0.5D, 0.7D));
         }
 
         int i = this.getFuse() - 1;
 
+        // Lumina start - Porting Carpet's features - merge TNT
+        net.minecraft.world.phys.Vec3 velocity = getDeltaMovement();
+        if(!level().isClientSide && (velocity.y != 0 || velocity.x != 0 || velocity.z != 0)){
+            mergeBool = true;
+        }
+        // Lumina end - Porting Carpet's features - merge TNT
         this.setFuse(i);
         if (i <= 0) {
             // CraftBukkit start - Need to reverse the order of the explosion and the entity death so we have a location for the event
@@ -159,6 +201,19 @@ public class PrimedTnt extends Entity implements TraceableEntity {
     }
 
     private void explode() {
+        // Lumina start - Porting Carpet's features - merge tnt
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__tnt && logHelper != null)
+            logHelper.onExploded(getX(), getY(), getZ(), this.level().getGameTime());
+
+        if (mergedTNT > 1)
+            for (int i = 0; i < mergedTNT - 1; i++) {
+                ExplosionPrimeEvent event = CraftEventFactory.callExplosionPrimeEvent((org.bukkit.entity.Explosive) this.getBukkitEntity());
+                if (!event.isCancelled())
+                    this.level().explode(this, this.getX(), this.getY() + (double)(this.getBbHeight() / 16.0F),
+                        this.getZ(),
+                        4.0F,
+                        Level.ExplosionInteraction.TNT);
+            }
         // CraftBukkit start
         ExplosionPrimeEvent event = CraftEventFactory.callExplosionPrimeEvent((org.bukkit.entity.Explosive) this.getBukkitEntity());
         if (event.isCancelled()) {
@@ -166,6 +221,7 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         }
         this.level().explode(this, Explosion.getDefaultDamageSource(this.level(), this), this.usedPortal ? PrimedTnt.USED_PORTAL_DAMAGE_CALCULATOR : null, this.getX(), this.getY(0.0625D), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.TNT);
         // CraftBukkit end
+        // Lumina end - Porting Carpet's features - merge tnt
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/monster/Guardian.java b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
index 951f46684623582980901c1ebc1870aa5bcf25a1..83d47d0a93fde3a6170aa08e1c1a082c4f4f9e2c 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Guardian.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
@@ -71,6 +71,28 @@ public class Guardian extends Monster {
         this.clientSideTailAnimationO = this.clientSideTailAnimation;
     }
 
+    // Lumina start - Porting Carpet's features reneweable sponges
+    public void thunderHit(net.minecraft.server.level.ServerLevel serverWorld, net.minecraft.world.entity.LightningBolt lightningEntity) {
+        if (!this.level().isClientSide && !this.isRemoved() && org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableSponges && !((Object)this instanceof ElderGuardian)) {
+            ElderGuardian elderGuardian = new ElderGuardian(EntityType.ELDER_GUARDIAN ,this.level());
+            elderGuardian.moveTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
+            elderGuardian.finalizeSpawn(serverWorld ,this.level().getCurrentDifficultyAt(elderGuardian.blockPosition()), EntitySpawnReason.CONVERSION, null);
+            elderGuardian.setNoAi(this.isNoAi());
+
+            if (this.hasCustomName()) {
+                elderGuardian.setCustomName(this.getCustomName());
+                elderGuardian.setCustomNameVisible(this.isCustomNameVisible());
+            }
+
+            this.level().addFreshEntity(elderGuardian);
+            this.discard(); // discard remove();
+        }
+        else {
+            super.thunderHit(serverWorld, lightningEntity);
+        }
+    }
+    // Lumina end - Porting Carpet's features reneweable sponges
+
     @Override
     protected void registerGoals() {
         MoveTowardsRestrictionGoal pathfindergoalmovetowardsrestriction = new MoveTowardsRestrictionGoal(this, 1.0D);
diff --git a/src/main/java/net/minecraft/world/entity/monster/Husk.java b/src/main/java/net/minecraft/world/entity/monster/Husk.java
index 184fa759db065fb345f3623752229430816d8ad3..afa8e8e823962fe7cb5895133a9ce16746953e86 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Husk.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Husk.java
@@ -24,7 +24,7 @@ public class Husk extends Zombie {
     }
 
     public static boolean checkHuskSpawnRules(EntityType<Husk> type, ServerLevelAccessor world, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random) {
-        return checkMonsterSpawnRules(type, world, spawnReason, pos, random) && (EntitySpawnReason.isSpawner(spawnReason) || world.canSeeSky(pos));
+        return checkMonsterSpawnRules(type, world, spawnReason, pos, random) && (EntitySpawnReason.isSpawner(spawnReason) || world.canSeeSky(pos) || (org.leavesmc.lumina.carpet.CarpetConfig.configModule().huskSpawningInTemples && org.leavesmc.lumina.carpet.utils.SpawnOverrides.isStructureAtPosition((net.minecraft.server.level.ServerLevel)world, net.minecraft.world.level.levelgen.structure.BuiltinStructures.DESERT_PYRAMID, pos))); // Lumina - Porting Carpet's features - husks spawning in desert temples
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/npc/Villager.java b/src/main/java/net/minecraft/world/entity/npc/Villager.java
index 07f50048e9748b28178847ad470b8b2ce37e0eea..6910d0791953233f962391ed6bffcf66538b8da3 100644
--- a/src/main/java/net/minecraft/world/entity/npc/Villager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/Villager.java
@@ -19,6 +19,7 @@ import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.core.Holder;
+import net.minecraft.core.particles.BlockParticleOption;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.nbt.CompoundTag;
@@ -90,6 +91,7 @@ import net.minecraft.world.item.trading.MerchantOffer;
 import net.minecraft.world.item.trading.MerchantOffers;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.ServerLevelAccessor;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.phys.AABB;
 import org.slf4j.Logger;
 
@@ -141,6 +143,11 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }, MemoryModuleType.MEETING_POINT, (entityvillager, holder) -> {
         return holder.is(PoiTypes.MEETING);
     });
+    // Lumina start - Porting Carpet's features - villager ai tracking
+    int totalFood;
+    boolean hasBed;
+    int displayAge;
+    // Lumina end - Porting Carpet's features - villager ai tracking
 
     public Villager(EntityType<? extends Villager> entityType, Level world) {
         this(entityType, world, VillagerType.PLAINS);
@@ -297,6 +304,51 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     @Override
     public void tick() {
+        // Lumina start - Porting Carpet's features - villager ai tracking
+        if (org.leavesmc.lumina.carpet.utils.MobAI.isTracking(this, org.leavesmc.lumina.carpet.utils.MobAI.TrackingType.IRON_GOLEM_SPAWNING)) {
+            long time;
+            Optional<? extends net.minecraft.world.entity.ai.memory.ExpirableValue<?>> last_seen = this.brain.getMemories().get(MemoryModuleType.GOLEM_DETECTED_RECENTLY);
+            if (!last_seen.isPresent()) {
+                time = 0;
+            } else {
+                time = last_seen.get().getTimeToLive();
+            }
+            boolean recentlySeen = time > 0;
+            Optional<Long> optional_11 = this.brain.getMemory(MemoryModuleType.LAST_SLEPT);
+            //Optional<Timestamp> optional_22 = this.brain.getOptionalMemory(MemoryModuleType.LAST_WORKED_AT_POI);
+            //boolean work = false;
+            boolean sleep = false;
+            boolean panic = this.brain.isActive(Activity.PANIC);
+            long currentTime = this.level().getGameTime();
+            if (optional_11.isPresent()) {
+                sleep = (currentTime - optional_11.get()) < 24000L;
+            }
+            //if (optional_22.isPresent()) {
+            //    work = (currentTime - optional_22.get().getTime()) < 36000L;
+            //}
+
+            this.setCustomName(org.leavesmc.lumina.carpet.utils.Messenger.c(
+                    (sleep?"eb ":"fb ")+"\u263d ",
+                    //(work?"eb ":"fb ")+"\u2692 ",//"\u26CF ",
+                    (panic?"lb ":"fb ")+"\u2623 ",//"\u2622 \u2620 \u26A1 ",
+                    (recentlySeen?"rb ":"lb ")+time ));
+            this.setCustomNameVisible(true);
+        } else if (org.leavesmc.lumina.carpet.utils.MobAI.isTracking(this, org.leavesmc.lumina.carpet.utils.MobAI.TrackingType.BREEDING)) {
+            if (tickCount % 50 == 0 || tickCount < 20) {
+                totalFood = countFoodPointsInInventory() / 12;
+                hasBed = this.brain.getMemory(MemoryModuleType.HOME).isPresent();
+                displayAge = getAge();
+            }
+            if (Math.abs(displayAge) < 100 && displayAge !=0) displayAge = getAge();
+
+            this.setCustomName(org.leavesmc.lumina.carpet.utils.Messenger.c(
+                    (hasBed?"eb ":"fb ")+"\u2616 ",//"\u263d ",
+                    (totalFood>0?"eb ":"fb ")+"\u2668",(totalFood>0?"e ":"f ")+totalFood+" ",
+                    (displayAge==0?"eb ":"fb ")+"\u2661",(displayAge==0?"e ":"f "+displayAge)
+            ));
+            this.setCustomNameVisible(true);
+        }
+        // Lumina end - Porting Carpet's features - villager ai tracking
         super.tick();
         if (this.getUnhappyCounter() > 0) {
             this.setUnhappyCounter(this.getUnhappyCounter() - 1);
@@ -307,6 +359,34 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
+        // Lumina start - Porting Carpet's features - villager ai tracking
+        if (org.leavesmc.lumina.carpet.utils.MobAI.isTracking(this, org.leavesmc.lumina.carpet.utils.MobAI.TrackingType.BREEDING)) {
+            ItemStack itemStack_1 = player.getItemInHand(hand);
+            if (itemStack_1.getItem() == Items.EMERALD) {
+                GlobalPos bedPos = this.brain.getMemory(MemoryModuleType.HOME).orElse(null);
+                if (bedPos == null || bedPos.dimension() != level().dimension()) { // get Dimension
+                     setUnhappy();
+                     ((ServerLevel) getCommandSenderWorld()).sendParticles(new net.minecraft.core.particles.BlockParticleOption(ParticleTypes.BLOCK_MARKER, net.minecraft.world.level.block.Blocks.BARRIER.defaultBlockState()), getX(), getY() + getEyeHeight() + 1, getZ(), 1, 0.1, 0.1, 0.1, 0.0);
+                } else {
+                    org.leavesmc.lumina.carpet.helpers.ParticleDisplay.drawParticleLine((net.minecraft.server.level.ServerPlayer) player, position(), net.minecraft.world.phys.Vec3.atCenterOf(bedPos.pos()), "dust 0 0 0 1", "happy_villager", 100, 0.2); // pos+0.5v
+                }
+            } else if (itemStack_1.getItem() == Items.ROTTEN_FLESH) {
+                while(countFoodPointsInInventory() >= 12) eatAndDigestFood();
+            } else if (itemStack_1.getItem() instanceof net.minecraft.world.item.BedItem) {
+                List<net.minecraft.world.entity.ai.village.poi.PoiRecord> list_1 = ((ServerLevel) getCommandSenderWorld()).getPoiManager().getInRange(type -> type.is(PoiTypes.HOME), blockPosition(), 48, PoiManager.Occupancy.ANY).toList();
+                for (net.minecraft.world.entity.ai.village.poi.PoiRecord poi : list_1) {
+                    net.minecraft.world.phys.Vec3 pv = net.minecraft.world.phys.Vec3.atCenterOf(poi.getPos());
+                    if (!poi.hasSpace()) {
+                        ((ServerLevel) getCommandSenderWorld()).sendParticles(ParticleTypes.HAPPY_VILLAGER,
+                                pv.x, pv.y+1.5, pv.z,
+                                50, 0.1, 0.3, 0.1, 0.0);
+                    } else if (canReachHome((Villager)(Object)this, poi.getPos(), poi)) ((ServerLevel) getCommandSenderWorld()).sendParticles(ParticleTypes.END_ROD, pv.x, pv.y+1, pv.z, 50, 0.1, 0.3, 0.1, 0.0);
+                    else ((ServerLevel) getCommandSenderWorld()).sendParticles(new net.minecraft.core.particles.BlockParticleOption(ParticleTypes.BLOCK_MARKER, net.minecraft.world.level.block.Blocks.BARRIER.defaultBlockState()), pv.x, pv.y+1, pv.z, 1, 0.1, 0.1, 0.1, 0.0);
+                }
+            }
+            return InteractionResult.FAIL;
+        }
+        // Lumina end - Porting Carpet's features - villager ai tracking
         ItemStack itemstack = player.getItemInHand(hand);
 
         if (!itemstack.is(Items.VILLAGER_SPAWN_EGG) && this.isAlive() && !this.isTrading() && !this.isSleeping()) {
@@ -339,6 +419,13 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         }
     }
 
+    // Lumina start - Porting Carpet's features - villager ai tracking
+    private boolean canReachHome(Villager villager, BlockPos pos, net.minecraft.world.entity.ai.village.poi.PoiRecord poi) {
+        net.minecraft.world.level.pathfinder.Path path = villager.getNavigation().createPath(pos, poi.getPoiType().value().validRange());
+        return path != null && path.canReach();
+    }
+    // Lumina end - Porting Carpet's features - villager ai tracking
+
     public void setUnhappy() {
         this.setUnhappyCounter(40);
         if (!this.level().isClientSide()) {
@@ -967,6 +1054,11 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     public void spawnGolemIfNeeded(ServerLevel world, long time, int requiredCount) {
         if (this.wantsToSpawnGolem(time)) {
             AABB axisalignedbb = this.getBoundingBox().inflate(10.0D, 10.0D, 10.0D);
+            // Lumina start - Porting Carpet's features - villager ai tracking
+            if (org.leavesmc.lumina.carpet.utils.MobAI.isTracking(this, org.leavesmc.lumina.carpet.utils.MobAI.TrackingType.IRON_GOLEM_SPAWNING)) {
+                ((ServerLevel) getCommandSenderWorld()).sendParticles(new BlockParticleOption(ParticleTypes.BLOCK_MARKER, Blocks.BARRIER.defaultBlockState()), getX(), getY()+3, getZ(), 1, 0.1, 0.1, 0.1, 0.0);
+            }
+            // Lumina end - Porting Carpet's features - villager ai tracking
             List<Villager> list = world.getEntitiesOfClass(Villager.class, axisalignedbb);
             List<Villager> list1 = list.stream().filter((entityvillager) -> {
                 return entityvillager.wantsToSpawnGolem(time);
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index 110456deaa662bc1c0f6ba7878bb3074869a4350..230c321185d2fb38f3433c5a0edd7c4ec27be5d9 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -110,7 +110,7 @@ public class Inventory implements Container, Nameable {
     }
 
     private boolean hasRemainingSpaceForItem(ItemStack existingStack, ItemStack stack) {
-        return !existingStack.isEmpty() && existingStack.isStackable() && existingStack.getCount() < this.getMaxStackSize(existingStack) && ItemStack.isSameItemSameComponents(existingStack, stack); // Paper - check if itemstack is stackable first
+        return !existingStack.isEmpty() && org.leavesmc.leaves.util.ShulkerBoxUtils.isStackable(existingStack) && existingStack.getCount() < org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(existingStack) && ItemStack.isSameItemSameComponents(existingStack, stack); // Paper - check if itemstack is stackable first
     }
 
     // CraftBukkit start - Watch method above! :D
@@ -260,7 +260,9 @@ public class Inventory implements Container, Nameable {
             this.setItem(slot, itemstack1);
         }
 
-        int k = this.getMaxStackSize(itemstack1) - itemstack1.getCount();
+        // Leaves start - stackable shulker boxes
+        int k = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1) - itemstack1.getCount();
+        // Leaves end - stackable shulker boxes
         int l = Math.min(j, k);
 
         if (l == 0) {
@@ -375,7 +377,7 @@ public class Inventory implements Container, Nameable {
                 }
 
                 if (i != -1) {
-                    int j = stack.getMaxStackSize() - this.getItem(i).getCount();
+                    int j = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(stack) - this.getItem(i).getCount(); // Leaves - stackable shulker boxes
 
                     if (!this.add(i, stack.split(j)) || !notifiesClient) {
                         continue;
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index f2817f1c29431ef2c4a45dc9ef90f06d4982f7c9..f0a500ee9134178dc7880c876afdbbb18d8c33c6 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -255,8 +255,8 @@ public abstract class Player extends LivingEntity {
 
     @Override
     public void tick() {
-        this.noPhysics = this.isSpectator();
-        if (this.isSpectator() || this.isPassenger()) {
+        this.noPhysics = this.isCreativeFlyOrSpectator(); // Lumina - creative no clip
+        if (this.isCreativeFlyOrSpectator() || this.isPassenger()) { // Lumina - creative no clip
             this.setOnGround(false);
         }
 
@@ -473,7 +473,7 @@ public abstract class Player extends LivingEntity {
 
             Pose entitypose1;
 
-            if (!this.isSpectator() && !this.isPassenger() && !this.canPlayerFitWithinBlocksAndEntitiesWhen(entitypose)) {
+            if (!this.isCreativeFlyOrSpectator() && !this.isPassenger() && !this.canPlayerFitWithinBlocksAndEntitiesWhen(entitypose)) { // Lumina - creative no clip
                 if (this.canPlayerFitWithinBlocksAndEntitiesWhen(Pose.CROUCHING)) {
                     entitypose1 = Pose.CROUCHING;
                 } else {
@@ -609,7 +609,7 @@ public abstract class Player extends LivingEntity {
         }
 
         this.bob += (f - this.bob) * 0.4F;
-        if (this.getHealth() > 0.0F && !this.isSpectator()) {
+        if (this.getHealth() > 0.0F && !this.isCreativeFlyOrSpectator()) { // Lumina - creative no clip
             AABB axisalignedbb;
 
             if (this.isPassenger() && !this.getVehicle().isRemoved()) {
@@ -626,7 +626,11 @@ public abstract class Player extends LivingEntity {
                 Entity entity = (Entity) iterator.next();
 
                 if (entity.getType() == EntityType.EXPERIENCE_ORB) {
-                    list1.add(entity);
+                    // Lumina start - Porting Carpet's features
+                    if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().xpNoCooldown) {
+                        this.touch(entity);
+                    } else list1.add(entity);
+                    // Lumina end - Porting Carpet's features
                 } else if (!entity.isRemoved()) {
                     this.touch(entity);
                 }
@@ -640,7 +644,7 @@ public abstract class Player extends LivingEntity {
         this.playShoulderEntityAmbientSound(this.getShoulderEntityLeft());
         this.playShoulderEntityAmbientSound(this.getShoulderEntityRight());
         if (!this.level().isClientSide && (this.fallDistance > 0.5F || this.isInWater()) || this.abilities.flying || this.isSleeping() || this.isInPowderSnow) {
-            if (!this.level().paperConfig().entities.behavior.parrotsAreUnaffectedByPlayerMovement) // Paper - Add option to make parrots stay
+            if (!this.level().paperConfig().entities.behavior.parrotsAreUnaffectedByPlayerMovement && !org.leavesmc.lumina.carpet.CarpetConfig.configModule().persistentParrots) // Paper - Add option to make parrots stay // Lumina - Porting Carpet's features - persistent parrots
             this.removeEntitiesOnShoulder();
         }
 
@@ -663,6 +667,20 @@ public abstract class Player extends LivingEntity {
         }
 
     }
+    // Leaves start - creative no clip
+    public boolean isCreativeFlyOrSpectator() {
+        return isSpectator() || (org.leavesmc.lumina.carpet.CarpetConfig.configModule().creativeNoClip && isCreative() && getAbilities().flying);
+    }
+
+    public boolean canSpectatingPlace(Level world, BlockState state, BlockPos pos, net.minecraft.world.phys.shapes.CollisionContext context) {
+        if (this.isCreativeFlyOrSpectator()) {
+            net.minecraft.world.phys.shapes.VoxelShape voxelShape = state.getCollisionShape(world, pos, context);
+            return voxelShape.isEmpty() || world.isUnobstructed(this, voxelShape.move(pos.getX(), pos.getY(), pos.getZ()));
+        } else {
+            return world.isUnobstructed(state, pos, context);
+        }
+    }
+    // Leaves end - creative no clip
 
     private void touch(Entity entity) {
         entity.playerTouch(this);
@@ -959,6 +977,16 @@ public abstract class Player extends LivingEntity {
                 // CraftBukkit start - Don't filter out 0 damage
                 boolean damaged = super.hurtServer(world, source, amount);
                 if (damaged) {
+                    // Lumina start - Porting Carpet's features - persistent parrots
+                    if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().persistentParrots && !this.isShiftKeyDown()) {
+                        if (this.random.nextFloat() < ((amount)/15.0) ) {
+                            this.dismount_left();
+                        }
+                        if (this.random.nextFloat() < ((amount)/15.0) ) {
+                            this.dismount_right();
+                        }
+                    }
+                    // Lumina end - Porting Carpet's features - persistent parrots
                     this.removeEntitiesOnShoulder();
                 }
                 return damaged;
@@ -967,6 +995,18 @@ public abstract class Player extends LivingEntity {
         }
     }
 
+    // Lumina start - Porting Carpet's features - persistent parrots
+    protected void dismount_left() {
+        respawnEntityOnShoulder(this.getShoulderEntityLeft());
+        this.setShoulderEntityLeft(new CompoundTag());
+    }
+
+    protected void dismount_right() {
+        respawnEntityOnShoulder(this.getShoulderEntityRight());
+        this.setShoulderEntityRight(new CompoundTag());
+    }
+    // Lumina end - Porting Carpet's features - persistent parrots
+
     @Override
     protected void blockUsingShield(LivingEntity attacker) {
         super.blockUsingShield(attacker);
@@ -1357,6 +1397,7 @@ public abstract class Player extends LivingEntity {
                         }
 
                         if (target instanceof ServerPlayer && target.hurtMarked) {
+                            // && !(target instanceof org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake)) { // Lumina - Porting Carpet's features - fakepalyer // TODO
                             // CraftBukkit start - Add Velocity Event
                             boolean cancelled = false;
                             org.bukkit.entity.Player player = (org.bukkit.entity.Player) target.getBukkitEntity();
@@ -1709,7 +1750,7 @@ public abstract class Player extends LivingEntity {
     }
 
     public boolean tryToStartFallFlying() {
-        if (!this.isFallFlying() && this.canGlide() && !this.isInWater()) {
+        if ((org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled && (Object)this instanceof ServerPlayer sp && sp.getServer().isDedicatedServer()) || (!this.isFallFlying() && this.canGlide() && !this.isInWater())) { // Lumina - Porting Carpet's features - disable anticheat
             this.startFallFlying();
             return true;
         } else {
@@ -2394,12 +2435,22 @@ public abstract class Player extends LivingEntity {
     }
 
     public boolean canInteractWithEntity(AABB box, double additionalRange) {
+        // Lumina start - Porting Carpet's features - disable anticheat
+        double maxRange = entityInteractionRange() + additionalRange;
+        maxRange = maxRange * maxRange;
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled && maxRange < 1024 && box.distanceToSqr(getEyePosition()) < 1024) return true;
+        // Lumina end - Porting Carpet's features - disable anticheat
         double d1 = this.entityInteractionRange() + additionalRange;
 
         return box.distanceToSqr(this.getEyePosition()) < d1 * d1;
     }
 
     public boolean canInteractWithBlock(BlockPos pos, double additionalRange) {
+        // Lumina start - Porting Carpet's features - disable anticheat
+        double maxRange = blockInteractionRange() + additionalRange;
+        maxRange = maxRange * maxRange;
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().antiCheatDisabled && maxRange < 1024 && getEyePosition().distanceToSqr(Vec3.atCenterOf(pos)) < 1024) return true;
+        // Lumina end - Porting Carpet's features - disable anticheat
         double d1 = this.blockInteractionRange() + additionalRange;
 
         return (new AABB(pos)).distanceToSqr(this.getEyePosition()) < d1 * d1;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index 5d52f67b3e379e64d23a0429679c144373d20eac..6d15b859e7c8767df18b9ba4789f509420f43d8a 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -57,7 +57,7 @@ import org.bukkit.event.player.PlayerPickupArrowEvent;
 // CraftBukkit end
 
 public abstract class AbstractArrow extends Projectile {
-
+    private org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper logHelper; // Lumina - Porting Carpet's features
     private static final double ARROW_BASE_DAMAGE = 2.0D;
     private static final int SHAKE_TIME = 7;
     private static final float WATER_INERTIA = 0.6F;
@@ -120,7 +120,11 @@ public abstract class AbstractArrow extends Projectile {
         if (unit != null) {
             this.pickup = AbstractArrow.Pickup.CREATIVE_ONLY;
         }
-
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && !level.isClientSide) {
+            logHelper = new org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper("projectiles");
+        }
+        // Lumina end - Porting Carpet's features
         this.setPos(d0, d1, d2);
         if (itemstack1 != null && world instanceof ServerLevel worldserver) {
             if (itemstack1.isEmpty()) {
@@ -198,6 +202,11 @@ public abstract class AbstractArrow extends Projectile {
 
     @Override
     public void tick() {
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+            logHelper.onTick(getX(), getY(), getZ(), getDeltaMovement());
+        }
+        // Lumina end - Porting Carpet's features
         // Folia start - region threading - make sure entities do not move into regions they do not own
         if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
             return;
@@ -467,6 +476,12 @@ public abstract class AbstractArrow extends Projectile {
 
             if (this.piercingIgnoreEntityIds.size() >= this.getPierceLevel() + 1) {
                 this.discard(EntityRemoveEvent.Cause.HIT); // CraftBukkit - add Bukkit remove cause
+                // Lumina start - Porting Carpet's features
+                if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+                    logHelper.onFinish();
+                    logHelper = null;
+                }
+                // Lumina end - Porting Carpet's features
                 return;
             }
 
@@ -499,6 +514,12 @@ public abstract class AbstractArrow extends Projectile {
 
         if (entity.hurtOrSimulate(damagesource, (float) i)) {
             if (flag) {
+                // Lumina start - Porting Carpet's features
+                if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+                    logHelper.onFinish();
+                    logHelper = null;
+                }
+                // Lumina end - Porting Carpet's features
                 return;
             }
 
@@ -591,7 +612,12 @@ public abstract class AbstractArrow extends Projectile {
                 target.push(vec3d.x, 0.1D, vec3d.z, this); // Paper - Add EntityKnockbackByEntityEvent and EntityPushedByEntityAttackEvent
             }
         }
-
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+            logHelper.onFinish();
+            logHelper = null;
+        }
+        // Lumina end - Porting Carpet's features
     }
 
     @Override
@@ -620,6 +646,12 @@ public abstract class AbstractArrow extends Projectile {
         this.setPierceLevel((byte) 0);
         this.setSoundEvent(SoundEvents.ARROW_HIT);
         this.resetPiercedEntities();
+        // Lumina start - Porting Carpet's features
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null) {
+            logHelper.onFinish();
+            logHelper = null;
+        }
+        // Lumina end - Porting Carpet's features
     }
 
     protected void hitBlockEnchantmentEffects(ServerLevel world, BlockHitResult blockHitResult, ItemStack weaponStack) {
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrowableProjectile.java b/src/main/java/net/minecraft/world/entity/projectile/ThrowableProjectile.java
index ff53dfec183e7933e5ceda8bf5a88b179d8d8532..aa4be9d1efc5470cb749a7f2946728f32a340a39 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrowableProjectile.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrowableProjectile.java
@@ -11,11 +11,14 @@ import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 
 public abstract class ThrowableProjectile extends Projectile {
+    private org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper logHelper; // Lumina - Porting Carpet's features - log trajectory
 
     private static final float MIN_CAMERA_DISTANCE_SQUARED = 12.25F;
 
     protected ThrowableProjectile(EntityType<? extends ThrowableProjectile> type, Level world) {
         super(type, world);
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && !world.isClientSide)
+            logHelper = new org.leavesmc.lumina.carpet.logging.logHelpers.TrajectoryLogHelper("projectiles");
     }
 
     protected ThrowableProjectile(EntityType<? extends ThrowableProjectile> type, double x, double y, double z, Level world) {
@@ -44,8 +47,18 @@ public abstract class ThrowableProjectile extends Projectile {
         return true;
     }
 
+    // Lumina start - Porting Carpet's features
+    public void remove(net.minecraft.world.entity.Entity.RemovalReason arg) {
+        super.remove(arg);
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null)
+            logHelper.onFinish();
+    }
+    // Lumina end - Porting Carpet's features
+
     @Override
     public void tick() {
+        if (org.leavesmc.lumina.carpet.logging.LoggerRegistry.__projectiles && logHelper != null)
+            logHelper.onTick(getX(), getY(), getZ(), getDeltaMovement());
         // Folia start - region threading - make sure entities do not move into regions they do not own
         if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
             return;
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java b/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
index 45f6191cc8e2ecdacbc2df0ddb5ea7cc6a546812..02cfa01c85089c3aeee5288bff56cb4fa842dab6 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
@@ -165,7 +165,7 @@ public interface ContainerEntity extends Container, MenuProvider {
     default void setChestVehicleItem(int slot, ItemStack stack) {
         this.unpackChestVehicleLootTable(null);
         this.getItemStacks().set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
     }
 
     default SlotAccess getChestVehicleSlot(int slot) {
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index 4680f77a275d8d2b226018db89a571ac25998dd8..7d4354dbe752a9b5b39dae22d4d4a29105f538bd 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -436,6 +436,26 @@ public abstract class AbstractContainerMenu {
     }
 
     private void doClick(int slotIndex, int button, ClickType actionType, Player player) {
+        // Lumina start - Porting Carpet's features - ctrlQ crafting fix
+        if (actionType == ClickType.THROW && org.leavesmc.lumina.carpet.CarpetConfig.configModule().ctrlQCraftingFix && this.getCarried().isEmpty() && slotIndex >= 0)
+        {
+            Slot slot_4 = slots.get(slotIndex);
+            if (/*slot_4 != null && */slot_4.hasItem() && slot_4.mayPickup(player))
+            {
+                if(slotIndex == 0 && button == 1)
+                {
+                    net.minecraft.world.item.Item craftedItem = slot_4.getItem().getItem();
+                    while(slot_4.hasItem() && slot_4.getItem().getItem() == craftedItem)
+                    {
+                        this.clicked(slotIndex, 0, ClickType.THROW, player);
+                    }
+                    this.broadcastChanges();
+                    this.resetQuickCraft();
+                    return;
+                }
+            }
+        }
+        // Lumina end - Porting Carpet's features - ctrlQ crafting fix
         Inventory playerinventory = player.getInventory();
         Slot slot;
         ItemStack itemstack;
@@ -491,7 +511,7 @@ public abstract class AbstractContainerMenu {
 
                         if (slot1 != null && AbstractContainerMenu.canItemQuickReplace(slot1, itemstack2, true) && slot1.mayPlace(itemstack2) && (this.quickcraftType == 2 || itemstack2.getCount() >= this.quickcraftSlots.size()) && this.canDragTo(slot1)) {
                             int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
-                            int k1 = Math.min(itemstack1.getMaxStackSize(), slot1.getMaxStackSize(itemstack1));
+                            int k1 = Math.min(org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1), slot1.getMaxStackSize(itemstack1)); // Leaves - stackable shulker boxes                            int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
                             int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
 
                             l -= l1 - j1;
@@ -610,7 +630,7 @@ public abstract class AbstractContainerMenu {
                                     slot.setByPlayer(itemstack3);
                                 }
                             } else if (ItemStack.isSameItemSameComponents(itemstack, itemstack3)) {
-                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), itemstack3.getMaxStackSize() - itemstack3.getCount(), player);
+                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack3) - itemstack3.getCount(), player);
 
                                 optional1.ifPresent((itemstack4) -> {
                                     itemstack3.grow(itemstack4.getCount());
@@ -680,7 +700,7 @@ public abstract class AbstractContainerMenu {
                         slot2 = (Slot) this.slots.get(slotIndex);
                         if (slot2.hasItem()) {
                             itemstack1 = slot2.getItem();
-                            this.setCarried(itemstack1.copyWithCount(itemstack1.getMaxStackSize()));
+                            this.setCarried(itemstack1.copyWithCount(org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1))); // Leaves - stackable shulker boxes
                         }
                     } else if (actionType == ClickType.THROW && this.getCarried().isEmpty() && slotIndex >= 0) {
                         slot2 = (Slot) this.slots.get(slotIndex);
@@ -711,13 +731,13 @@ public abstract class AbstractContainerMenu {
                             j2 = button == 0 ? 1 : -1;
 
                             for (i2 = 0; i2 < 2; ++i2) {
-                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < itemstack1.getMaxStackSize(); k2 += j2) {
+                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); k2 += j2) { // Leaves - stackable shulker boxes
                                     Slot slot3 = (Slot) this.slots.get(k2);
 
                                     if (slot3.hasItem() && AbstractContainerMenu.canItemQuickReplace(slot3, itemstack1, true) && slot3.mayPickup(player) && this.canTakeItemForPickAll(itemstack1, slot3)) {
                                         ItemStack itemstack5 = slot3.getItem();
 
-                                        if (i2 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
+                                        if (i2 != 0 || itemstack5.getCount() != org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack5)) {
                                             ItemStack itemstack6 = slot3.safeTake(itemstack5.getCount(), itemstack1.getMaxStackSize() - itemstack1.getCount(), player);
 
                                             itemstack1.grow(itemstack6.getCount());
@@ -850,7 +870,7 @@ public abstract class AbstractContainerMenu {
         ItemStack itemstack1;
         int l;
 
-        if (stack.isStackable()) {
+        if (org.leavesmc.leaves.util.ShulkerBoxUtils.isStackable(stack)) { // Leaves - stackable shulker boxes
             while (!stack.isEmpty()) {
                 if (fromLast) {
                     if (k < startIndex) {
@@ -869,6 +889,7 @@ public abstract class AbstractContainerMenu {
                 // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (!itemstack1.isEmpty() && ItemStack.isSameItemSameComponents(stack, itemstack1)) {
                     l = itemstack1.getCount() + stack.getCount();
+                    // int i1 = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); // Leaves - stackable shulker boxes // disabled temporarily
                     int i1 = slot.getMaxStackSize(itemstack1);
 
                     if (l <= i1) {
@@ -920,6 +941,7 @@ public abstract class AbstractContainerMenu {
                 }
                 // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (itemstack1.isEmpty() && slot.mayPlace(stack)) {
+                    // l = org.leavesmc.leaves.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); // Leaves - stackable shulker boxes // disabled temporarily
                     l = slot.getMaxStackSize(stack);
                     // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent
                     if (isCheck) {
diff --git a/src/main/java/net/minecraft/world/inventory/MerchantContainer.java b/src/main/java/net/minecraft/world/inventory/MerchantContainer.java
index 9140fab07aab32065f7a3b5d13dd17d61dc6d646..210b88b5d87fad641188cf5907c54824d21163ce 100644
--- a/src/main/java/net/minecraft/world/inventory/MerchantContainer.java
+++ b/src/main/java/net/minecraft/world/inventory/MerchantContainer.java
@@ -130,7 +130,7 @@ public class MerchantContainer implements Container {
     @Override
     public void setItem(int slot, ItemStack stack) {
         this.itemStacks.set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
         if (this.isPaymentSlot(slot)) {
             this.updateSellItem();
         }
diff --git a/src/main/java/net/minecraft/world/item/BlockItem.java b/src/main/java/net/minecraft/world/item/BlockItem.java
index 4377fa2400c4320e0023ece230090a2a3b4b2ab6..2a73da8996e49d3584b6482f4baf22640eb06e0d 100644
--- a/src/main/java/net/minecraft/world/item/BlockItem.java
+++ b/src/main/java/net/minecraft/world/item/BlockItem.java
@@ -182,7 +182,7 @@ public class BlockItem extends Item {
         CollisionContext voxelshapecollision = entityhuman == null ? CollisionContext.empty() : CollisionContext.of(entityhuman);
         // CraftBukkit start - store default return
         Level world = context.getLevel(); // Paper - Cancel hit for vanished players
-        boolean defaultReturn = (!this.mustSurvive() || state.canSurvive(context.getLevel(), context.getClickedPos())) && world.checkEntityCollision(state, entityhuman, voxelshapecollision, context.getClickedPos(), true); // Paper - Cancel hit for vanished players
+        boolean defaultReturn = (!this.mustSurvive() || state.canSurvive(context.getLevel(), context.getClickedPos())) && (org.leavesmc.lumina.carpet.CarpetConfig.configModule().creativeNoClip && context.getPlayer() != null ? context.getPlayer().canSpectatingPlace(world, state, context.getClickedPos(), voxelshapecollision) : world.checkEntityCollision(state, entityhuman, voxelshapecollision, context.getClickedPos(), true)); // Paper - Cancel hit for vanished players // Lumina - creative no clip
         org.bukkit.entity.Player player = (context.getPlayer() instanceof ServerPlayer) ? (org.bukkit.entity.Player) context.getPlayer().getBukkitEntity() : null;
 
         BlockCanBuildEvent event = new BlockCanBuildEvent(CraftBlock.at(context.getLevel(), context.getClickedPos()), player, CraftBlockData.fromData(state), defaultReturn, org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(context.getHand())); // Paper - Expose hand in BlockCanBuildEvent
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index b4bf2069e78cb1408593ed41575ee747651e33c8..84cc401f6c71216d2997eaab8bc057bb49d5cdc0 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -225,7 +225,7 @@ public final class ItemStack implements DataComponentHolder {
     @Deprecated
     @Nullable
     private Item item;
-    private PatchedDataComponentMap components;
+    public PatchedDataComponentMap components; // Leaves - stackable shulker boxes
     @Nullable
     private Entity entityRepresentation;
 
diff --git a/src/main/java/net/minecraft/world/item/PickaxeItem.java b/src/main/java/net/minecraft/world/item/PickaxeItem.java
index 628cefa185598d4de53c72c94a2823b47c97c6ae..e645b21f3927fc71dfbb7ec1921915404da27827 100644
--- a/src/main/java/net/minecraft/world/item/PickaxeItem.java
+++ b/src/main/java/net/minecraft/world/item/PickaxeItem.java
@@ -6,4 +6,15 @@ public class PickaxeItem extends DiggerItem {
     public PickaxeItem(ToolMaterial material, float attackDamage, float attackSpeed, Item.Properties settings) {
         super(material, BlockTags.MINEABLE_WITH_PICKAXE, attackDamage, attackSpeed, settings);
     }
+
+    // Lumina - Porting Carpet's features - missing tools
+    public float getDestroySpeed(ItemStack stack, net.minecraft.world.level.block.state.BlockState state) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().missingTools && state.getSoundType() == net.minecraft.world.level.block.SoundType.GLASS)
+        {
+            final net.minecraft.world.item.component.Tool tool = stack.get(net.minecraft.core.component.DataComponents.TOOL);
+            return tool != null ? tool.getMiningSpeed(net.minecraft.world.level.block.Blocks.STONE.defaultBlockState()) : super.getDestroySpeed(stack, state);
+        }
+        return super.getDestroySpeed(stack, state);
+    }
+    // Lumina - Porting Carpet's features - missing tools
 }
diff --git a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
index 1451b25cedb7a8f01c046c8e1f8c6853aca42283..191c4615ffb7e2cbefb3781e445ff742f3b785f1 100644
--- a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
+++ b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
@@ -56,7 +56,7 @@ public class StandingAndWallBlockItem extends BlockItem {
 
         // CraftBukkit start
         if (iblockdata1 != null) {
-            boolean defaultReturn = world.isUnobstructed(iblockdata1, blockposition, CollisionContext.empty());
+            boolean defaultReturn = context.getPlayer() != null ? context.getPlayer().canSpectatingPlace(world, iblockdata1, blockposition, CollisionContext.empty()) : world.isUnobstructed(iblockdata1, blockposition, CollisionContext.empty()); // Lumina - creative no clip
             org.bukkit.entity.Player player = (context.getPlayer() instanceof ServerPlayer) ? (org.bukkit.entity.Player) context.getPlayer().getBukkitEntity() : null;
 
             BlockCanBuildEvent event = new BlockCanBuildEvent(CraftBlock.at(world, blockposition), player, CraftBlockData.fromData(iblockdata1), defaultReturn, org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(context.getHand())); // Paper - Expose hand in BlockCanBuildEvent
diff --git a/src/main/java/net/minecraft/world/item/context/UseOnContext.java b/src/main/java/net/minecraft/world/item/context/UseOnContext.java
index 09ef94ef68f5e2e1943bac32b5fc261cf5562f41..1a7306f109082b3268c9a3b8d5988e2ff42c658b 100644
--- a/src/main/java/net/minecraft/world/item/context/UseOnContext.java
+++ b/src/main/java/net/minecraft/world/item/context/UseOnContext.java
@@ -68,7 +68,7 @@ public class UseOnContext {
     }
 
     public Direction getHorizontalDirection() {
-        return this.player == null ? Direction.NORTH : this.player.getDirection();
+        return this.player == null ? Direction.NORTH : ((org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(player)) ? this.player.getDirection().getOpposite() : this.player.getDirection()); // Lumina - Porting Carpet's features - cactus flipper
     }
 
     public boolean isSecondaryUseActive() {
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index 0b0054b3d5d56ba24e1aee0e3ab56ea5b01a82a8..f41ebad315b55075a5324b6b7762ae6f1681e289 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -26,7 +26,6 @@ import javax.annotation.Nullable;
 // CraftBukkit end
 
 public final class Ingredient implements StackedContents.IngredientInfo<io.papermc.paper.inventory.recipe.ItemOrExact>, Predicate<ItemStack> { // Paper - Improve exact choice recipe ingredients
-
     public static final StreamCodec<RegistryFriendlyByteBuf, Ingredient> CONTENTS_STREAM_CODEC = ByteBufCodecs.holderSet(Registries.ITEM).map(Ingredient::new, (recipeitemstack) -> {
         return recipeitemstack.values;
     });
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index 2483627f807d7a3907f6848a8bc45d7a798e746d..159b3965d66983e9c9eba647f1fbdfa5ce01c2ff 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -38,6 +38,12 @@ import org.slf4j.Logger;
 import java.util.Collections;
 import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
+// Lumina start - Porting Carpet's features
+import net.minecraft.world.item.Item;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+// Lumina end - Porting Carpet's features
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 456f15e44e41d65338c0346594be2b0042b84005..955d9073287eda25032a4a3a7de8fee2ffcac8f7 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -107,7 +107,10 @@ import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions
-
+    // Lumina start - Porting Carpet's features
+    Map<net.minecraft.world.entity.EntityType<?>, Entity> precookedMobs = new HashMap<>();
+    private static final RuntimeException CONTROL_FLOW_EXCEPTION = new RuntimeException("Should be caught for control flow in World_getOtherEntitiesLimited!");
+    // Lumina end - Porting Carpet's features
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("the_nether"));
@@ -171,6 +174,105 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     //public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions // Folia - region threading
     //public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here // Folia - region threading
 
+        // Lumina start - Porting Carpet's features - fill update
+    public NeighborUpdater getNeighborUpdater() {
+        return this.getCurrentWorldData().neighborUpdater;
+    }
+
+    public Map<net.minecraft.world.entity.EntityType<?>, Entity> getPrecookedMobs() {
+        return precookedMobs;
+    }
+
+    public List<Entity> getOtherEntitiesLimited(@org.jetbrains.annotations.Nullable Entity except, AABB box, Predicate<? super Entity> predicate, int limit) {
+        java.util.concurrent.atomic.AtomicInteger checkedEntities = new java.util.concurrent.atomic.AtomicInteger();
+        List<Entity> list = Lists.newArrayList();
+        try {
+            this.getEntities().get(box, (entity) -> {
+                if (checkedEntities.getAndIncrement() > limit) {
+                    throw CONTROL_FLOW_EXCEPTION;
+                }
+
+                if (entity != except && predicate.test(entity)) {
+                    list.add(entity);
+                }
+
+                if (entity instanceof EnderDragon) {
+                    EnderDragonPart[] var4 = ((EnderDragon) entity).getSubEntities();
+
+                    for (EnderDragonPart enderDragonPart : var4) {
+                        if (entity != except && predicate.test(enderDragonPart)) {
+                            list.add(enderDragonPart);
+                        }
+                    }
+                }
+            });
+        } catch (RuntimeException e) {
+            if (e != CONTROL_FLOW_EXCEPTION)
+                // If it wasn't the exception we were watching, rethrow it
+                throw e;
+        }
+        return list;
+    }
+    // Lumina end - Porting Carpet's features - fill update
+    // Lumina start - Porting Carpet's features - movable block entities
+    public boolean setBlockStateWithBlockEntity(BlockPos blockPos_1, BlockState blockState_1, BlockEntity newBlockEntity, int int_1) {
+        if (isOutsideBuildHeight(blockPos_1) || !this.isClientSide && isDebug()) return false;
+        LevelChunk worldChunk_1 = this.getChunkAt(blockPos_1);
+        Block block_1 = blockState_1.getBlock();
+
+        BlockState blockState_2;
+        if (newBlockEntity != null && block_1 instanceof net.minecraft.world.level.block.EntityBlock) {
+            blockState_2 = worldChunk_1.setBlockStateWithBlockEntity(blockPos_1, blockState_1, newBlockEntity, (int_1 & 64) != 0);
+            if (newBlockEntity instanceof net.minecraft.world.level.block.entity.LidBlockEntity) {
+                scheduleTick(blockPos_1, block_1, 5);
+            }
+        }
+        else {
+            blockState_2 = worldChunk_1.setBlockState(blockPos_1, blockState_1, (int_1 & 64) != 0);
+        }
+
+        if (blockState_2 == null) {
+            return false;
+        }
+        else {
+            BlockState blockState_3 = this.getBlockState(blockPos_1);
+
+            if (blockState_3 != blockState_2 && (blockState_3.getLightBlock() != blockState_2.getLightBlock() || blockState_3.getLightEmission() != blockState_2.getLightEmission() || blockState_3.useShapeForLightOcclusion() || blockState_2.useShapeForLightOcclusion())) {
+                ProfilerFiller profiler = Profiler.get();
+                profiler.push("queueCheckLight");
+                this.getChunkSource().getLightEngine().checkBlock(blockPos_1);
+                profiler.pop();
+            }
+
+            if (blockState_3 == blockState_1) {
+                if (blockState_2 != blockState_3) {
+                    this.setBlocksDirty(blockPos_1, blockState_2, blockState_3);
+                }
+
+                if ((int_1 & 2) != 0 && (!this.isClientSide || (int_1 & 4) == 0) && (this.isClientSide || worldChunk_1.getFullStatus() != null && worldChunk_1.getFullStatus().isOrAfter(FullChunkStatus.BLOCK_TICKING))) {
+                    this.sendBlockUpdated(blockPos_1, blockState_2, blockState_1, int_1);
+                }
+
+                if (!this.isClientSide && (int_1 & 1) != 0) {
+                    this.updateNeighborsAt(blockPos_1, blockState_2.getBlock());
+                    if (blockState_1.hasAnalogOutputSignal()) {
+                        updateNeighbourForOutputSignal(blockPos_1, block_1);
+                    }
+                }
+
+                if ((int_1 & 16) == 0) {
+                    int int_2 = int_1 & -34;
+                    blockState_2.updateIndirectNeighbourShapes(this, blockPos_1, int_2); // prepare
+                    blockState_1.updateNeighbourShapes(this, blockPos_1, int_2); // updateNeighbours
+                    blockState_1.updateIndirectNeighbourShapes(this, blockPos_1, int_2); // prepare
+                }
+                this.onBlockStateChange(blockPos_1, blockState_2, blockState_3);
+            }
+            return true;
+        }
+    }
+    // Lumina end - Porting Carpet's features - movable block entities
+
     public CraftWorld getWorld() {
         return this.world;
     }
@@ -1219,13 +1321,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             }
 
             if ((i & 1) != 0) {
-                this.blockUpdated(blockposition, iblockdata1.getBlock());
+                if (!org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) this.blockUpdated(blockposition, iblockdata1.getBlock()); // Lumina - Porting Carpet's features - fill updates
                 if (!this.isClientSide && iblockdata.hasAnalogOutputSignal()) {
                     this.updateNeighbourForOutputSignal(blockposition, newBlock.getBlock());
                 }
             }
 
-            if ((i & 16) == 0 && j > 0) {
+            if ((i & (org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get() ? -1 : 16)) == 0 && j > 0) { // Lumina - Porting Carpet's features - fill updates
                 int k = i & -34;
 
                 // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/level/block/BarrierBlock.java b/src/main/java/net/minecraft/world/level/block/BarrierBlock.java
index c27f78ab7994687fe1c25ec44ffff4388270df6f..0373cfeab1cb7048c4f038c36c2ffabbaf9f5224 100644
--- a/src/main/java/net/minecraft/world/level/block/BarrierBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BarrierBlock.java
@@ -24,6 +24,38 @@ import net.minecraft.world.level.material.Fluids;
 public class BarrierBlock extends Block implements SimpleWaterloggedBlock {
     public static final MapCodec<BarrierBlock> CODEC = simpleCodec(BarrierBlock::new);
     public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
+    // Lumina start - Porting Carpet's features - update suppression block
+    private boolean shouldPower = false;
+
+    public int getSignal(BlockState state, BlockGetter level, BlockPos pos, Direction direction) {
+        return (shouldPower && direction == Direction.DOWN) ? 15 : 0;
+    }
+
+    public void neighborChanged(BlockState state, net.minecraft.world.level.Level level, BlockPos pos, Block block, net.minecraft.world.level.redstone.Orientation fromPos, boolean notify) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().updateSuppressionBlock != -1) {
+            if (true/*fromPos.equals(pos.above())*/) { // todo neighbour updates don't have source
+                BlockState stateAbove = level.getBlockState(pos.above());
+                if (stateAbove.is(Blocks.ACTIVATOR_RAIL) && !stateAbove.getValue(PoweredRailBlock.POWERED)) {
+                    level.scheduleTick(pos, this, 1);
+                    net.minecraft.world.level.redstone.NeighborUpdater updater = level.getNeighborUpdater();
+                    if (updater instanceof net.minecraft.world.level.redstone.CollectingNeighborUpdater cnua)
+                        cnua.count = (cnua.maxChainedNeighborUpdates-org.leavesmc.lumina.carpet.CarpetConfig.configModule().updateSuppressionBlock);
+                }
+            }
+        }
+        super.neighborChanged(state, level, pos, block, fromPos, notify);
+    }
+
+    public void tick(BlockState state, net.minecraft.server.level.ServerLevel level, BlockPos pos, net.minecraft.util.RandomSource random) {
+        BlockPos posAbove = pos.above();
+        BlockState stateAbove = level.getBlockState(posAbove);
+        if (stateAbove.is(Blocks.ACTIVATOR_RAIL) && !stateAbove.getValue(PoweredRailBlock.POWERED)) {
+            shouldPower = true;
+            level.setBlock(posAbove, stateAbove.setValue(PoweredRailBlock.POWERED, true), Block.UPDATE_CLIENTS | Block.UPDATE_NONE);
+            shouldPower = false;
+        }
+    }
+    // Lumina end - Porting Carpet's features - update suppression block
 
     @Override
     public MapCodec<BarrierBlock> codec() {
diff --git a/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java b/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
index 8920855b07a31715327b8102c7faafc9f916825d..ee866cd00cd843df66830e84d6fe64487f43f7cc 100644
--- a/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BuddingAmethystBlock.java
@@ -24,6 +24,19 @@ public class BuddingAmethystBlock extends AmethystBlock {
         super(settings);
     }
 
+    // Lumina start - Porting Carpet's features - movable amethyst
+    public void playerDestroy(net.minecraft.world.level.Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, net.minecraft.world.level.block.entity.BlockEntity blockEntity, net.minecraft.world.item.ItemStack stack) {
+        super.playerDestroy(world, player, pos, state, blockEntity, stack, true, false);
+        // doing it here rather than though loottables since loottables are loaded on reload
+        // drawback - not controlled via loottables, but hey
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().movableAmethyst &&
+                stack.getItem() instanceof net.minecraft.world.item.PickaxeItem &&
+                net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(world.registryAccess().lookupOrThrow(net.minecraft.core.registries.Registries.ENCHANTMENT).getOrThrow(net.minecraft.world.item.enchantment.Enchantments.SILK_TOUCH), stack) > 0
+        )
+            popResource(world, pos, net.minecraft.world.item.Items.BUDDING_AMETHYST.getDefaultInstance());
+    }
+    // Lumina end - Porting Carpet's features - movable amethyst
+
     @Override
     protected void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
         if (random.nextInt(5) == 0) {
diff --git a/src/main/java/net/minecraft/world/level/block/ChainBlock.java b/src/main/java/net/minecraft/world/level/block/ChainBlock.java
index b2ca7a089e358a82c6712f5e564fd702c42d575f..aec1460215d2914ae79540caaf3895fde8bb4d31 100644
--- a/src/main/java/net/minecraft/world/level/block/ChainBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ChainBlock.java
@@ -29,6 +29,32 @@ public class ChainBlock extends RotatedPillarBlock implements SimpleWaterloggedB
     protected static final VoxelShape Z_AXIS_AABB = Block.box(6.5, 6.5, 0.0, 9.5, 9.5, 16.0);
     protected static final VoxelShape X_AXIS_AABB = Block.box(0.0, 6.5, 6.5, 16.0, 9.5, 9.5);
 
+    // Lumina start - Porting Carpet's features - custom sticky
+    public boolean isSticky(BlockState state) {
+        return org.leavesmc.lumina.carpet.CarpetConfig.configModule().chainStone.enabled();
+    }
+
+    public boolean isStickyToNeighbor(net.minecraft.world.level.Level level, BlockPos pos, BlockState state, BlockPos neighborPos, BlockState neighborState, Direction dir, Direction moveDir) {
+        net.minecraft.core.Direction.Axis axis = state.getValue(ChainBlock.AXIS);
+
+        if (axis != dir.getAxis()) {
+            return false;
+        }
+
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().chainStone == org.leavesmc.lumina.carpet.CarpetConfigModule.ChainStoneMode.STICK_TO_ALL) {
+            return true;
+        }
+        if (neighborState.is((Block)(Object)this)) {
+            return axis == neighborState.getValue(ChainBlock.AXIS);
+        }
+        if (neighborState.is(Blocks.END_ROD)) {
+            return axis == neighborState.getValue(EndRodBlock.FACING).getAxis();
+        }
+
+        return Block.canSupportCenter(level, neighborPos, dir.getOpposite());
+    }
+    // Lumina end - Porting Carpet's features - custom sticky
+
     @Override
     public MapCodec<ChainBlock> codec() {
         return CODEC;
diff --git a/src/main/java/net/minecraft/world/level/block/ChestBlock.java b/src/main/java/net/minecraft/world/level/block/ChestBlock.java
index ca69a9fbd4942f9079aeaab7cead2d7a2c3b8659..b055a94038738806db23c668064b5ee75602131a 100644
--- a/src/main/java/net/minecraft/world/level/block/ChestBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ChestBlock.java
@@ -104,6 +104,28 @@ public class ChestBlock extends AbstractChestBlock<ChestBlockEntity> implements
         }
     };
 
+    // Lumina start - Porting Carpet's features - movable block entities
+    public boolean isSticky(BlockState state) {
+        // return org.leavesmc.lumina.carpet.CarpetConfig.configModule().movableBlockEntities; // TODO
+        return false;
+    }
+
+    public boolean isStickyToNeighbor(Level level, BlockPos pos, BlockState state, BlockPos neighborPos, BlockState neighborState, Direction dir, Direction moveDir) {
+        if (!neighborState.is((Block)(Object)this)) {
+            return false;
+        }
+
+        ChestType type = state.getValue(ChestBlock.TYPE);
+        ChestType neighborType = neighborState.getValue(ChestBlock.TYPE);
+
+        if (type == ChestType.SINGLE || neighborType == ChestType.SINGLE) {
+            return false;
+        }
+
+        return getConnectedDirection(state) == dir;
+    }
+    // Lumina end - Porting Carpet's features - movable block entities
+
     // CraftBukkit start
     public static class DoubleInventory implements MenuProvider {
 
diff --git a/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java b/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java
index 09849438e2170d8b2fbc82ee7dfc5df28ce91cc9..910cd74a985063b8e9f5e758fdcdbda2e42d58a3 100644
--- a/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CoralFanBlock.java
@@ -15,6 +15,11 @@ import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.Fluids;
 
 public class CoralFanBlock extends BaseCoralFanBlock {
+    // Lumina start - Porting Carpet's features - renewable coral
+    public boolean isEnabled() {
+        return org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableCoral == org.leavesmc.lumina.carpet.CarpetConfigModule.RenewableCoralMode.EXPANDED;
+    }
+    // Lumina end - Porting Carpet's features - renewable coral
 
     public static final MapCodec<CoralFanBlock> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
         return instance.group(CoralBlock.DEAD_CORAL_FIELD.forGetter((blockcoralfan) -> {
diff --git a/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java b/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java
index 5200ceb141795dd7d4d28d861996ce360adeae01..b0279512397eb2e26cc7da58663ca9254ac6ecae 100644
--- a/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CoralPlantBlock.java
@@ -28,6 +28,13 @@ public class CoralPlantBlock extends BaseCoralPlantTypeBlock {
     protected static final float AABB_OFFSET = 6.0F;
     protected static final VoxelShape SHAPE = Block.box(2.0D, 0.0D, 2.0D, 14.0D, 15.0D, 14.0D);
 
+    // Lumina start - Porting Carpet's features - renewable coral
+    public boolean isEnabled() {
+        return org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableCoral == org.leavesmc.lumina.carpet.CarpetConfigModule.RenewableCoralMode.EXPANDED
+                || org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableCoral == org.leavesmc.lumina.carpet.CarpetConfigModule.RenewableCoralMode.TRUE;
+    }
+    // Lumina end - Porting Carpet's features - renewable coral
+
     @Override
     public MapCodec<CoralPlantBlock> codec() {
         return CoralPlantBlock.CODEC;
diff --git a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
index 0537418c9337d95acdc80eead47c9cbf397e7042..2800b76f1617de80cfe36c79a7c8545a06603576 100644
--- a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
@@ -124,6 +124,7 @@ public class DispenserBlock extends BaseEntityBlock {
     // Paper end - Fix NPE with equippable and items without behavior
 
     protected DispenseItemBehavior getDispenseMethod(Level world, ItemStack stack) {
+        if (stack.getItem() == net.minecraft.world.item.Items.CACTUS) return new org.leavesmc.lumina.carpet.helpers.BlockRotator.CactusDispenserBehaviour(); // Lumina - Porting Carpet's features - cactus dispenser
         if (!stack.isItemEnabled(world.enabledFeatures())) {
             return DispenserBlock.DEFAULT_BEHAVIOR;
         } else {
@@ -139,7 +140,7 @@ public class DispenserBlock extends BaseEntityBlock {
 
     @Override
     protected void neighborChanged(BlockState state, Level world, BlockPos pos, Block sourceBlock, @Nullable Orientation wireOrientation, boolean notify) {
-        boolean flag1 = world.hasNeighborSignal(pos) || world.hasNeighborSignal(pos.above());
+        boolean flag1 = world.hasNeighborSignal(pos) || org.leavesmc.lumina.carpet.helpers.QuasiConnectivity.hasQuasiSignal(world, pos); // Lumina - Porting Carpet's features - quasi connectivity
         boolean flag2 = (Boolean) state.getValue(DispenserBlock.TRIGGERED);
 
         if (flag1 && !flag2) {
diff --git a/src/main/java/net/minecraft/world/level/block/HopperBlock.java b/src/main/java/net/minecraft/world/level/block/HopperBlock.java
index 8ba23af2fa6c5174aa3ec34e78f9c21ce786c4fc..44c3638bf27dfa2cf0189fc4372553325ffb44c1 100644
--- a/src/main/java/net/minecraft/world/level/block/HopperBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/HopperBlock.java
@@ -99,7 +99,10 @@ public class HopperBlock extends BaseEntityBlock {
 
     @Override
     public BlockState getStateForPlacement(BlockPlaceContext ctx) {
-        Direction direction = ctx.getClickedFace().getOpposite();
+        // Lumina start - Porting Carpet's features - cactus
+        Direction direction = ctx.getClickedFace();
+        if (!org.leavesmc.lumina.carpet.helpers.BlockRotator.flippinEligibility(ctx.getPlayer())) direction = direction.getOpposite();
+        // Lumina end - Porting Carpet's features - cactus
         return this.defaultBlockState()
             .setValue(FACING, direction.getAxis() == Direction.Axis.Y ? Direction.DOWN : direction)
             .setValue(ENABLED, Boolean.valueOf(true));
diff --git a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
index ba70bcd21af5f2c33ba14612771484ff56a54a2a..3495538f2620a4eedaa51f0b1e10943c7e6d81bc 100644
--- a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
@@ -57,6 +57,11 @@ public class InfestedBlock extends Block {
             entitysilverfish.moveTo((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D, 0.0F, 0.0F);
             world.addFreshEntity(entitysilverfish, SpawnReason.SILVERFISH_BLOCK); // CraftBukkit - add SpawnReason
             entitysilverfish.spawnAnim();
+            // Lumina start - Porting Carpet's features - silverfish drop gravel
+            if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().silverFishDropGravel) {
+                popResource(world, pos, new ItemStack(Blocks.GRAVEL));
+            }
+            // Lumina end - Porting Carpet's features - silverfish drop gravel
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/block/LiquidBlock.java b/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
index a2d023ff011f71f80032f02430a53d6a08a23623..4a4a3d9758ce45105a0eb9a73f2383409126e807 100644
--- a/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
@@ -193,6 +193,13 @@ public class LiquidBlock extends Block implements BucketPickup {
                 BlockPos blockposition1 = pos.relative(enumdirection.getOpposite());
 
                 if (world.getFluidState(blockposition1).is(FluidTags.WATER)) {
+                    // Lumina start - Porting Carpet's features - renewable deepslate
+                    if(org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableDeepslate && !world.getFluidState(pos).isSource() && world.dimension() == Level.OVERWORLD && pos.getY() < 0) {
+                        world.setBlockAndUpdate(pos, Blocks.COBBLED_DEEPSLATE.defaultBlockState());
+                        this.fizz(world, pos);
+                        return false;
+                    }
+                    // Lumina end - Porting Carpet's features - renewable deepslate
                     Block block = world.getFluidState(pos).isSource() ? Blocks.OBSIDIAN : Blocks.COBBLESTONE;
 
                     // CraftBukkit start
@@ -213,7 +220,22 @@ public class LiquidBlock extends Block implements BucketPickup {
                 }
             }
         }
-
+        // Lumina start - Porting Carpet's features - renewable blackstone
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableBlackstone) {
+            if (fluid.is(FluidTags.LAVA)) {
+                for(Direction direction : Direction.values()) {
+                    if (direction != Direction.DOWN) {
+                        BlockPos blockPos = pos.relative(direction); // offset
+                        if (world.getBlockState(blockPos).is(Blocks.BLUE_ICE)) {
+                            world.setBlockAndUpdate(pos, Blocks.BLACKSTONE.defaultBlockState());
+                            fizz(world, pos);
+                            return false;
+                        }
+                    }
+                }
+            }
+        }
+        // Lumina end - Porting Carpet's features - renewable blackstone
         return true;
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/PoweredRailBlock.java b/src/main/java/net/minecraft/world/level/block/PoweredRailBlock.java
index 78c6fc0755b149515a98163cb7c68589595c365c..339bdbdad0d8d13be621b8cf7bb134315e8f9f4b 100644
--- a/src/main/java/net/minecraft/world/level/block/PoweredRailBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/PoweredRailBlock.java
@@ -30,7 +30,7 @@ public class PoweredRailBlock extends BaseRailBlock {
     }
 
     protected boolean findPoweredRailSignal(Level world, BlockPos pos, BlockState state, boolean flag, int distance) {
-        if (distance >= 8) {
+        if (distance >= (org.leavesmc.lumina.carpet.CarpetConfig.configModule().railPowerLimit-1)) { // Lumina - Porting Carpet's features - rail power limit
             return false;
         } else {
             int j = pos.getX();
diff --git a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
index e842c05cfe5991ba33582b9399610affbd02913f..7ecab74208cd2a8502a8ba85f1346069ed376c1f 100644
--- a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
@@ -4,9 +4,12 @@ import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BiomeTags;
+import net.minecraft.tags.FluidTags;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.grower.TreeGrower;
 import net.minecraft.world.level.block.state.BlockBehaviour;
@@ -61,6 +64,17 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
 
     }
 
+    // Lumina start - Porting Carpet's features - desert shrubs
+    private static boolean nearWater(LevelAccessor level, BlockPos pos) {
+        for (BlockPos blockPos : BlockPos.betweenClosed(pos.offset(-4, -4, -4), pos.offset(4, 1, 4))) {
+            if (level.getFluidState(blockPos).is(FluidTags.WATER)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    // Lumina end - Porting Carpet's features - desert shrubs
+
     public void advanceTree(ServerLevel world, BlockPos pos, net.minecraft.world.level.block.state.BlockState state, RandomSource random) {
         if ((Integer) state.getValue(SaplingBlock.STAGE) == 0) {
             world.setBlock(pos, (net.minecraft.world.level.block.state.BlockState) state.cycle(SaplingBlock.STAGE), 4);
@@ -68,10 +82,18 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
             // CraftBukkit start
             io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - region threading
             if (worldData.captureTreeGeneration) { // Folia - region threading
-                this.treeGrower.growTree(world, world.getChunkSource().getGenerator(), pos, state, random);
+                // Lumina start - Porting Carpet's features - desert shrubs
+                if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().desertShrubs && world.getBiome(pos).is(BiomeTags.HAS_DESERT_PYRAMID) && !nearWater(world, pos))
+                    world.setBlock(pos, Blocks.DEAD_BUSH.defaultBlockState(), Block.UPDATE_ALL);
+                else this.treeGrower.growTree(world, world.getChunkSource().getGenerator(), pos, state, random);
+                // Lumina end - Porting Carpet's features - desert shrubs
             } else {
                 worldData.captureTreeGeneration = true; // Folia - region threading
-                this.treeGrower.growTree(world, world.getChunkSource().getGenerator(), pos, state, random);
+                // Lumina start - Porting Carpet's features - desert shrubs
+                if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().desertShrubs && world.getBiome(pos).is(BiomeTags.HAS_DESERT_PYRAMID) && !nearWater(world, pos))
+                    world.setBlock(pos, Blocks.DEAD_BUSH.defaultBlockState(), Block.UPDATE_ALL);
+                else this.treeGrower.growTree(world, world.getChunkSource().getGenerator(), pos, state, random);
+                // Lumina end - Porting Carpet's features - desert shrubs
                 worldData.captureTreeGeneration = false; // Folia - region threading
                 if (worldData.capturedBlockStates.size() > 0) { // Folia - region threading
                     TreeType treeType = SaplingBlock.treeTypeRT.get(); // Folia - region threading
diff --git a/src/main/java/net/minecraft/world/level/block/TntBlock.java b/src/main/java/net/minecraft/world/level/block/TntBlock.java
index 2cbe2053dd5d0bcdcd89de69762c77b400b8697a..d17e327e3ac7040db1b2cdb6167867a8af066cce 100644
--- a/src/main/java/net/minecraft/world/level/block/TntBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/TntBlock.java
@@ -51,7 +51,7 @@ public class TntBlock extends Block {
     @Override
     protected void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
         if (!oldState.is(state.getBlock())) {
-            if (world.hasNeighborSignal(pos) && CraftEventFactory.callTNTPrimeEvent(world, pos, PrimeCause.REDSTONE, null, null)) { // CraftBukkit - TNTPrimeEvent
+            if (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().tntDoNotUpdate && world.hasNeighborSignal(pos) && CraftEventFactory.callTNTPrimeEvent(world, pos, PrimeCause.REDSTONE, null, null)) { // CraftBukkit - TNTPrimeEvent // Lumina - Porting Carpet's features - tnt do not update
                 // Paper start - TNTPrimeEvent
                 org.bukkit.block.Block tntBlock = org.bukkit.craftbukkit.block.CraftBlock.at(world, pos);
                 if (!new com.destroystokyo.paper.event.block.TNTPrimeEvent(tntBlock, com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason.REDSTONE, null).callEvent()) {
diff --git a/src/main/java/net/minecraft/world/level/block/WoolCarpetBlock.java b/src/main/java/net/minecraft/world/level/block/WoolCarpetBlock.java
index d8a3d6d5998939c0db8eb521a97774bb5083cd3c..43a5cc9696c37f93f6053ef2901a8d94a489a075 100644
--- a/src/main/java/net/minecraft/world/level/block/WoolCarpetBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/WoolCarpetBlock.java
@@ -25,4 +25,17 @@ public class WoolCarpetBlock extends CarpetBlock {
     public DyeColor getColor() {
         return this.color;
     }
+
+
+    // Lumina start - Porting Carpet's features - carpet place action
+    public net.minecraft.world.level.block.state.BlockState getStateForPlacement(net.minecraft.world.item.context.BlockPlaceContext context)
+    {
+        net.minecraft.world.level.block.state.BlockState state = super.getStateForPlacement(context);
+        if (context.getPlayer() != null && !context.getLevel().isClientSide)
+        { // getColor()
+            org.leavesmc.lumina.carpet.utils.WoolTool.carpetPlacedAction(((WoolCarpetBlock)(Object)this).getColor(), context.getPlayer(), context.getClickedPos(), (net.minecraft.server.level.ServerLevel) context.getLevel());
+        }
+        return state;
+    }
+    // Lumina end - Porting Carpet's features - carpet place action
 }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index 7faa0c9d34a40a021a0f2c22c0cc83e17a427cdc..e105e3dfb4c925c4897109329a96f7613c6fc820 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -421,7 +421,7 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         boolean flag = !stack.isEmpty() && ItemStack.isSameItemSameComponents(itemstack1, stack);
 
         this.items.set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
         if (slot == 0 && !flag) {
             Level world = this.level;
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
index 1f29b2419914ca9257db6553f01b7e7ec49bfc18..9d9a7c972119b224089f062d9c64c689e3d47bcc 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
@@ -158,7 +158,7 @@ public abstract class BaseContainerBlockEntity extends BlockEntity implements Co
     @Override
     public void setItem(int slot, ItemStack stack) {
         this.getItems().set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
         this.setChanged();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index edb7b9391855eba5d693f3d64b6fb14a1b1c4949..b99481bc253d8e432bd926b4522131dc9530ea5c 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -43,11 +43,17 @@ public abstract class BlockEntity {
     private final BlockEntityType<?> type;
     @Nullable
     protected Level level;
-    protected final BlockPos worldPosition;
+    protected BlockPos worldPosition; // Lumina - Porting Carpet's features
     protected boolean remove;
     private BlockState blockState;
     private DataComponentMap components;
 
+    // Lumina start - Porting Carpet's features - movable block entity
+    public void setCMPos(BlockPos newPos) {
+        worldPosition = newPos;
+    }
+    // Lumina end - Porting Carpet's features
+
     // Folia start - region ticking
     public void updateTicks(final long fromTickOffset, final long fromRedstoneTimeOffset) {
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 5ab069e1582a46e4420f3aff58451636ba0e87dc..d23fe75697b3acee823590447cceee740c16da19 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -22,6 +22,7 @@ import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.inventory.AbstractContainerMenu;
 import net.minecraft.world.inventory.HopperMenu;
+import net.minecraft.world.item.DyeColor;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
@@ -135,7 +136,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     public void setItem(int slot, ItemStack stack) {
         this.unpackLootTable((Player) null);
         this.getItems().set(slot, stack);
-        stack.limitSize(this.getMaxStackSize(stack));
+        stack.limitSize(this.getMaxStackLeaves(stack)); // Leaves - stackable shulker boxes
     }
 
     @Override
@@ -460,6 +461,25 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     // Paper end - Perf: Optimize Hoppers
 
     private static boolean ejectItems(Level world, BlockPos pos, HopperBlockEntity blockEntity) {
+        // Lumina start - Porting Carpet's features - hopper counters
+        if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().hopperCounters) {
+            Direction hopperFacing = world.getBlockState(pos).getValue(HopperBlock.FACING);
+            DyeColor woolColor = org.leavesmc.lumina.carpet.utils.WoolTool.getWoolColorAtPosition(
+                    world,
+                    pos.relative(hopperFacing));
+            if (woolColor != null) {
+                Container inventory = HopperBlockEntity.getContainerAt(world, pos);
+                for (int i = 0; i < inventory.getContainerSize(); ++i) {
+                    if (!inventory.getItem(i).isEmpty()) {
+                        ItemStack itemstack = inventory.getItem(i);//.copy();
+                        org.leavesmc.lumina.carpet.helpers.HopperCounter.getCounter(woolColor).add(world.getServer(), itemstack);
+                        inventory.setItem(i, ItemStack.EMPTY);
+                    }
+                }
+                return true;
+            }
+        }
+        // Lumina end - Porting Carpet's features - hopper counters
         Container iinventory = HopperBlockEntity.getAttachedContainer(world, pos, blockEntity);
 
         if (iinventory == null) {
@@ -766,9 +786,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
             if (itemstack1.isEmpty()) {
                 // Spigot start - SPIGOT-6693, InventorySubcontainer#setItem
                 ItemStack leftover = ItemStack.EMPTY; // Paper - Make hoppers respect inventory max stack size
-                if (!stack.isEmpty() && stack.getCount() > to.getMaxStackSize()) {
+                if (!stack.isEmpty() && (stack.getCount() > to.getMaxStackSize() || stack.getCount() > stack.getMaxStackSize())) { // Leaves - stackable shulker boxes
                     leftover = stack; // Paper - Make hoppers respect inventory max stack size
-                    stack = stack.split(to.getMaxStackSize());
+                    stack = stack.split(Math.min(to.getMaxStackSize(), stack.getMaxStackSize())); // Leaves - stackable shulker boxes
                 }
                 // Spigot end
                 IGNORE_TILE_UPDATES.set(Boolean.TRUE); // Paper - Perf: Optimize Hoppers // Folia - region threading
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
index 28849cf84afcdc0d9fc245fac1a8d769a2db3b68..52bea3098432e1bf87bf8484157f06fcb66d6c39 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
@@ -115,6 +115,7 @@ public class SculkSensorBlockEntity extends BlockEntity implements GameEventList
 
         @Override
         public int getListenerRadius() {
+            if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().sculkSensorRange != SculkSensorBlockEntity.VibrationUser.LISTENER_RANGE) return org.leavesmc.lumina.carpet.CarpetConfig.configModule().sculkSensorRange; // Lumina - Porting Carpet's features - sculk sensor range
             if (SculkSensorBlockEntity.this.rangeOverride != null) return SculkSensorBlockEntity.this.rangeOverride; // Paper - Configurable sculk sensor listener range
             return 8;
         }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
index c27776bfeef0e2a79ac0a22384c862d469363a0c..ac4e636344804d4ebdd6e4cd2a230563c0c68ea3 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
@@ -174,7 +174,7 @@ public class ShulkerBoxBlockEntity extends RandomizableContainerBlockEntity impl
                 while (iterator.hasNext()) {
                     Entity entity = (Entity) iterator.next();
 
-                    if (entity.getPistonPushReaction() != PushReaction.IGNORE) {
+                    if (entity.getPistonPushReaction() != PushReaction.IGNORE  && !(entity instanceof Player player && player.isCreativeFlyOrSpectator())) { // Lumina - creative no clip
                         entity.move(MoverType.SHULKER_BOX, new Vec3((axisalignedbb.getXsize() + 0.01D) * (double) enumdirection.getStepX(), (axisalignedbb.getYsize() + 0.01D) * (double) enumdirection.getStepY(), (axisalignedbb.getZsize() + 0.01D) * (double) enumdirection.getStepZ()));
                     }
                 }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/StructureBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/StructureBlockEntity.java
index 0e4c17c7246093d7fdb64a8f98536a84a8cfd978..1d10bd031903a1ac5faf491fffe135aee462b5cb 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/StructureBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/StructureBlockEntity.java
@@ -404,7 +404,15 @@ public class StructureBlockEntity extends BlockEntity {
         }
 
         BlockPos blockPos = this.getBlockPos().offset(this.structurePos);
-        template.placeInWorld(world, blockPos, blockPos, structurePlaceSettings, createRandom(this.seed), 2);
+        // Lumina start - Porting Carpet's features - fill updates
+        if(!org.leavesmc.lumina.carpet.CarpetConfig.configModule().fillUpdates) org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(true);
+        try {
+            template.placeInWorld(world, blockPos, blockPos, structurePlaceSettings, createRandom(this.seed), 2);
+        }
+        finally {
+            org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(false);
+        }
+        // Lumina end - Porting Carpet's features - fill updates
     }
 
     public void unloadStructure() {
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index 0a7b67863e6f75bfcde877d5d226ab60dbe5a81b..64b0b866c328c5f1046a471a4fd8516ed4628dc3 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -72,6 +72,12 @@ public class PistonBaseBlock extends DirectionalBlock {
     protected static final VoxelShape DOWN_AABB = Block.box(0.0D, 4.0D, 0.0D, 16.0D, 16.0D, 16.0D);
     private final boolean isSticky;
 
+    // Lumina start - Porting Carpet's features - rotator block
+    public boolean publicShouldExtend(Level world_1, BlockPos blockPos_1, Direction direction_1) {
+        return getNeighborSignal(world_1, blockPos_1,direction_1);
+    }
+    // Lumina end - Porting Carpet's features - rotator block
+
     @Override
     public MapCodec<PistonBaseBlock> codec() {
         return PistonBaseBlock.CODEC;
@@ -196,6 +202,7 @@ public class PistonBaseBlock extends DirectionalBlock {
         if (world.hasSignal(pos, Direction.DOWN)) {
             return true;
         } else {
+            if(true) return org.leavesmc.lumina.carpet.helpers.QuasiConnectivity.hasQuasiSignal(world, pos); // Lumina - Porting Carpet's features - quasi connectivity
             BlockPos blockposition1 = pos.above();
             Direction[] aenumdirection1 = Direction.values();
 
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index c3a04ef842630b3df447dea48b84bccde0c89e83..2e616aa6e3e03ea78bfd5ba503a63495ea6f1c50 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -137,6 +137,22 @@ public class PistonMovingBlockEntity extends BlockEntity {
                         }
 
                         entity = (Entity)var12.next();
+                        // Lumina start - Porting Carpet's features - creative no clip
+                        // TODO fakeplayer
+                        // if (entity instanceof org.leavesmc.lumina.carpet.patches.EntityPlayerMPFake && blockEntity.getMovedState().is(Blocks.SLIME_BLOCK)) {
+                        //     Vec3 vec3d = entity.getDeltaMovement();
+                        //     double x = vec3d.x;
+                        //     double y = vec3d.y;
+                        //     double z = vec3d.z;
+                        //     Direction di = blockEntity.getMovementDirection();
+                        //     switch (di.getAxis()) {
+                        //         case X -> x = di.getStepX();
+                        //         case Y -> y = di.getStepY();
+                        //         case Z -> z = di.getStepZ();
+                        //     }
+                        //     entity.setDeltaMovement(x, y, z);
+                        // }
+                        // Lumina end - Porting Carpet's features - creative no clip
                         if (entity.getPistonPushReaction() != PushReaction.IGNORE) {
                             if (!bl) {
                                 break;
@@ -158,7 +174,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
                                         h = (double)direction.getStepZ();
                                 }
 
-                                entity.setDeltaMovement(e, g, h);
+                                if (!(entity instanceof net.minecraft.world.entity.player.Player player) || !player.isCreativeFlyOrSpectator()) entity.setDeltaMovement(e, g, h); // Lumina - creative no clip
                                 // Paper - EAR items stuck in in slime pushed by a piston
                                 entity.activatedTick = Math.max(entity.activatedTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 10); // Folia - region threading
                                 entity.activatedImmunityTick = Math.max(entity.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 10); // Folia - region threading
@@ -194,6 +210,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
     }
 
     private static void moveEntityByPiston(Direction direction, Entity entity, double distance, Direction movementDirection) {
+        if (entity instanceof net.minecraft.world.entity.player.Player player && player.isCreativeFlyOrSpectator()) return; // Lumina - creative no clip
         NOCLIP.set(direction);
         entity.move(
             MoverType.PISTON,
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java b/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java
index 205e223c356634bd6bc6bd58c6f0b7fda61a6f5f..53d4bc27df9bade309ce082f3e309b8966ab778d 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java
@@ -10,7 +10,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.PushReaction;
 
 public class PistonStructureResolver {
-    public static final int MAX_PUSH_DEPTH = 12;
+    public static int MAX_PUSH_DEPTH = 12; // Lumina - Porting Carpet's features - push limit
     private final Level level;
     private final BlockPos pistonPos;
     private final boolean extending;
@@ -19,6 +19,34 @@ public class PistonStructureResolver {
     private final List<BlockPos> toPush = Lists.newArrayList();
     private final List<BlockPos> toDestroy = Lists.newArrayList();
     private final Direction pistonDirection;
+    // Lumina start - Porting Carpet's features - custom sticky
+    private BlockPos pos_addBlockLine;
+    private BlockPos behindPos_addBlockLine;
+    private Direction dir_addBranchingBlocks;
+    private BlockPos neighborPos_addBranchingBlocks;
+
+    private boolean onAddBlockLineCanStickToEachOther(BlockState state, BlockState behindState) {
+        if (state.getBlock() instanceof net.minecraft.world.level.block.ChainBlock chainBlock){
+            return chainBlock.isStickyToNeighbor(level, pos_addBlockLine, state, behindPos_addBlockLine, behindState, pushDirection.getOpposite(), pushDirection);
+        }
+        if (state.getBlock() instanceof net.minecraft.world.level.block.ChestBlock chestBlock){
+            return chestBlock.isStickyToNeighbor(level, pos_addBlockLine, state, behindPos_addBlockLine, behindState, pushDirection.getOpposite(), pushDirection);
+        }
+
+        return canStickToEachOther(state, behindState);
+    }
+
+    private boolean onAddBranchingBlocksCanStickToEachOther(BlockState neighborState, BlockState state, BlockPos pos) {
+        if (state.getBlock() instanceof net.minecraft.world.level.block.ChainBlock chainBlock) {
+            return chainBlock.isStickyToNeighbor(level, pos, state, neighborPos_addBranchingBlocks, neighborState, dir_addBranchingBlocks, pushDirection);
+        }
+        if (state.getBlock() instanceof net.minecraft.world.level.block.ChestBlock chestBlock) {
+            return chestBlock.isStickyToNeighbor(level, pos, state, neighborPos_addBranchingBlocks, neighborState, dir_addBranchingBlocks, pushDirection);
+        }
+
+        return canStickToEachOther(neighborState, state);
+    }
+    // Lumina end - Porting Carpet's features - custom sticky
 
     public PistonStructureResolver(Level world, BlockPos pos, Direction dir, boolean retracted) {
         this.level = world;
@@ -60,6 +88,14 @@ public class PistonStructureResolver {
     }
 
     private static boolean isSticky(BlockState state) {
+        // Lumina start - Porting Carpet's features - custom sticky
+        if (state.getBlock() instanceof net.minecraft.world.level.block.ChainBlock chainBlock){
+            return chainBlock.isSticky(state);
+        }
+        if (state.getBlock() instanceof net.minecraft.world.level.block.ChestBlock chestBlock){
+            return chestBlock.isSticky(state);
+        }
+        // Lumina end - Porting Carpet's features - custom sticky
         return state.is(Blocks.SLIME_BLOCK) || state.is(Blocks.HONEY_BLOCK);
     }
 
@@ -87,9 +123,13 @@ public class PistonStructureResolver {
                 while (isSticky(blockState)) {
                     BlockPos blockPos = pos.relative(this.pushDirection.getOpposite(), i);
                     BlockState blockState2 = blockState;
+                    // Lumina start - Porting Carpet's features - custom sticky
+                    pos_addBlockLine = blockPos.relative(pushDirection);
+                    behindPos_addBlockLine = blockPos;
+                    // Lumina end - Porting Carpet's features - custom sticky
                     blockState = this.level.getBlockState(blockPos);
                     if (blockState.isAir()
-                        || !canStickToEachOther(blockState2, blockState)
+                        || !onAddBlockLineCanStickToEachOther(blockState2, blockState) // Lumina - Porting Carpet's features - custom sticky
                         || !PistonBaseBlock.isPushable(blockState, this.level, blockPos, this.pushDirection, false, this.pushDirection.getOpposite())
                         || blockPos.equals(this.pistonPos)) {
                         break;
@@ -171,8 +211,12 @@ public class PistonStructureResolver {
         for (Direction direction : Direction.values()) {
             if (direction.getAxis() != this.pushDirection.getAxis()) {
                 BlockPos blockPos = pos.relative(direction);
+                // Lumina start - Porting Carpet's features - custom sticky
+                dir_addBranchingBlocks = direction;
+                neighborPos_addBranchingBlocks = blockPos;
+                // Lumina end - Porting Carpet's features - custom sticky
                 BlockState blockState2 = this.level.getBlockState(blockPos);
-                if (canStickToEachOther(blockState2, blockState) && !this.addBlockLine(blockPos, direction)) {
+                if (onAddBranchingBlocksCanStickToEachOther(blockState2, blockState, blockPos) && !this.addBlockLine(blockPos, direction)) { // Lumina - Porting Carpet's features - custom sticky
                     return false;
                 }
             }
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 8c0f332a1a0918f60226d969918ae7fe4fe74166..89376ebc5b0859b71b93261114b6463bc15611fc 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -192,7 +192,7 @@ public abstract class BlockBehaviour implements FeatureElement {
                     // CraftBukkit end
                 }
 
-                state.spawnAfterBreak(world, pos, ItemStack.EMPTY, flag);
+                state.spawnAfterBreak(world, pos, ItemStack.EMPTY, flag || org.leavesmc.lumina.carpet.CarpetConfig.configModule().xpFromExplosions); // Lumina - Porting Carpet's features - xp from explosions
                 state.getDrops(lootparams_a).forEach((itemstack) -> {
                     stackMerger.accept(itemstack, pos);
                 });
@@ -1163,6 +1163,11 @@ public abstract class BlockBehaviour implements FeatureElement {
         }
 
         public PushReaction getPistonPushReaction() {
+            // Lumina start - Porting Carpet's features - movable amethyst
+            if (org.leavesmc.lumina.carpet.CarpetConfig.configModule().movableAmethyst && getBlock() instanceof net.minecraft.world.level.block.BuddingAmethystBlock) {
+                return PushReaction.NORMAL;
+            }
+            // Lumina end - Porting Carpet's features - movable amethyst
             return !this.isDestroyable() ? PushReaction.BLOCK : this.pushReaction; // Paper - Protect Bedrock and End Portal/Frames from being destroyed
         }
 
diff --git a/src/main/java/net/minecraft/world/level/border/WorldBorder.java b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
index c2a0cd1c25b6d775b55f8c3aacca9837e35a5dfd..c18b733032b9ad51a552782d0afce525653e6e3f 100644
--- a/src/main/java/net/minecraft/world/level/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
@@ -220,6 +220,11 @@ public class WorldBorder {
         }
         // Paper end - Add worldborder events
         this.extent = (WorldBorder.BorderExtent) (fromSize == toSize ? new WorldBorder.StaticBorderExtent(toSize) : new WorldBorder.MovingBorderExtent(fromSize, toSize, time));
+        // Lumina - Porting Carpet's features - tick synced world borders
+        if (fromSize != toSize && org.leavesmc.lumina.carpet.CarpetConfig.configModule().tickSyncedWorldBorders) {
+            this.extent = new org.leavesmc.lumina.carpet.patches.TickSyncedBorderExtent((WorldBorder) (Object) this, time, fromSize, toSize);
+        }
+        // Lumina end - Porting Carpet's features - tick synced world borders
         Iterator iterator = this.getListeners().iterator();
 
         while (iterator.hasNext()) {
@@ -230,7 +235,7 @@ public class WorldBorder {
 
     }
 
-    protected List<BorderChangeListener> getListeners() {
+    public List<BorderChangeListener> getListeners() { // Lumina - Porting Carpet's features - tick synced world borders access
         return Lists.newArrayList(this.listeners);
     }
 
@@ -342,7 +347,7 @@ public class WorldBorder {
 
     }
 
-    private class StaticBorderExtent implements WorldBorder.BorderExtent {
+    public class StaticBorderExtent implements WorldBorder.BorderExtent {
 
         private final double size;
         private double minX;
@@ -351,7 +356,7 @@ public class WorldBorder {
         private double maxZ;
         private VoxelShape shape;
 
-        public StaticBorderExtent(final double d0) {
+        public StaticBorderExtent(final double d0) { // Lumina - Porting Carpet's features - tick synced world borders access
             this.size = d0;
             this.updateBox();
         }
@@ -430,7 +435,7 @@ public class WorldBorder {
         }
     }
 
-    private interface BorderExtent {
+    public interface BorderExtent { // Lumina - Porting Carpet's features - tick synced world borders access
 
         double getMinX();
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index f87abb22dd161b2b74401086de80dc95c9ac2dbb..df78cc9a7011938417c1ec42bdf711746d022040 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -63,7 +63,7 @@ public abstract class ChunkAccess implements BiomeManager.NoiseBiomeSource, Ligh
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final LongSet EMPTY_REFERENCE_SET = new LongOpenHashSet();
     protected final ShortList[] postProcessing;
-    private volatile boolean unsaved;
+    volatile boolean unsaved; // Lumina - Porting Carpet's features - private -> package-private
     private volatile boolean isLightCorrect;
     protected final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
     private long inhabitedTime;
@@ -376,6 +376,7 @@ public abstract class ChunkAccess implements BiomeManager.NoiseBiomeSource, Ligh
     public abstract void removeBlockEntity(BlockPos pos);
 
     public void markPosForPostprocessing(BlockPos pos) {
+        if (org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.SKIP_GENERATION_CHECKS.get()) return; // Lumina - Porting Carpet's features - Skip generation checks
         ChunkAccess.LOGGER.warn("Trying to mark a block for PostProcessing @ {}, but this operation is not supported.", pos);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 7f6dd454e0794739dc1861f768aaed86c484afe7..57ccfdb70d5c1edb1b952baa599c2552f943ed5f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -532,6 +532,12 @@ public abstract class ChunkGenerator {
 
         while (iterator.hasNext()) {
             Entry<Structure, LongSet> entry = (Entry) iterator.next();
+            // Lumina start - Porting Carpet's features - custome mob spawn
+            WeightedRandomList<MobSpawnSettings.SpawnerData> res = org.leavesmc.lumina.carpet.utils.SpawnOverrides.test(accessor, entry.getValue(), group, entry.getKey(), pos);
+            if (res != null) {
+                return res;
+            }
+            // Lumina end - Porting Carpet's features - custome mob spawn
             Structure structure = (Structure) entry.getKey();
             StructureSpawnOverride structurespawnoverride = (StructureSpawnOverride) structure.spawnOverrides().get(group);
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index b82e57fbcaa5aeabb81748ff2c5689a52079f6dd..b5228429d1791d7b0038ce549f250a117f654c11 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -100,6 +100,79 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
         this(world, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, (LevelChunkSection[]) null, (LevelChunk.PostLoadProcessor) null, (BlendingData) null);
     }
 
+    // Lumina start - Porting Carpet's features - fill updates
+    public BlockState setBlockStateWithBlockEntity(BlockPos blockPos_1, BlockState newBlockState, BlockEntity newBlockEntity, boolean boolean_1) {
+        int x = blockPos_1.getX() & 15;
+        int y = blockPos_1.getY();
+        int z = blockPos_1.getZ() & 15;
+        LevelChunkSection chunkSection = this.getSection(this.getSectionIndex(y));
+        if (chunkSection.hasOnlyAir()) {
+            if (newBlockState.isAir()) {
+                return null;
+            }
+        }
+
+        boolean boolean_2 = chunkSection.hasOnlyAir();
+        BlockState oldBlockState = chunkSection.setBlockState(x, y & 15, z, newBlockState);
+        if (oldBlockState == newBlockState) {
+            return null;
+        }
+        else {
+            Block newBlock = newBlockState.getBlock();
+            Block oldBlock = oldBlockState.getBlock();
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING)).update(x, y, z, newBlockState);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES)).update(x, y, z, newBlockState);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.OCEAN_FLOOR)).update(x, y, z, newBlockState);
+            ((Heightmap) this.heightmaps.get(Heightmap.Types.WORLD_SURFACE)).update(x, y, z, newBlockState);
+            boolean boolean_3 = chunkSection.hasOnlyAir();
+            if (boolean_2 != boolean_3) {
+                this.level.getChunkSource().getLightEngine().updateSectionStatus(blockPos_1, boolean_3);
+            }
+
+            if (!this.level.isClientSide) {
+                if (!(oldBlock instanceof net.minecraft.world.level.block.piston.MovingPistonBlock))//this is a movableTE special case, if condition wasn't there it would remove the blockentity that was carried for some reason
+                    oldBlockState.onRemove(this.level, blockPos_1, newBlockState, boolean_1);//this kills it
+            }
+            else if (oldBlock != newBlock && oldBlock instanceof EntityBlock) {
+                this.level.removeBlockEntity(blockPos_1);
+            }
+
+            if (chunkSection.getBlockState(x, y & 15, z).getBlock() != newBlock) {
+                return null;
+            }
+            else {
+                BlockEntity oldBlockEntity = null;
+                if (oldBlockState.hasBlockEntity()) {
+                    oldBlockEntity = this.getBlockEntity(blockPos_1, LevelChunk.EntityCreationType.CHECK);
+                    if (oldBlockEntity != null) {
+                        oldBlockEntity.setBlockState(oldBlockState);
+                        updateBlockEntityTicker(oldBlockEntity);
+                    }
+                }
+
+                if (oldBlockState.hasBlockEntity()) {
+                    if (newBlockEntity == null) {
+                        newBlockEntity = ((EntityBlock) newBlock).newBlockEntity(blockPos_1, newBlockState);
+                    }
+                    if (newBlockEntity != oldBlockEntity && newBlockEntity != null) {
+                        newBlockEntity.clearRemoved();
+                        this.level.setBlockEntity(newBlockEntity);
+                        newBlockEntity.setBlockState(newBlockState);
+                        updateBlockEntityTicker(newBlockEntity);
+                    }
+                }
+
+                if (!this.level.isClientSide) {
+                    newBlockState.onPlace(this.level, blockPos_1, oldBlockState, boolean_1); //This can call setblockstate! (e.g. hopper does)
+                }
+
+                this.unsaved = true; // shouldSave
+                return oldBlockState;
+            }
+        }
+    }
+    // Lumina end - Porting Carpet's features - fill updates
+
     public LevelChunk(Level world, ChunkPos pos, UpgradeData upgradeData, LevelChunkTicks<Block> blockTickScheduler, LevelChunkTicks<Fluid> fluidTickScheduler, long inhabitedTime, @Nullable LevelChunkSection[] sectionArrayInitializer, @Nullable LevelChunk.PostLoadProcessor entityLoader, @Nullable BlendingData blendingData) {
         super(pos, upgradeData, world, net.minecraft.server.MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.BIOME), inhabitedTime, sectionArrayInitializer, blendingData); // Paper - Anti-Xray - The world isn't ready yet, use server singleton for registry
         this.tickersInLevel = Maps.newHashMap();
@@ -425,7 +498,16 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
                 boolean flag3 = iblockdata1.hasBlockEntity();
 
                 if (!this.level.isClientSide && !this.level.getCurrentWorldData().isBlockPlaceCancelled) { // Paper - prevent calling cleanup logic when undoing a block place upon a cancelled BlockPlaceEvent // Folia - region threading
-                    iblockdata1.onRemove(this.level, blockposition, iblockdata, flag);
+                    // Lumina start - Porting Carpet's features - fill updates
+                    if (org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) { // doing due dilligence from AbstractBlock onStateReplaced{
+                        if (iblockdata1.hasBlockEntity() && !iblockdata1.is(iblockdata.getBlock())) {
+                            this.level.removeBlockEntity(blockposition);
+                        }
+                    }
+                    else {
+                        iblockdata1.onRemove(this.level, blockposition, iblockdata, flag);
+                    }
+                    // Lumina end - Porting Carpet's features - fill updates
                 } else if (!iblockdata1.is(block) && flag3) {
                     this.removeBlockEntity(blockposition);
                 }
@@ -435,11 +517,13 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
                 } else {
                     // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
                     if (!this.level.isClientSide && doPlace && (!this.level.getCurrentWorldData().captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // Folia - region threading
-                        iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
+                        if (!org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                     }
 
                     if (iblockdata.hasBlockEntity()) {
-                        BlockEntity tileentity = this.getBlockEntity(blockposition, LevelChunk.EntityCreationType.CHECK);
+                        BlockEntity tileentity =
+                                // (!org.leavesmc.lumina.carpet.CarpetConfig.configModule().movableBlockEntities) ? this.getBlockEntity(blockposition, LevelChunk.EntityCreationType.CHECK) :
+                                this.level.getBlockEntity(blockposition); // Lumina - Porting Carpet's features - movable block entities // TODO
 
                         if (tileentity != null && !tileentity.isValidBlockState(iblockdata)) {
                             LevelChunk.LOGGER.warn("Found mismatched block entity @ {}: type = {}, state = {}", new Object[]{blockposition, tileentity.getType().builtInRegistryHolder().key().location(), iblockdata});
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java
index 7bc5ff8eb1174834dcc27363af4a5cef19017b3d..44d75c68eec02c6c6407352b63e32ba6081eb1e5 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/CoralFeature.java
@@ -22,6 +22,12 @@ public abstract class CoralFeature extends Feature<NoneFeatureConfiguration> {
         super(configCodec);
     }
 
+    // Lumina start - Porting Carpet's features - renewable coral
+    public boolean growSpecific(net.minecraft.world.level.Level worldIn, RandomSource random, BlockPos pos, BlockState blockUnder) {
+        return placeFeature(worldIn, random, pos, blockUnder);
+    }
+    // Lumina end - Porting Carpet's features - renewable coral
+
     @Override
     public boolean place(FeaturePlaceContext<NoneFeatureConfiguration> context) {
         RandomSource randomSource = context.random();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java
index 4ccb92ca80752eb614114b554f65bb8427785d41..47fe3f1a6b45dc2912b0e0d488d3363055ef1953 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/HugeFungusFeature.java
@@ -49,8 +49,14 @@ public class HugeFungusFeature extends Feature<HugeFungusConfiguration> {
                 }
             }
 
+            // Lumina start - Porting Carpet's features - thick fungus growth
             boolean bl = !hugeFungusConfiguration.planted && randomSource.nextFloat() < 0.06F;
             worldGenLevel.setBlock(blockPos, Blocks.AIR.defaultBlockState(), 4);
+            boolean natural = !hugeFungusConfiguration.planted;
+            bl = natural && bl ||
+                    !natural && (org.leavesmc.lumina.carpet.CarpetConfig.configModule().thickFungusGrowth == org.leavesmc.lumina.carpet.CarpetConfigModule.FungusGrowthMode.ALL ||
+                            org.leavesmc.lumina.carpet.CarpetConfig.configModule().thickFungusGrowth == org.leavesmc.lumina.carpet.CarpetConfigModule.FungusGrowthMode.RANDOM && randomSource.nextFloat() < 0.06F);
+            // Lumina end - Porting Carpet's features - thick fungus growth
             this.placeStem(worldGenLevel, randomSource, hugeFungusConfiguration, blockPos2, i, bl);
             this.placeHat(worldGenLevel, randomSource, hugeFungusConfiguration, blockPos2, i, bl);
             return true;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java b/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java
index 05cca3aef35f7ab016790a7ea2328772fcf7bf38..e0f52f0976260e2e0aacdbad17618cb725c15600 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/pieces/PieceGeneratorSupplier.java
@@ -23,7 +23,7 @@ public interface PieceGeneratorSupplier<C extends FeatureConfiguration> {
         Predicate<PieceGeneratorSupplier.Context<C>> predicate, PieceGenerator<C> generator
     ) {
         Optional<PieceGenerator<C>> optional = Optional.of(generator);
-        return context -> predicate.test(context) ? optional : Optional.empty();
+        return context -> (org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.SKIP_GENERATION_CHECKS.get() || predicate.test(context)) ? optional : Optional.empty(); // Lumina - Porting Carpet's features - skip generation checks
     }
 
     static <C extends FeatureConfiguration> Predicate<PieceGeneratorSupplier.Context<C>> checkForBiomeOnTop(Heightmap.Types heightmapType) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
index d35b731751e851bee531aa5e7996557658ba6fae..7f479f011d25b658ca245e39b70db49ca3010430 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
@@ -396,7 +396,7 @@ public class StructureTemplate {
                 }
 
                 if (j <= i1) {
-                    if (!placementData.getKnownShape()) {
+                    if (!placementData.getKnownShape() || org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) { // Lumina - Porting Carpet's features - fill updates
                         BitSetDiscreteVoxelShape voxelshapebitset = new BitSetDiscreteVoxelShape(i1 - j + 1, j1 - k + 1, k1 - l + 1);
                         int i2 = j;
                         int j2 = k;
@@ -420,7 +420,7 @@ public class StructureTemplate {
                         Pair<BlockPos, CompoundTag> pair1 = (Pair) iterator1.next();
                         BlockPos blockposition6 = (BlockPos) pair1.getFirst();
 
-                        if (!placementData.getKnownShape()) {
+                        if (!placementData.getKnownShape() || org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) { // Lumina - Porting Carpet's features - fill updates
                             iblockdata1 = world.getBlockState(blockposition6);
                             BlockState iblockdata2 = Block.updateFromNeighbourShapes(iblockdata1, world, blockposition6);
 
@@ -428,7 +428,7 @@ public class StructureTemplate {
                                 world.setBlock(blockposition6, iblockdata2, flags & -2 | 16);
                             }
 
-                            world.blockUpdated(blockposition6, iblockdata2.getBlock());
+                            if (!org.leavesmc.lumina.carpet.CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.get()) world.blockUpdated(blockposition6, iblockdata2.getBlock());
                         }
 
                         if (pair1.getSecond() != null) {
diff --git a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
index f4fbcbb8ff6d2677af1a02a0801a323c06dce9b1..c076b50883c71b8a80b580a70b2b7ec16d438450 100644
--- a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
@@ -491,7 +491,7 @@ public abstract class FlowingFluid extends Fluid {
     private static boolean canHoldAnyFluid(BlockState state) {
         Block block = state.getBlock();
 
-        return block instanceof LiquidBlockContainer ? true : (state.blocksMotion() ? false : !(block instanceof DoorBlock) && !state.is(BlockTags.SIGNS) && !state.is(Blocks.LADDER) && !state.is(Blocks.SUGAR_CANE) && !state.is(Blocks.BUBBLE_COLUMN) && !state.is(Blocks.NETHER_PORTAL) && !state.is(Blocks.END_PORTAL) && !state.is(Blocks.END_GATEWAY) && !state.is(Blocks.STRUCTURE_VOID));
+        return block instanceof LiquidBlockContainer ? true : (state.blocksMotion() ? false : !(block instanceof DoorBlock) && !state.is(BlockTags.SIGNS) && !state.is(Blocks.LADDER) && !state.is(Blocks.SUGAR_CANE) && !state.is(Blocks.BUBBLE_COLUMN) && !state.is(Blocks.NETHER_PORTAL) && !state.is(Blocks.END_PORTAL) && !state.is(Blocks.END_GATEWAY) && !state.is(Blocks.STRUCTURE_VOID)) && !((org.leavesmc.lumina.carpet.CarpetConfig.configModule().liquidDamageDisabled) && (state.isAir() || state.is(Blocks.WATER) || state.is(Blocks.LAVA)));
     }
 
     private static boolean canHoldFluid(BlockGetter world, BlockPos pos, BlockState state, Fluid fluid) {
diff --git a/src/main/java/net/minecraft/world/level/material/LavaFluid.java b/src/main/java/net/minecraft/world/level/material/LavaFluid.java
index 884db3e64cb22ed765beec8f11ea309fcf810207..b3cf16bb92f25f6094aa01feeb1878be4535afd1 100644
--- a/src/main/java/net/minecraft/world/level/material/LavaFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/LavaFluid.java
@@ -211,6 +211,13 @@ public abstract class LavaFluid extends FlowingFluid {
 
             if (this.is(FluidTags.LAVA) && fluid1.is(FluidTags.WATER)) {
                 if (state.getBlock() instanceof LiquidBlock) {
+                    // Lumina start - Porting Carpet's features - renewable deepslate
+                    if(org.leavesmc.lumina.carpet.CarpetConfig.configModule().renewableDeepslate && ((Level)world).dimension() == Level.OVERWORLD && pos.getY() < 0) {
+                        world.setBlock(pos, Blocks.DEEPSLATE.defaultBlockState(), 3);
+                        this.fizz(world, pos);
+                        return;
+                    }
+                    // Lumina end - Porting Carpet's features - renewable deepslate
                     // CraftBukkit start
                     if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(world.getMinecraftWorld(), pos, Blocks.STONE.defaultBlockState(), 3)) {
                         return;
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index d1d8360f1ae931b22e1712b498ae66b7649be90d..a49f7ed9e8daf10a7076c27d6f71edfd55d1aeb1 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -16,10 +16,10 @@ import org.slf4j.Logger;
 public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
-    private final int maxChainedNeighborUpdates;
+    public final int maxChainedNeighborUpdates; // Lumina - Porting Carpet's features - access
     private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
     private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
-    private int count = 0;
+    public int count = 0; // Lumina - Porting Carpet's features - access
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
         this.level = world;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 8048e644cf477483a8beb9b00c0590def98b93ee..c7df263d46383e3743b8650f3c082cca42d44162 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -22,19 +22,7 @@ import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.net.InetAddress;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
 import java.util.function.Consumer;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -258,6 +246,7 @@ import org.bukkit.scoreboard.Criteria;
 import org.bukkit.structure.StructureManager;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.jetbrains.annotations.NotNull;
 import org.yaml.snakeyaml.LoaderOptions;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
diff --git a/src/main/java/org/leavesmc/leaves/protocol/CarpetServerProtocol.java b/src/main/java/org/leavesmc/leaves/protocol/CarpetServerProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..0939faf78ea163984a7df2f77579a8c6dfe9ec04
--- /dev/null
+++ b/src/main/java/org/leavesmc/leaves/protocol/CarpetServerProtocol.java
@@ -0,0 +1,127 @@
+package org.leavesmc.leaves.protocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.leaves.protocol.core.LeavesCustomPayload;
+import org.leavesmc.leaves.protocol.core.LeavesProtocol;
+import org.leavesmc.leaves.protocol.core.ProtocolHandler;
+import org.leavesmc.leaves.protocol.core.ProtocolUtils;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.config.LuminaConfig;
+
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+@LeavesProtocol(namespace = "carpet")
+public class CarpetServerProtocol {
+
+    public static final String PROTOCOL_ID = "carpet";
+    public static final String VERSION = "leaves-carpet-1.0.0";
+
+    private static final ResourceLocation HELLO_ID = CarpetServerProtocol.id("hello");
+
+    private static final String HI = "69";
+    private static final String HELLO = "420";
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    @ProtocolHandler.PlayerJoin
+    public static void onPlayerJoin(ServerPlayer player) {
+        if (LuminaConfig.configModule().protocol.carpetProtocol) {
+            CompoundTag data = new CompoundTag();
+            data.putString(HI, VERSION);
+            ProtocolUtils.sendPayloadPacket(player, new CarpetPayload(data));
+            CarpetServer.onPlayerLoggedIn(player);
+        }
+    }
+
+    @ProtocolHandler.PayloadReceiver(payload = CarpetPayload.class, payloadId = "hello")
+    private static void handleHello(@NotNull ServerPlayer player, @NotNull CarpetServerProtocol.CarpetPayload payload) {
+        if (LuminaConfig.configModule().protocol.carpetProtocol) {
+            if (payload.nbt.contains(HELLO)) {
+                CarpetServer.LOGGER.info("Player {} joined with carpet {}", player.getScoreboardName(), payload.nbt.getString(HELLO));
+                CompoundTag data = new CompoundTag();
+                CarpetRules.write(data);
+                ProtocolUtils.sendPayloadPacket(player, new CarpetPayload(data));
+            }
+        }
+    }
+
+    @ProtocolHandler.Ticker
+    private static void tick() {
+        CarpetServer.tick(MinecraftServer.getServer());
+    }
+
+    public static class CarpetRules {
+
+        private static final Map<String, CarpetRule> rules = new HashMap<>();
+
+        public static void write(@NotNull CompoundTag tag) {
+            CompoundTag rulesNbt = new CompoundTag();
+            rules.values().forEach(rule -> rule.writeNBT(rulesNbt));
+
+            tag.put("Rules", rulesNbt);
+        }
+
+        public static void register(CarpetRule rule) {
+            rules.put(rule.name, rule);
+        }
+    }
+
+    public record CarpetRule(String identifier, String name, String value) {
+
+        @NotNull
+        @Contract("_, _, _ -> new")
+        public static CarpetRule of(String identifier, String name, Enum<?> value) {
+            return new CarpetRule(identifier, name, value.name().toLowerCase(Locale.ROOT));
+        }
+
+        @NotNull
+        @Contract("_, _, _ -> new")
+        public static CarpetRule of(String identifier, String name, boolean value) {
+            return new CarpetRule(identifier, name, Boolean.toString(value));
+        }
+
+        public void writeNBT(@NotNull CompoundTag rules) {
+            CompoundTag rule = new CompoundTag();
+            String key = name;
+
+            while (rules.contains(key)) {
+                key = key + "2";
+            }
+
+            rule.putString("Value", value);
+            rule.putString("Manager", identifier);
+            rule.putString("Rule", name);
+            rules.put(key, rule);
+        }
+    }
+
+    public record CarpetPayload(CompoundTag nbt) implements LeavesCustomPayload<CarpetPayload> {
+
+        @New
+        public CarpetPayload(ResourceLocation location, FriendlyByteBuf buf) {
+            this(buf.readNbt());
+        }
+
+        @Override
+        public void write(FriendlyByteBuf buf) {
+            buf.writeNbt(nbt);
+        }
+
+        @Override
+        @NotNull
+        public ResourceLocation id() {
+            return HELLO_ID;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
index 8d6de4b557dfb5fdef7d246f15872b9f2d7bdc60..d33d8d096ab8b4fe1dbc870edc64addba1d3fc5f 100644
--- a/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetConfigModule.java
@@ -36,6 +36,7 @@ public class CarpetConfigModule {
     @Comment("Players absorb XP instantly, without delay")
     public boolean xpNoCooldown = false;
 
+    // Customize
     @Validate(ShulkerBoxValidator.class)
     @Comment("""
             When set more than 1, empty shulker boxes can stack when thrown on the ground,
@@ -155,27 +156,6 @@ public class CarpetConfigModule {
             that scans the area around the block for potential spawnable spots""")
     public boolean commandPerimeterInfo = true;
 
-    @Comment("Enables /player command to control/spawn players")
-    public boolean commandPlayer = true;
-
-    @Comment("Spawn offline players in online mode if online-mode player with specified name does not exist")
-    public boolean allowSpawningOfflinePlayers = true;
-
-    @Comment("Allows listing fake players on the multiplayer screen")
-    public boolean allowListingFakePlayers = false;
-
-    @Comment("""
-            Add a markerName prefix for fake players spawned with /player command
-            Which can prevent summoning fake player with illegal names and make player list look nicer
-            Set it to #none to stop adding a prefix""")
-    public String fakePlayerNamePrefix = "#none";
-
-    @Comment("""
-            Add a markerName suffix for fake players spawned with /player command
-            Which can prevent summoning fake player with illegal names and make player list look nicer
-            Set it to #none to stop adding a suffix""")
-    public String fakePlayerNameSuffix = "#none";
-
     @Comment("Allows to track mobs AI via /track command")
     public boolean commandTrackAI = true;
 
@@ -284,7 +264,7 @@ public class CarpetConfigModule {
     @Comment("""
             Makes world borders move based on in game time instead of real time
             This has the effect that when the tick rate changes the world border speed also changes proportional to it""")
-    public boolean tickSyncedWorldBorders = false;
+    public boolean tickSyncedWorldBorders = false; // TODO
 
     // refers to "[MC-215169](https://bugs.mojang.com/browse/MC-215169)." - unconfirmed yet that its a java bug
     @Comment("""
@@ -306,17 +286,17 @@ public class CarpetConfigModule {
         }
     }
 
-    public static class TNTRandomRangeValidator extends Validator<Double> {
-        @Override
-        public boolean validate(Double newValue, Double oldValue) {
-            return newValue == -1 || newValue >= 0;
-        }
-
-        @Override
-        public String getErrorMessage(Double newValue) {
-            return "Value can't be negative, or -1, but got " + newValue;
-        }
-    }
+    // public static class TNTRandomRangeValidator extends Validator<Double> {
+    //     @Override
+    //     public boolean validate(Double newValue, Double oldValue) {
+    //         return newValue == -1 || newValue >= 0;
+    //     }
+    //
+    //     @Override
+    //     public String getErrorMessage(Double newValue) {
+    //         return "Value can't be negative, or -1, but got " + newValue;
+    //     }
+    // }
 
     public static class TNTAngleValidator extends Validator<Double> {
         @Override
@@ -424,7 +404,7 @@ public class CarpetConfigModule {
         public boolean validate(String newValue, String oldValue) {
             Optional<Block> ignoredBlock = MinecraftServer.getServer()
                     .registryAccess()
-                    .registryOrThrow(Registries.BLOCK)
+                    .lookupOrThrow(Registries.BLOCK)
                     .getOptional(ResourceLocation.tryParse(newValue));
             if (ignoredBlock.isEmpty()) {
                 return false;
diff --git a/src/main/java/org/leavesmc/lumina/carpet/CarpetServer.java b/src/main/java/org/leavesmc/lumina/carpet/CarpetServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ea101f28d97b0bc7635b4e3ace42784503835b8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/CarpetServer.java
@@ -0,0 +1,141 @@
+package org.leavesmc.lumina.carpet;
+
+import com.mojang.logging.LogUtils;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.InternalJavaPluginFactory;
+import org.leavesmc.lumina.carpet.command.*;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import org.leavesmc.lumina.carpet.logging.HUDController;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.script.utils.ParticleParser;
+import org.leavesmc.lumina.carpet.utils.MobAI;
+import org.leavesmc.lumina.carpet.utils.SpawnReporter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CarpetServer {
+    public static Plugin PLUGIN = InternalJavaPluginFactory.create("Carpet");
+    public static final Logger LOGGER = LoggerFactory.getLogger("Carpet");
+    // public static final List<CarpetExtension> extensions = new ArrayList<>(); // TODO
+
+    // public static void manageExtension(CarpetExtension extension) {
+    //     extensions.add(extension);
+    //     // Stop the stupid practice of extensions mixing into Carpet just to register themselves
+    //     if (StackWalker.getInstance().walk(stream -> stream.skip(1)
+    //             .anyMatch(el -> el.getClassName() == CarpetServer.class.getName())))
+    //     {
+    //         CarpetSettings.LOG.warn("""
+    //                 Extension '%s' is registering itself using a mixin into Carpet instead of a regular ModInitializer!
+    //                 This is stupid and will crash the game in future versions!""".formatted(extension.getClass().getSimpleName()));
+    //     }
+    // } // TODO
+
+    public static void onGameStarted() {
+        CarpetServer.registerCarpetCommands();
+        // settingsManager = new carpet.settings.SettingsManager(CarpetSettings.carpetVersion, "carpet", "Carpet Mod");
+        // settingsManager.parseSettingsClass(CarpetSettings.class);
+        // extensions.forEach(CarpetExtension::onGameStarted); // TODO
+    }
+
+    public static void onServerLoaded(MinecraftServer server) {
+        // should not be needed - that bit needs refactoring, but not now.
+        SpawnReporter.resetSpawnStats(server, true);
+
+        // forEachManager(sm -> sm.attachServer(server));
+        // extensions.forEach(e -> e.onServerLoaded(server)); // TODO
+        MobAI.resetTrackers();
+        LoggerRegistry.initLoggers();
+    }
+
+    public static void onServerLoadedWorlds(MinecraftServer server) {
+        HopperCounter.resetAll(server, true);
+        // extensions.forEach(e -> e.onServerLoadedWorlds(server)); // TODO
+    }
+
+    public static void tick(MinecraftServer server) {
+        HUDController.update_hud(server);
+
+        // in case something happens
+        CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(false);
+
+        // extensions.forEach(e -> e.onTick(server)); // TODO
+    }
+
+    public static void registerCarpetCommands() {
+        if (CarpetConfig.configModule() == null) {
+            return;
+        }
+        if (CarpetConfig.configModule().commandTrackAI) {
+            TrackCommand.register();
+        }
+        if (CarpetConfig.configModule().commandDistance) {
+            DistanceCommand.register();
+        }
+        if (CarpetConfig.configModule().commandPerimeterInfo) {
+            PerimeterInfoCommand.register();
+        }
+        if (CarpetConfig.configModule().commandInfo) {
+            InfoCommand.register();
+        }
+        if (CarpetConfig.configModule().commandLog) {
+            LogCommand.register();
+        }
+        if (CarpetConfig.configModule().commandSpawn) {
+            SpawnCommand.register();
+        }
+        if (CarpetConfig.configModule().hopperCounters) {
+            CounterCommand.register();
+        }
+        CarpetCommand.register();
+        PlayerCommand.register();
+    }
+
+    public static void onPlayerLoggedIn(ServerPlayer player) {
+        LoggerRegistry.playerConnected(player);
+        // extensions.forEach(e -> e.onPlayerLoggedIn(player)); // TODO
+    }
+
+    public static void onPlayerLoggedOut(ServerPlayer player, Component reason) {
+        LoggerRegistry.playerDisconnected(player);
+        // extensions.forEach(e -> e.onPlayerLoggedOut(player)); // TODO
+    }
+
+    public static void onServerClosed(MinecraftServer server) {
+        LoggerRegistry.stopLoggers();
+        HUDController.resetScarpetHUDs();
+        ParticleParser.resetCache();
+        // extensions.forEach(e -> e.onServerClosed(server)); // TODO
+    }
+
+    // not API
+    // carpet's included
+    // public static void forEachManager(Consumer<SettingsManager> consumer) {
+    //     consumer.accept(settingsManager);
+    //     for (CarpetExtension e : extensions) {
+    //         SettingsManager manager = e.extensionSettingsManager();
+    //         if (manager != null) {
+    //             consumer.accept(manager);
+    //         }
+    //     }
+    // } // TODO
+
+    public static void registerExtensionLoggers() {
+        // extensions.forEach(CarpetExtension::registerLoggers); // TODO
+    }
+
+    public static void onReload(MinecraftServer server) {
+        // extensions.forEach(e -> e.onReload(server)); // TODO
+    }
+
+    // private static final Set<CarpetExtension> warnedOutdatedManagerProviders = new HashSet<>(); // TODO
+
+    // static void warnOutdatedManager(CarpetExtension ext) {
+    //     if (warnedOutdatedManagerProviders.add(ext))
+    //         CarpetSettings.LOG.warn("""
+    //                 %s is providing a SettingsManager from an outdated method in CarpetExtension!
+    //                 This behaviour will not work in later Carpet versions and the manager won't be registered!""".formatted(ext.getClass().getName()));
+    // } // TODO
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java b/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
index f673832378af9529a2eb6fe18c25cda7398a5f61..346d2fa7515f93af17ac9800bb2ceec2ca4e23df 100644
--- a/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
+++ b/src/main/java/org/leavesmc/lumina/carpet/command/PerimeterInfoCommand.java
@@ -7,6 +7,8 @@ import dev.jorel.commandapi.arguments.LocationType;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntitySpawnReason;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.Mob;
 import org.bukkit.Bukkit;
@@ -51,8 +53,8 @@ public class PerimeterInfoCommand {
         BlockPos blockPos = toBlockPos(pos);
         if (mobId != null) {
             nbtTagCompound.putString("id", mobId);
-            net.minecraft.world.entity.Entity baseEntity = EntityType.loadEntityRecursive(nbtTagCompound, level, (entity1x) -> {
-                entity1x.moveTo(new BlockPos(blockPos.getX(), level.getMinBuildHeight() - 10, blockPos.getZ()), entity1x.getYRot(), entity1x.getXRot());
+            Entity baseEntity = EntityType.loadEntityRecursive(nbtTagCompound, level, EntitySpawnReason.COMMAND, (entity1x) -> {
+                entity1x.moveTo(new BlockPos(blockPos.getX(), level.getMinY() - 10, blockPos.getZ()), entity1x.getYRot(), entity1x.getXRot());
                 return !level.addWithUUID(entity1x) ? null : entity1x;
             });
             if (!(baseEntity instanceof Mob)) {
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/BlockRotator.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/BlockRotator.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d5ba0572bdeeb30c15ae04a0523a7812886a6d9
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/BlockRotator.java
@@ -0,0 +1,164 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.dispenser.BlockSource;
+import net.minecraft.core.dispenser.DispenseItemBehavior;
+import net.minecraft.core.dispenser.OptionalDispenseItemBehavior;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.BaseRailBlock;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.DirectionalBlock;
+import net.minecraft.world.level.block.DispenserBlock;
+import net.minecraft.world.level.block.EndRodBlock;
+import net.minecraft.world.level.block.HopperBlock;
+import net.minecraft.world.level.block.HorizontalDirectionalBlock;
+import net.minecraft.world.level.block.ObserverBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.piston.PistonBaseBlock;
+import net.minecraft.world.level.block.piston.PistonStructureResolver;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+public class BlockRotator {
+    public static boolean flipBlockWithCactus(BlockState state, Level world, Player player, InteractionHand hand, BlockHitResult hit) {
+        if (!player.getAbilities().mayBuild || !CarpetConfig.configModule().flippinCactus || !playerHoldsCactusMainhand(player)) {
+            return false;
+        }
+        CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(true);
+        boolean retval = flipBlock(state, world, player, hand, hit);
+        CarpetConfig.INSTANCE.IMPENDING_FILL_SKIP_UPDATES.set(false);
+        return retval;
+    }
+
+    public static ItemStack dispenserRotate(BlockSource source, ItemStack stack) {
+        Direction sourceFace = source.state().getValue(DispenserBlock.FACING);
+        Level world = source.level();
+        BlockPos blockpos = source.pos().relative(sourceFace); // offset
+        BlockState blockstate = world.getBlockState(blockpos);
+        Block block = blockstate.getBlock();
+
+        // Block rotation for blocks that can be placed in all 6 or 4 rotations.
+        if (block instanceof DirectionalBlock || block instanceof DispenserBlock) {
+            Direction face = blockstate.getValue(DirectionalBlock.FACING);
+            if (block instanceof PistonBaseBlock baseBlock && (
+                    blockstate.getValue(PistonBaseBlock.EXTENDED)
+                            || (baseBlock.publicShouldExtend(world, blockpos, face) && (new PistonStructureResolver(world, blockpos, face, true)).resolve())
+            )
+            ) {
+                return stack;
+            }
+
+            Direction rotatedFace = face.getClockWise(sourceFace.getAxis());
+            if (sourceFace.get3DDataValue() % 2 == 0 || rotatedFace == face) {   // Flip to make blocks always rotate clockwise relative to the dispenser
+                // when index is equal to zero. when index is equal to zero the dispenser is in the opposite direction.
+                rotatedFace = rotatedFace.getOpposite();
+            }
+            world.setBlock(blockpos, blockstate.setValue(DirectionalBlock.FACING, rotatedFace), 3);
+        } else if (block instanceof HorizontalDirectionalBlock) // Block rotation for blocks that can be placed in only 4 horizontal rotations.
+        {
+            if (block instanceof BedBlock)
+                return stack;
+            Direction face = blockstate.getValue(HorizontalDirectionalBlock.FACING).getClockWise(Direction.Axis.Y);
+
+            if (sourceFace == Direction.DOWN) { // same as above.
+                face = face.getOpposite();
+            }
+            world.setBlock(blockpos, blockstate.setValue(HorizontalDirectionalBlock.FACING, face), 3);
+        } else if (block == Blocks.HOPPER) {
+            Direction face = blockstate.getValue(HopperBlock.FACING);
+            if (face != Direction.DOWN) {
+                face = face.getClockWise(Direction.Axis.Y);
+                world.setBlock(blockpos, blockstate.setValue(HopperBlock.FACING, face), 3);
+            }
+        }
+        // Send block update to the block that just have been rotated.
+        world.neighborChanged(blockpos, block, null);
+
+        return stack;
+    }
+
+    public static boolean flipBlock(BlockState state, Level world, Player player, InteractionHand hand, BlockHitResult hit) {
+        Block block = state.getBlock();
+        BlockPos pos = hit.getBlockPos();
+        Vec3 hitVec = hit.getLocation().subtract(pos.getX(), pos.getY(), pos.getZ());
+        Direction facing = hit.getDirection();
+        BlockState newState = null;
+        if ((block instanceof HorizontalDirectionalBlock || block instanceof BaseRailBlock) && !(block instanceof BedBlock)) {
+            newState = state.rotate(Rotation.CLOCKWISE_90);
+        } else if (block instanceof ObserverBlock || block instanceof EndRodBlock) {
+            newState = state.setValue(DirectionalBlock.FACING, state.getValue(DirectionalBlock.FACING).getOpposite());
+        } else if (block instanceof DispenserBlock) {
+            newState = state.setValue(DispenserBlock.FACING, state.getValue(DispenserBlock.FACING).getOpposite());
+        } else if (block instanceof PistonBaseBlock) {
+            if (!(state.getValue(PistonBaseBlock.EXTENDED)))
+                newState = state.setValue(DirectionalBlock.FACING, state.getValue(DirectionalBlock.FACING).getOpposite());
+        } else if (block instanceof SlabBlock) {
+            if (state.getValue(SlabBlock.TYPE) != SlabType.DOUBLE) {
+                newState = state.setValue(SlabBlock.TYPE, state.getValue(SlabBlock.TYPE) == SlabType.TOP ? SlabType.BOTTOM : SlabType.TOP);
+            }
+        } else if (block instanceof HopperBlock) {
+            if (state.getValue(HopperBlock.FACING) != Direction.DOWN) {
+                newState = state.setValue(HopperBlock.FACING, state.getValue(HopperBlock.FACING).getClockWise());
+            }
+        } else if (block instanceof StairBlock) {
+            if ((facing == Direction.UP && hitVec.y == 1.0f) || (facing == Direction.DOWN && hitVec.y == 0.0f)) {
+                newState = state.setValue(StairBlock.HALF, state.getValue(StairBlock.HALF) == Half.TOP ? Half.BOTTOM : Half.TOP);
+            } else {
+                boolean turnCounterClockwise = switch (facing) {
+                    case NORTH -> (hitVec.x <= 0.5);
+                    case SOUTH -> !(hitVec.x <= 0.5);
+                    case EAST -> (hitVec.z <= 0.5);
+                    case WEST -> !(hitVec.z <= 0.5);
+                    default -> false;
+                };
+                newState = state.rotate(turnCounterClockwise ? Rotation.COUNTERCLOCKWISE_90 : Rotation.CLOCKWISE_90);
+            }
+        } else if (block instanceof RotatedPillarBlock) {
+            newState = state.setValue(RotatedPillarBlock.AXIS, switch (state.getValue(RotatedPillarBlock.AXIS)) {
+                case X -> Direction.Axis.Z;
+                case Y -> Direction.Axis.X;
+                case Z -> Direction.Axis.Y;
+            });
+        }
+        if (newState != null) {
+            world.setBlock(pos, newState, Block.UPDATE_CLIENTS | 1024); // no constant matching 1024 in Block, what does this do?
+            world.setBlocksDirty(pos, state, newState);
+            return true;
+        }
+        return false;
+    }
+
+    private static boolean playerHoldsCactusMainhand(Player playerIn) {
+        return playerIn.getMainHandItem().getItem() == Items.CACTUS;
+    }
+
+    public static boolean flippinEligibility(Entity entity) {
+        return CarpetConfig.configModule().flippinCactus && entity instanceof Player p && p.getOffhandItem().getItem() == Items.CACTUS;
+    }
+
+    public static class CactusDispenserBehaviour extends OptionalDispenseItemBehavior implements DispenseItemBehavior {
+        @Override
+        protected ItemStack execute(BlockSource source, ItemStack stack) {
+            if (CarpetConfig.configModule().rotatorBlock) {
+                return BlockRotator.dispenserRotate(source, stack);
+            } else {
+                return super.execute(source, stack);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/CarpetTaintedList.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/CarpetTaintedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0eb90b1f501d9d702d9d08e09ba7c0e2108fba2
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/CarpetTaintedList.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class CarpetTaintedList<E> extends ArrayList<E>
+{
+    public CarpetTaintedList(final List<E> list)
+    {
+        super(list);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/FertilizableCoral.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/FertilizableCoral.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a68e7be02613ac207fe4d5c0122cf746a3bac3d
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/FertilizableCoral.java
@@ -0,0 +1,77 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.HolderSet;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.level.block.BaseCoralPlantTypeBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.BonemealableBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.levelgen.feature.CoralClawFeature;
+import net.minecraft.world.level.levelgen.feature.CoralFeature;
+import net.minecraft.world.level.levelgen.feature.CoralMushroomFeature;
+import net.minecraft.world.level.levelgen.feature.CoralTreeFeature;
+import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
+import net.minecraft.world.level.material.MapColor;
+
+/**
+ * Deduplicates logic for the different behaviors of the {@code renewableCoral} rule
+ */
+public interface FertilizableCoral extends BonemealableBlock {
+    /**
+     * @return Whether the rule for this behavior is enabled
+     */
+    boolean isEnabled();
+
+    @Override
+    public default boolean isValidBonemealTarget(LevelReader world, BlockPos pos, BlockState state) {
+        return isEnabled()
+                && state.getValue(BaseCoralPlantTypeBlock.WATERLOGGED)
+                && world.getFluidState(pos.above()).is(FluidTags.WATER);
+    }
+
+    @Override
+    public default boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return random.nextFloat() < 0.15D;
+    }
+
+    @Override
+    public default void performBonemeal(ServerLevel worldIn, RandomSource random, BlockPos pos, BlockState blockUnder) {
+        int variant = random.nextInt(3);
+        CoralFeature coral = switch (variant) {
+            case 0 -> new CoralClawFeature(NoneFeatureConfiguration.CODEC);
+            case 1 -> new CoralTreeFeature(NoneFeatureConfiguration.CODEC);
+            default -> new CoralMushroomFeature(NoneFeatureConfiguration.CODEC);
+        };
+
+        MapColor color = blockUnder.getMapColor(worldIn, pos);
+        BlockState properBlock = blockUnder;
+        HolderSet.Named<Block> coralBlocks = worldIn.registryAccess().lookupOrThrow(Registries.BLOCK).get(BlockTags.CORAL_BLOCKS).orElseThrow();
+        for (Holder<Block> block : coralBlocks) {
+            properBlock = block.value().defaultBlockState();
+            if (properBlock.getMapColor(worldIn, pos) == color) {
+                break;
+            }
+        }
+        worldIn.setBlock(pos, Blocks.WATER.defaultBlockState(), Block.UPDATE_NONE);
+
+        if (!coral.growSpecific(worldIn, random, pos, properBlock)) {
+            worldIn.setBlock(pos, blockUnder, 3);
+        } else {
+            if (worldIn.random.nextInt(10) == 0) {
+                BlockPos randomPos = pos.offset(worldIn.random.nextInt(16) - 8, worldIn.random.nextInt(8), worldIn.random.nextInt(16) - 8);
+                if (coralBlocks.contains(worldIn.getBlockState(randomPos).getBlockHolder())) {
+                    worldIn.setBlock(randomPos, Blocks.WET_SPONGE.defaultBlockState(), Block.UPDATE_ALL);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/HopperCounter.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/HopperCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..d11e835f97be89f93f9cfc47cc6b63710229a3f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/HopperCounter.java
@@ -0,0 +1,389 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import it.unimi.dsi.fastutil.objects.Object2LongLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2LongMap;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.*;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.AbstractBannerBlock;
+import net.minecraft.world.level.block.BeaconBeamBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.material.MapColor;
+import org.leavesmc.lumina.carpet.CarpetServer;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.RecipeHelper;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+import static java.util.Map.entry;
+
+/**
+ * The actual object residing in each hopper counter which makes them count the items and saves them. There is one for each
+ * colour in MC.
+ */
+
+public class HopperCounter {
+    /**
+     * A map of all the {@link HopperCounter} counters.
+     */
+    private static final Map<DyeColor, HopperCounter> COUNTERS;
+
+    /**
+     * The default display colour of each item, which makes them look nicer when printing the counter contents to the chat
+     */
+
+    public static final TextColor WHITE = TextColor.fromLegacyFormat(ChatFormatting.WHITE);
+
+    static {
+        EnumMap<DyeColor, HopperCounter> counterMap = new EnumMap<>(DyeColor.class);
+        for (DyeColor color : DyeColor.values()) {
+            counterMap.put(color, new HopperCounter(color));
+        }
+        COUNTERS = Collections.unmodifiableMap(counterMap);
+    }
+
+    /**
+     * The counter's colour, determined by the colour of wool it's pointing into
+     */
+    public final DyeColor color;
+    /**
+     * The string which is passed into {@link Messenger#m} which makes each counter name be displayed in the colour of
+     * that counter.
+     */
+    private final String coloredName;
+    /**
+     * All the items stored within the counter, as a map of {@link Item} mapped to a {@code long} of the amount of items
+     * stored thus far of that item type.
+     */
+    private final Object2LongMap<Item> counter = new Object2LongLinkedOpenHashMap<>();
+    /**
+     * The starting tick of the counter, used to calculate in-game time. Only initialised when the first item enters the
+     * counter
+     */
+    private long startTick;
+    /**
+     * The starting millisecond of the counter, used to calculate IRl time. Only initialised when the first item enters
+     * the counter
+     */
+    private long startMillis;
+    // private PubSubInfoProvider<Long> pubSubProvider;
+
+    private HopperCounter(DyeColor color) {
+        startTick = -1;
+        this.color = color;
+        String hexColor = Integer.toHexString(color.getTextColor());
+        if (hexColor.length() < 6)
+            hexColor = "0".repeat(6 - hexColor.length()) + hexColor;
+        this.coloredName = '#' + hexColor + ' ' + color.getName();
+    }
+
+    /**
+     * Method used to add items to the counter. Note that this is when the {@link HopperCounter#startTick} and
+     * {@link HopperCounter#startMillis} variables are initialised, so you can place the counters and then start the farm
+     * after all the collection is sorted out.
+     */
+    public void add(MinecraftServer server, ItemStack stack) {
+        if (startTick < 0) {
+            startTick = server.overworld().getGameTime();
+            startMillis = System.currentTimeMillis();
+        }
+        Item item = stack.getItem();
+        counter.put(item, counter.getLong(item) + stack.getCount());
+        // pubSubProvider.publish();
+    }
+
+    /**
+     * Resets the counter, clearing its items but keeping the clock running.
+     */
+    public void reset(MinecraftServer server) {
+        counter.clear();
+        startTick = server.overworld().getGameTime();
+        startMillis = System.currentTimeMillis();
+        // pubSubProvider.publish();
+    }
+
+    /**
+     * Resets all counters, clearing their items.
+     *
+     * @param fresh Whether or not to start the clocks going immediately or later.
+     */
+    public static void resetAll(MinecraftServer server, boolean fresh) {
+        for (HopperCounter counter : COUNTERS.values()) {
+            counter.reset(server);
+            if (fresh) counter.startTick = -1;
+        }
+    }
+
+    /**
+     * Prints all the counters to chat, nicely formatted, and you can choose whether to diplay in in game time or IRL time
+     */
+    public static List<Component> formatAll(MinecraftServer server, boolean realtime) {
+        List<Component> text = new ArrayList<>();
+
+        for (HopperCounter counter : COUNTERS.values()) {
+            List<Component> temp = counter.format(server, realtime, false);
+            if (temp.size() > 1) {
+                if (!text.isEmpty()) text.add(Messenger.s(""));
+                text.addAll(temp);
+            }
+        }
+        if (text.isEmpty()) {
+            text.add(Messenger.s("No items have been counted yet."));
+        }
+        return text;
+    }
+
+    /**
+     * Prints a single counter's contents and timings to chat, with the option to keep it short (so no item breakdown,
+     * only rates). Again, realtime displays IRL time as opposed to in game time.
+     */
+    public List<Component> format(MinecraftServer server, boolean realTime, boolean brief) {
+        long ticks = Math.max(realTime ? (System.currentTimeMillis() - startMillis) / 50 : server.overworld().getGameTime() - startTick, 1);
+        if (startTick < 0 || ticks == 0) {
+            if (brief) {
+                return Collections.singletonList(Messenger.c("b" + coloredName, "w : ", "gi -, -/h, - min "));
+            }
+            return Collections.singletonList(Messenger.c(coloredName, "w  hasn't started counting yet"));
+        }
+        long total = getTotalItems();
+        if (total == 0) {
+            if (brief) {
+                return Collections.singletonList(Messenger.c("b" + coloredName, "w : ", "wb 0", "w , ", "wb 0", "w /h, ", String.format("wb %.1f ", ticks / (20.0 * 60.0)), "w min"));
+            }
+            return Collections.singletonList(Messenger.c("w No items for ", coloredName, String.format("w  yet (%.2f min.%s)",
+                            ticks / (20.0 * 60.0), (realTime ? " - real time" : "")),
+                    "nb  [X]", "^g reset", "!/counter " + color.getName() + " reset"));
+        }
+        if (brief) {
+            return Collections.singletonList(Messenger.c("b" + coloredName, "w : ",
+                    "wb " + total, "w , ",
+                    "wb " + (total * (20 * 60 * 60) / ticks), "w /h, ",
+                    String.format("wb %.1f ", ticks / (20.0 * 60.0)), "w min"
+            ));
+        }
+        List<Component> items = new ArrayList<>();
+        items.add(Messenger.c("w Items for ", coloredName,
+                "w  (", String.format("wb %.2f", ticks * 1.0 / (20 * 60)), "w  min" + (realTime ? " - real time" : "") + "), ",
+                "w total: ", "wb " + total, "w , (", String.format("wb %.1f", total * 1.0 * (20 * 60 * 60) / ticks), "w /h):",
+                "nb [X]", "^g reset", "!/counter " + color + " reset"
+        ));
+        items.addAll(counter.object2LongEntrySet().stream().sorted((e, f) -> Long.compare(f.getLongValue(), e.getLongValue())).map(e ->
+        {
+            Item item = e.getKey();
+            MutableComponent itemName = Component.translatable(item.getDescriptionId());
+            Style itemStyle = itemName.getStyle();
+            TextColor color = guessColor(item, server.overworld());
+            itemName.setStyle((color != null) ? itemStyle.withColor(color) : itemStyle.withItalic(true));
+            long count = e.getLongValue();
+            return Messenger.c("g - ", itemName,
+                    "g : ", "wb " + count, "g , ",
+                    String.format("wb %.1f", count * (20.0 * 60.0 * 60.0) / ticks), "w /h"
+            );
+        }).collect(Collectors.toList()));
+        return items;
+    }
+
+    /**
+     * Converts a colour to have a low brightness and uniform colour, so when it prints the items in different colours
+     * it's not too flashy and bright, but enough that it's not dull to look at.
+     */
+    public static int appropriateColor(int color) {
+        if (color == 0) return MapColor.SNOW.col;
+        int r = (color >> 16 & 255);
+        int g = (color >> 8 & 255);
+        int b = (color & 255);
+        if (r < 70) r = 70;
+        if (g < 70) g = 70;
+        if (b < 70) b = 70;
+        return (r << 16) + (g << 8) + b;
+    }
+
+    /**
+     * Maps items that don't get a good block to reference for colour, or those that colour is wrong to a number of blocks, so we can get their colours easily with the
+     * {@link Block#defaultMapColor()} method as these items have those same colours.
+     */
+    private static final Map<Item, Block> DEFAULTS = Map.ofEntries(
+            entry(Items.DANDELION, Blocks.YELLOW_WOOL),
+            entry(Items.POPPY, Blocks.RED_WOOL),
+            entry(Items.BLUE_ORCHID, Blocks.LIGHT_BLUE_WOOL),
+            entry(Items.ALLIUM, Blocks.MAGENTA_WOOL),
+            entry(Items.AZURE_BLUET, Blocks.SNOW_BLOCK),
+            entry(Items.RED_TULIP, Blocks.RED_WOOL),
+            entry(Items.ORANGE_TULIP, Blocks.ORANGE_WOOL),
+            entry(Items.WHITE_TULIP, Blocks.SNOW_BLOCK),
+            entry(Items.PINK_TULIP, Blocks.PINK_WOOL),
+            entry(Items.OXEYE_DAISY, Blocks.SNOW_BLOCK),
+            entry(Items.CORNFLOWER, Blocks.BLUE_WOOL),
+            entry(Items.WITHER_ROSE, Blocks.BLACK_WOOL),
+            entry(Items.LILY_OF_THE_VALLEY, Blocks.WHITE_WOOL),
+            entry(Items.BROWN_MUSHROOM, Blocks.BROWN_MUSHROOM_BLOCK),
+            entry(Items.RED_MUSHROOM, Blocks.RED_MUSHROOM_BLOCK),
+            entry(Items.STICK, Blocks.OAK_PLANKS),
+            entry(Items.GOLD_INGOT, Blocks.GOLD_BLOCK),
+            entry(Items.IRON_INGOT, Blocks.IRON_BLOCK),
+            entry(Items.DIAMOND, Blocks.DIAMOND_BLOCK),
+            entry(Items.NETHERITE_INGOT, Blocks.NETHERITE_BLOCK),
+            entry(Items.SUNFLOWER, Blocks.YELLOW_WOOL),
+            entry(Items.LILAC, Blocks.MAGENTA_WOOL),
+            entry(Items.ROSE_BUSH, Blocks.RED_WOOL),
+            entry(Items.PEONY, Blocks.PINK_WOOL),
+            entry(Items.CARROT, Blocks.ORANGE_WOOL),
+            entry(Items.APPLE, Blocks.RED_WOOL),
+            entry(Items.WHEAT, Blocks.HAY_BLOCK),
+            entry(Items.PORKCHOP, Blocks.PINK_WOOL),
+            entry(Items.RABBIT, Blocks.PINK_WOOL),
+            entry(Items.CHICKEN, Blocks.WHITE_TERRACOTTA),
+            entry(Items.BEEF, Blocks.NETHERRACK),
+            entry(Items.ENCHANTED_GOLDEN_APPLE, Blocks.GOLD_BLOCK),
+            entry(Items.COD, Blocks.WHITE_TERRACOTTA),
+            entry(Items.SALMON, Blocks.ACACIA_PLANKS),
+            entry(Items.ROTTEN_FLESH, Blocks.BROWN_WOOL),
+            entry(Items.PUFFERFISH, Blocks.YELLOW_TERRACOTTA),
+            entry(Items.TROPICAL_FISH, Blocks.ORANGE_WOOL),
+            entry(Items.POTATO, Blocks.WHITE_TERRACOTTA),
+            entry(Items.MUTTON, Blocks.RED_WOOL),
+            entry(Items.BEETROOT, Blocks.NETHERRACK),
+            entry(Items.MELON_SLICE, Blocks.MELON),
+            entry(Items.POISONOUS_POTATO, Blocks.SLIME_BLOCK),
+            entry(Items.SPIDER_EYE, Blocks.NETHERRACK),
+            entry(Items.GUNPOWDER, Blocks.GRAY_WOOL),
+            entry(Items.TURTLE_SCUTE, Blocks.LIME_WOOL),
+            entry(Items.ARMADILLO_SCUTE, Blocks.ANCIENT_DEBRIS),
+            entry(Items.FEATHER, Blocks.WHITE_WOOL),
+            entry(Items.FLINT, Blocks.BLACK_WOOL),
+            entry(Items.LEATHER, Blocks.SPRUCE_PLANKS),
+            entry(Items.GLOWSTONE_DUST, Blocks.GLOWSTONE),
+            entry(Items.PAPER, Blocks.WHITE_WOOL),
+            entry(Items.BRICK, Blocks.BRICKS),
+            entry(Items.INK_SAC, Blocks.BLACK_WOOL),
+            entry(Items.SNOWBALL, Blocks.SNOW_BLOCK),
+            entry(Items.WATER_BUCKET, Blocks.WATER),
+            entry(Items.LAVA_BUCKET, Blocks.LAVA),
+            entry(Items.MILK_BUCKET, Blocks.WHITE_WOOL),
+            entry(Items.CLAY_BALL, Blocks.CLAY),
+            entry(Items.COCOA_BEANS, Blocks.COCOA),
+            entry(Items.BONE, Blocks.BONE_BLOCK),
+            entry(Items.COD_BUCKET, Blocks.BROWN_TERRACOTTA),
+            entry(Items.PUFFERFISH_BUCKET, Blocks.YELLOW_TERRACOTTA),
+            entry(Items.SALMON_BUCKET, Blocks.PINK_TERRACOTTA),
+            entry(Items.TROPICAL_FISH_BUCKET, Blocks.ORANGE_TERRACOTTA),
+            entry(Items.SUGAR, Blocks.WHITE_WOOL),
+            entry(Items.BLAZE_POWDER, Blocks.GOLD_BLOCK),
+            entry(Items.ENDER_PEARL, Blocks.WARPED_PLANKS),
+            entry(Items.NETHER_STAR, Blocks.DIAMOND_BLOCK),
+            entry(Items.PRISMARINE_CRYSTALS, Blocks.SEA_LANTERN),
+            entry(Items.PRISMARINE_SHARD, Blocks.PRISMARINE),
+            entry(Items.RABBIT_HIDE, Blocks.OAK_PLANKS),
+            entry(Items.CHORUS_FRUIT, Blocks.PURPUR_BLOCK),
+            entry(Items.SHULKER_SHELL, Blocks.SHULKER_BOX),
+            entry(Items.NAUTILUS_SHELL, Blocks.BONE_BLOCK),
+            entry(Items.HEART_OF_THE_SEA, Blocks.CONDUIT),
+            entry(Items.HONEYCOMB, Blocks.HONEYCOMB_BLOCK),
+            entry(Items.NAME_TAG, Blocks.BONE_BLOCK),
+            entry(Items.TOTEM_OF_UNDYING, Blocks.YELLOW_TERRACOTTA),
+            entry(Items.TRIDENT, Blocks.PRISMARINE),
+            entry(Items.GHAST_TEAR, Blocks.WHITE_WOOL),
+            entry(Items.PHANTOM_MEMBRANE, Blocks.BONE_BLOCK),
+            entry(Items.EGG, Blocks.BONE_BLOCK),
+            //entry(Items.,Blocks.),
+            entry(Items.COPPER_INGOT, Blocks.COPPER_BLOCK),
+            entry(Items.AMETHYST_SHARD, Blocks.AMETHYST_BLOCK));
+
+    /**
+     * Gets the colour to print an item in when printing its count in a hopper counter.
+     */
+    public static TextColor fromItem(Item item, RegistryAccess registryAccess) {
+        if (DEFAULTS.containsKey(item))
+            return TextColor.fromRgb(appropriateColor(DEFAULTS.get(item).defaultMapColor().col));
+        if (item instanceof DyeItem dye)
+            return TextColor.fromRgb(appropriateColor(dye.getDyeColor().getMapColor().col));
+        Block block = null;
+        final Registry<Item> itemRegistry = registryAccess.lookupOrThrow(Registries.ITEM);
+        final Registry<Block> blockRegistry = registryAccess.lookupOrThrow(Registries.BLOCK);
+        ResourceLocation id = itemRegistry.getKey(item);
+        if (item instanceof BlockItem blockItem) {
+            block = blockItem.getBlock();
+        } else if (blockRegistry.getOptional(id).isPresent()) {
+            block = blockRegistry.getValue(id);
+        }
+        if (block != null) {
+            if (block instanceof AbstractBannerBlock)
+                return TextColor.fromRgb(appropriateColor(((AbstractBannerBlock) block).getColor().getMapColor().col));
+            if (block instanceof BeaconBeamBlock)
+                return TextColor.fromRgb(appropriateColor(((BeaconBeamBlock) block).getColor().getMapColor().col));
+            return TextColor.fromRgb(appropriateColor(block.defaultMapColor().col));
+        }
+        return null;
+    }
+
+    /**
+     * Guesses the item's colour from the item itself. It first calls {@link HopperCounter#fromItem} to see if it has a
+     * valid colour there, if not just makes a guess, and if that fails just returns null
+     */
+    public static TextColor guessColor(Item item, Level level) {
+        RegistryAccess registryAccess = level.registryAccess();
+        TextColor direct = fromItem(item, registryAccess);
+        if (direct != null) {
+            return direct;
+        }
+        if (MinecraftServer.getServer() == null) {
+            return WHITE;
+        }
+
+        ResourceLocation id = registryAccess.lookupOrThrow(Registries.ITEM).getKey(item);
+        if (id == null) {
+            return null;
+        }
+
+        for (Recipe<?> r : RecipeHelper.getRecipesForOutput(MinecraftServer.getServer().getRecipeManager(), id, level)) {
+            for (Ingredient ingredient : r.placementInfo().ingredients()) {
+                Optional<Holder<Item>> match = ingredient.items().filter(stack -> fromItem(stack.value(), registryAccess) != null).findFirst();
+                if (match.isPresent()) {
+                    return fromItem(match.get().value(), registryAccess);
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns the hopper counter for the given color
+     */
+    public static HopperCounter getCounter(DyeColor color) {
+        return COUNTERS.get(color);
+    }
+
+    /**
+     * Returns the hopper counter from the colour name, if not null
+     */
+    public static HopperCounter getCounter(String color) {
+        try {
+            DyeColor colorEnum = DyeColor.valueOf(color.toUpperCase(Locale.ROOT));
+            return COUNTERS.get(colorEnum);
+        } catch (IllegalArgumentException e) {
+            return null;
+        }
+    }
+
+    /**
+     * The total number of items in the counter
+     */
+    public long getTotalItems() {
+        return counter.isEmpty() ? 0 : counter.values().longStream().sum();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/ParticleDisplay.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/ParticleDisplay.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d9fb04e4112f3c46c36185f00d4ca34fc85ef52
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/ParticleDisplay.java
@@ -0,0 +1,35 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.particles.ParticleOptions;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.script.utils.ParticleParser;
+
+public class ParticleDisplay {
+    public static void drawParticleLine(ServerPlayer player, Vec3 from, Vec3 to, String main, String accent, int count, double spread) {
+        ParticleOptions accentParticle = ParticleParser.getEffect(accent, player.server.registryAccess());
+        ParticleOptions mainParticle = ParticleParser.getEffect(main, player.server.registryAccess());
+
+        if (accentParticle != null) player.serverLevel().sendParticles(
+                player,
+                accentParticle,
+                true, true,
+                to.x, to.y, to.z, count,
+                spread, spread, spread, 0.0);
+
+        double lineLengthSq = from.distanceToSqr(to);
+        if (lineLengthSq == 0) return;
+
+        Vec3 incvec = to.subtract(from).normalize();//    multiply(50/sqrt(lineLengthSq));
+        for (Vec3 delta = new Vec3(0.0, 0.0, 0.0);
+             delta.lengthSqr() < lineLengthSq;
+             delta = delta.add(incvec.scale(player.level().random.nextFloat()))) {
+            player.serverLevel().sendParticles(
+                    player,
+                    mainParticle,
+                    true, true,
+                    delta.x + from.x, delta.y + from.y, delta.z + from.z, 1,
+                    0.0, 0.0, 0.0, 0.0);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/helpers/QuasiConnectivity.java b/src/main/java/org/leavesmc/lumina/carpet/helpers/QuasiConnectivity.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c665fcf6f60018ae52c6061bb2a9c53914c7710
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/helpers/QuasiConnectivity.java
@@ -0,0 +1,23 @@
+package org.leavesmc.lumina.carpet.helpers;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.SignalGetter;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+public class QuasiConnectivity {
+
+    public static boolean hasQuasiSignal(SignalGetter level, BlockPos pos) {
+        for (int i = 1; i <= CarpetConfig.configModule().quasiConnectivity; i++) {
+            BlockPos above = pos.above(i);
+
+            if (level.isOutsideBuildHeight(above)) {
+                break;
+            }
+            if (level.hasNeighborSignal(above)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/HUDController.java b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDController.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0558f39decc3e1d3727b30a4af2131d5a2bb117
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDController.java
@@ -0,0 +1,157 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import io.papermc.paper.threadedregions.*;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+import org.leavesmc.lumina.carpet.logging.logHelpers.PacketCounter;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+import org.leavesmc.lumina.carpet.utils.SpawnReporter;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ClientboundTabListPacket;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.world.level.Level;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class HUDController {
+    private static final Set<Consumer<MinecraftServer>> HUDListeners = Sets.newConcurrentHashSet();
+
+    /**
+     * Adds listener to be called when HUD is updated for logging information
+     *
+     * @param listener - a method to be called when new HUD inforation are collected
+     */
+    public static void register(Consumer<MinecraftServer> listener) {
+        HUDListeners.add(listener);
+    }
+
+    public static final Map<ServerPlayer, List<Component>> player_huds = Maps.newConcurrentMap();
+    //keyed with player names so unlogged players don't hold the reference
+    public static final Map<String, Component> scarpet_headers = Maps.newConcurrentMap();
+
+    public static final Map<String, Component> scarpet_footers = Maps.newConcurrentMap();
+
+    private static final Map<String, Boolean> shouldSendClear = Maps.newConcurrentMap();
+
+    public static void resetScarpetHUDs() {
+        scarpet_headers.clear();
+        scarpet_footers.clear();
+    }
+
+    public static void addMessage(ServerPlayer player, Component hudMessage) {
+        if (player == null) return;
+        final List<Component> hudMessages = player_huds.computeIfAbsent(player, k -> new ArrayList<>());
+
+        if (hudMessages.isEmpty()) {
+            hudMessages.add(hudMessage);
+            return;
+        }
+
+        hudMessages.add(Component.literal("\n"));
+        hudMessages.add(hudMessage);
+    }
+
+    public static void clearPlayer(ServerPlayer player) {
+        ClientboundTabListPacket packet = new ClientboundTabListPacket(Component.literal(""), Component.literal(""));
+        player.connection.send(packet);
+    }
+
+
+    public static void update_hud(MinecraftServer server) {
+        if (RegionizedServer.getGlobalTickData().getCurrentTick() % 20 != 0) {
+            return;
+        }
+
+        player_huds.clear();
+        if (LoggerRegistry.__mobcaps) {
+            LoggerRegistry.getLogger("mobcaps").log((option, pl) -> {
+                ResourceKey<Level> dim = switch (option) {
+                    case "overworld" -> Level.OVERWORLD;
+                    case "nether" -> Level.NETHER;
+                    case "end" -> Level.END;
+                    default -> pl.level().dimension();
+                };
+                return new Component[]{SpawnReporter.printMobcapsForDimension(server.getLevel(dim), false).get(0)};
+            });
+        }
+
+        if (LoggerRegistry.__counter) {
+            LoggerRegistry.getLogger("counter").log((option) -> send_counter_info(server, option));
+        }
+
+        if (LoggerRegistry.__packets) {
+            LoggerRegistry.getLogger("packets").log(HUDController::packetCounter);
+        }
+
+        for (final ServerPlayer player : server.getPlayerList().getPlayers()) {
+            player.getBukkitEntity().taskScheduler.schedule(task -> {
+                String playerName = player.getScoreboardName();
+                if (LoggerRegistry.__tps) {
+                    final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentRegion = TickRegionScheduler.getCurrentRegion();
+                    final TickRegions.TickRegionData currentData = currentRegion.getData();
+                    Component tpsMsg = Messenger.c("r error getting tps & mspt");
+                    if (currentData != null) {
+                        final TickData.TickReportData tickReport = currentData.getRegionSchedulingHandle().getTickReport5s(System.nanoTime());
+
+                        final TickData.SegmentedAverage tpsData = tickReport.tpsData();
+                        final TickData.SegmentedAverage msptData = tickReport.timePerTickData();
+
+                        final double mspt = msptData.segmentAll().average() / 1.0E6;
+                        final double tps = tpsData.segmentAll().average();
+                        String color = Messenger.heatmap_color(mspt, ((long) ((double) TimeUtil.NANOSECONDS_PER_SECOND / tps) / (float) TimeUtil.NANOSECONDS_PER_MILLISECOND));
+                        tpsMsg = Messenger.c(
+                                "g TPS: ", String.format(Locale.US, "%s %.1f", color, tps),
+                                "g  MSPT: ", String.format(Locale.US, "%s %.1f", color, mspt));
+                    }
+                    if (LoggerRegistry.isPlayerSubscripting(playerName, "tps")) {
+                        HUDController.addMessage(player, tpsMsg);
+                    }
+                }
+                Component scarpetFOoter = scarpet_footers.get(player.getScoreboardName());
+                if (scarpetFOoter != null) HUDController.addMessage(player, scarpetFOoter);
+                List<Component> forSend = player_huds.getOrDefault(player, List.of());
+                if (forSend.isEmpty() && !shouldSendClear.getOrDefault(player.getScoreboardName(), false)) {
+                    return;
+                } else {
+                    shouldSendClear.put(player.getScoreboardName(), true);
+                }
+                if (forSend.isEmpty()) {
+                    shouldSendClear.put(player.getScoreboardName(), false);
+                }
+                // Bukkit.getGlobalRegionScheduler().execute(CarpetServer.PLUGIN, () -> {
+                ClientboundTabListPacket packet = new ClientboundTabListPacket(
+                        scarpet_headers.getOrDefault(player.getScoreboardName(), Component.literal("")),
+                        Messenger.c(forSend.toArray(new Object[0]))
+                );
+                player.connection.send(packet);
+                // });
+                // extensions have time to pitch in.
+                // HUDListeners.forEach(l -> l.accept(server)); // TODO
+            }, null, 1);
+        }
+    }
+
+    private static Component[] send_counter_info(MinecraftServer server, String colors) {
+        List<Component> res = new ArrayList<>();
+
+        for (String color : colors.split(",")) {
+            HopperCounter counter = HopperCounter.getCounter(color);
+            if (counter != null) res.addAll(counter.format(server, false, true));
+        }
+
+        return res.toArray(new Component[0]);
+    }
+
+    private static Component[] packetCounter() {
+        Component[] ret = new Component[]{
+                Messenger.c("w I/" + PacketCounter.totalIn + " O/" + PacketCounter.totalOut),
+        };
+        PacketCounter.reset();
+        return ret;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/HUDLogger.java b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3de8593057c4f7c3f017c7fe3d3d85fcf646684
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/HUDLogger.java
@@ -0,0 +1,44 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import java.lang.reflect.Field;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+
+public class HUDLogger extends Logger {
+    static Logger stardardHUDLogger(String logName, String def, String[] options) {
+        return stardardHUDLogger(logName, def, options, false);
+    }
+
+    static Logger stardardHUDLogger(String logName, String def, String[] options, boolean strictOptions) {
+        // should convert to factory method if more than 2 classes are here
+        try {
+            return new HUDLogger(LoggerRegistry.class.getField("__" + logName), logName, def, options, strictOptions);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException("Failed to create logger " + logName);
+        }
+    }
+
+    public HUDLogger(Field field, String logName, String def, String[] options, boolean strictOptions) {
+        super(field, logName, def, options, strictOptions);
+    }
+
+    @Deprecated
+    public HUDLogger(Field field, String logName, String def, String[] options) {
+        super(field, logName, def, options, false);
+    }
+
+    @Override
+    public void removePlayer(String playerName) {
+        ServerPlayer player = playerFromName(playerName);
+        if (player != null) HUDController.clearPlayer(player);
+        super.removePlayer(playerName);
+    }
+
+    @Override
+    public void sendPlayerMessage(ServerPlayer player, Component... messages) {
+        for (Component m : messages) HUDController.addMessage(player, m);
+    }
+
+
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/Logger.java b/src/main/java/org/leavesmc/lumina/carpet/logging/Logger.java
new file mode 100644
index 0000000000000000000000000000000000000000..e9d6a5146d675306b894084065fc602c9767cbae
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/Logger.java
@@ -0,0 +1,230 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Supplier;
+
+import com.google.common.collect.Maps;
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectMaps;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.player.Player;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.CarpetServer;
+
+public class Logger {
+    // The set of subscribed and online players.
+    private Map<String, String> subscribedOnlinePlayers;
+
+    // The set of subscribed and offline players.
+    private Map<String, String> subscribedOfflinePlayers;
+
+    // The logName of this log. Gets prepended to logged messages.
+    private String logName;
+
+    private String default_option;
+
+    private String[] options;
+
+    private Field acceleratorField;
+
+    private boolean strictOptions;
+
+    static Logger stardardLogger(String logName, String def, String[] options) {
+        return stardardLogger(logName, def, options, false);
+    }
+
+    static Logger stardardLogger(String logName, String def, String[] options, boolean strictOptions) {
+        try {
+            return new Logger(LoggerRegistry.class.getField("__" + logName), logName, def, options, strictOptions);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException("Failed to create logger " + logName);
+        }
+    }
+
+    @Deprecated
+    public Logger(Field acceleratorField, String logName, String def, String[] options) {
+        this(acceleratorField, logName, def, options, false);
+    }
+
+    public Logger(Field acceleratorField, String logName, String def, String[] options, boolean strictOptions) {
+        subscribedOnlinePlayers = Object2ObjectMaps.synchronize(new Object2ObjectLinkedOpenHashMap<>());
+        subscribedOfflinePlayers = Object2ObjectMaps.synchronize(new Object2ObjectLinkedOpenHashMap<>());
+        this.acceleratorField = acceleratorField;
+        this.logName = logName;
+        this.default_option = def;
+        this.options = options == null ? new String[0] : options;
+        this.strictOptions = strictOptions;
+        if (acceleratorField == null)
+            CarpetServer.LOGGER.error("[CM] Logger {} is missing a specified accelerator", getLogName());
+    }
+
+    public String getDefault() {
+        return default_option;
+    }
+
+    public String[] getOptions() {
+        return options;
+    }
+
+    public String getLogName() {
+        return logName;
+    }
+
+    /**
+     * Subscribes the player with the given logName to the logger.
+     */
+    public void addPlayer(String playerName, String option) {
+        if (playerFromName(playerName) != null) {
+            subscribedOnlinePlayers.put(playerName, option);
+        } else {
+            subscribedOfflinePlayers.put(playerName, option);
+        }
+        LoggerRegistry.setAccess(this);
+    }
+
+    /**
+     * Unsubscribes the player with the given logName from the logger.
+     */
+    public void removePlayer(String playerName) {
+        subscribedOnlinePlayers.remove(playerName);
+        subscribedOfflinePlayers.remove(playerName);
+        LoggerRegistry.setAccess(this);
+    }
+
+    /**
+     * Returns true if there are any online subscribers for this log.
+     */
+    public boolean hasOnlineSubscribers() {
+        return !subscribedOnlinePlayers.isEmpty();
+    }
+
+    public void serverStopped() {
+        subscribedOnlinePlayers.clear();
+        subscribedOfflinePlayers.clear();
+    }
+
+    public Field getField() {
+        return acceleratorField;
+    }
+
+    /**
+     * serves messages to players fetching them from the promise
+     * will repeat invocation for players that share the same option
+     */
+    @FunctionalInterface
+    public interface lMessage {
+        Component[] get(String playerOption, Player player);
+    }
+
+    public void log(lMessage messagePromise) {
+        for (Map.Entry<String, String> en : subscribedOnlinePlayers.entrySet()) {
+            ServerPlayer player = playerFromName(en.getKey());
+            if (player != null) {
+                Component[] messages = messagePromise.get(en.getValue(), player);
+                if (messages != null)
+                    sendPlayerMessage(player, messages);
+            }
+        }
+    }
+
+    /**
+     * guarantees that each message for each option will be evaluated once from the promise
+     * and served the same way to all other players subscribed to the same option
+     */
+    @FunctionalInterface
+    public interface lMessageIgnorePlayer {
+        Component[] get(String playerOption);
+    }
+
+    public void log(lMessageIgnorePlayer messagePromise) {
+        Map<String, Component[]> cannedMessages = new HashMap<>();
+        for (Map.Entry<String, String> en : subscribedOnlinePlayers.entrySet()) {
+            ServerPlayer player = playerFromName(en.getKey());
+            if (player != null) {
+                String option = en.getValue();
+                if (!cannedMessages.containsKey(option)) {
+                    cannedMessages.put(option, messagePromise.get(option));
+                }
+                Component[] messages = cannedMessages.get(option);
+                if (messages != null)
+                    sendPlayerMessage(player, messages);
+            }
+        }
+    }
+
+    /**
+     * guarantees that message is evaluated once, so independent from the player and chosen option
+     */
+    public void log(Supplier<Component[]> messagePromise) {
+        Component[] cannedMessages = null;
+        for (Map.Entry<String, String> en : subscribedOnlinePlayers.entrySet()) {
+            ServerPlayer player = playerFromName(en.getKey());
+            if (player != null) {
+                if (cannedMessages == null) cannedMessages = messagePromise.get();
+                sendPlayerMessage(player, cannedMessages);
+            }
+        }
+    }
+
+    public void sendPlayerMessage(ServerPlayer player, Component... messages) {
+        Arrays.stream(messages).forEach(player::sendSystemMessage);
+    }
+
+    /**
+     * Gets the {@code PlayerEntity} instance for a player given their UUID. Returns null if they are offline.
+     */
+    protected ServerPlayer playerFromName(String name) {
+        return MinecraftServer.getServer().getPlayerList().getPlayerByName(name);
+    }
+
+    // ----- Event Handlers ----- //
+
+    public void onPlayerConnect(Player player, boolean firstTime) {
+        // If the player was subscribed to the log and offline, move them to the set of online subscribers.
+        String playerName = player.getName().getString();
+        if (subscribedOfflinePlayers.containsKey(playerName)) {
+            subscribedOnlinePlayers.put(playerName, subscribedOfflinePlayers.get(playerName));
+            subscribedOfflinePlayers.remove(playerName);
+        } else if (firstTime) {
+            Set<String> loggingOptions = new HashSet<>(Arrays.asList(CarpetConfig.configModule().defaultLoggers.split(",")));
+            String logName = getLogName();
+            for (String str : loggingOptions) {
+                String[] vars = str.split(" ", 2);
+                if (vars[0].equals(logName)) {
+                    LoggerRegistry.subscribePlayer(playerName, getLogName(), vars.length == 1 ? getDefault() : vars[1]);
+                    break;
+                }
+            }
+        }
+        LoggerRegistry.setAccess(this);
+    }
+
+    public void onPlayerDisconnect(Player player) {
+        // If the player was subscribed to the log, move them to the set of offline subscribers.
+        String playerName = player.getName().getString();
+        if (subscribedOnlinePlayers.containsKey(playerName)) {
+            subscribedOfflinePlayers.put(playerName, subscribedOnlinePlayers.get(playerName));
+            subscribedOnlinePlayers.remove(playerName);
+        }
+        LoggerRegistry.setAccess(this);
+    }
+
+    public String getAcceptedOption(String arg) {
+        if (Arrays.asList(this.getOptions()).contains(arg)) return arg;
+        return null;
+    }
+
+    public boolean isOptionValid(String option) {
+        if (strictOptions) {
+            return Arrays.asList(this.getOptions()).contains(option);
+        }
+        return option != null;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/LoggerRegistry.java b/src/main/java/org/leavesmc/lumina/carpet/logging/LoggerRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..e36e5b3661f780faba5995fe1963c2d902a0c966
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/LoggerRegistry.java
@@ -0,0 +1,163 @@
+package org.leavesmc.lumina.carpet.logging;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import org.leavesmc.lumina.carpet.CarpetServer;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.DyeColor;
+
+public class LoggerRegistry {
+    private final static Set<String> seenPlayers = Sets.newConcurrentHashSet();
+    // Map from logger names to loggers.
+    private static final Map<String, Logger> loggerRegistry = Maps.newConcurrentMap();
+    // Map from player names to the set of names of the logs that player is subscribed to.
+    private static final Map<String, Map<String, String>> playerSubscriptions = Maps.newConcurrentMap();
+    //statics to quickly asses if its worth even to call each one
+    public static volatile boolean __tnt;
+    public static volatile boolean __projectiles;
+    public static volatile boolean __fallingBlocks;
+    public static volatile boolean __tps;
+    public static volatile boolean __counter;
+    public static volatile boolean __mobcaps;
+    public static volatile boolean __packets;
+    public static volatile boolean __pathfinding;
+    public static volatile boolean __explosions;
+
+    public static void initLoggers() {
+        stopLoggers();
+        registerLoggers();
+        CarpetServer.registerExtensionLoggers();
+    }
+
+    public static void registerLoggers() {
+        registerLogger("tnt", Logger.stardardLogger("tnt", "brief", new String[]{"brief", "full"}, true));
+        registerLogger("projectiles", Logger.stardardLogger("projectiles", "brief", new String[]{"brief", "full"}));
+        registerLogger("fallingBlocks", Logger.stardardLogger("fallingBlocks", "brief", new String[]{"brief", "full"}));
+        registerLogger("pathfinding", Logger.stardardLogger("pathfinding", "20", new String[]{"2", "5", "10"}));
+        registerLogger("tps", HUDLogger.stardardHUDLogger("tps", null, null));
+        registerLogger("packets", HUDLogger.stardardHUDLogger("packets", null, null));
+        registerLogger("counter", HUDLogger.stardardHUDLogger("counter", "white", Arrays.stream(DyeColor.values()).map(Object::toString).toArray(String[]::new)));
+        registerLogger("mobcaps", HUDLogger.stardardHUDLogger("mobcaps", "dynamic", new String[]{"dynamic", "overworld", "nether", "end"}));
+        registerLogger("explosions", Logger.stardardLogger("explosions", "brief", new String[]{"brief", "full"}, true));
+
+    }
+
+    /**
+     * Gets the logger with the given name. Returns null if no such logger exists.
+     */
+    public static Logger getLogger(String name) {
+        return loggerRegistry.get(name);
+    }
+
+    /**
+     * Gets the set of logger names.
+     */
+    public static Set<String> getLoggerNames() {
+        return loggerRegistry.keySet();
+    }
+
+    /**
+     * Subscribes the player with name playerName to the log with name logName.
+     */
+    public static void subscribePlayer(String playerName, String logName, String option) {
+        final Map<String, String> optionMap = playerSubscriptions.computeIfAbsent(playerName, unused -> new HashMap<>());
+        Logger log = loggerRegistry.get(logName);
+        if (option == null) option = log.getDefault();
+        optionMap.put(logName, option);
+        log.addPlayer(playerName, option);
+    }
+
+    /**
+     * Unsubscribes the player with name playerName from the log with name logName.
+     */
+    public static void unsubscribePlayer(String playerName, String logName) {
+        final Map<String, String> subscriptionMap = playerSubscriptions.get(playerName);
+
+        if (subscriptionMap != null) {
+            subscriptionMap.remove(logName);
+            loggerRegistry.get(logName).removePlayer(playerName);
+            if (subscriptionMap.isEmpty()) playerSubscriptions.remove(playerName);
+        }
+    }
+
+    /**
+     * If the player is not subscribed to the log, then subscribe them. Otherwise, unsubscribe them.
+     */
+    public static boolean togglePlayerSubscription(String playerName, String logName) {
+        final Map<String, String> subscriptionMap = playerSubscriptions.get(playerName);
+
+        if (subscriptionMap == null || !subscriptionMap.containsKey(logName)) {
+            subscribePlayer(playerName, logName, null);
+            return true;
+        }
+
+        unsubscribePlayer(playerName, logName);
+        return false;
+    }
+
+    /**
+     * Get the set of logs the current player is subscribed to.
+     */
+    public static Map<String, String> getPlayerSubscriptions(String playerName) {
+        return playerSubscriptions.get(playerName);
+    }
+
+    protected static void setAccess(Logger logger) {
+        boolean value = logger.hasOnlineSubscribers();
+        try {
+            Field f = logger.getField();
+            f.setBoolean(null, value);
+        } catch (IllegalAccessException e) {
+            CarpetServer.LOGGER.error("Cannot change logger quick access field");
+        }
+    }
+
+    /**
+     * Called when the server starts. Creates the logs used by Carpet mod.
+     */
+    public static void registerLogger(String name, Logger logger) {
+        loggerRegistry.put(name, logger);
+        setAccess(logger);
+    }
+
+    public static void stopLoggers() {
+        for (Logger log : loggerRegistry.values()) {
+            log.serverStopped();
+        }
+        seenPlayers.clear();
+        loggerRegistry.clear();
+        playerSubscriptions.clear();
+    }
+
+    public static void playerConnected(Player player) {
+        boolean firstTime = !seenPlayers.add(player.getName().getString());
+        //subscribe them to the defualt loggers
+        for (Logger log : loggerRegistry.values()) {
+            log.onPlayerConnect(player, firstTime);
+        }
+    }
+
+    public static void playerDisconnected(Player player) {
+        for (Logger log : loggerRegistry.values()) {
+            log.onPlayerDisconnect(player);
+        }
+    }
+
+    public static boolean isPlayerSubscripting(String playerName, String logName) {
+        final Map<String, String> subscriptionMap = playerSubscriptions.get(playerName);
+
+        if (subscriptionMap == null) {
+            return false;
+        }
+
+        return subscriptionMap.containsKey(logName);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/ExplosionLogHelper.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/ExplosionLogHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f3e494b66da7cd7a5480285c2488ddac1f3ead3
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/ExplosionLogHelper.java
@@ -0,0 +1,96 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.Explosion;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+import static org.leavesmc.lumina.carpet.utils.Messenger.c;
+
+public class ExplosionLogHelper {
+    private final boolean createFire;
+    private final Explosion.BlockInteraction blockDestructionType;
+    private final RegistryAccess regs;
+    public final Vec3 pos;
+    private final float power;
+    private boolean affectBlocks = false;
+    private final Object2IntMap<EntityChangedStatusWithCount> impactedEntities = new Object2IntOpenHashMap<>();
+
+    private static long lastGametime = 0;
+    private static int explosionCountInCurrentGT = 0;
+    private static boolean newTick;
+
+    public ExplosionLogHelper(double x, double y, double z, float power, boolean createFire, Explosion.BlockInteraction blockDestructionType, RegistryAccess regs) {
+        this.power = power;
+        this.pos = new Vec3(x, y, z);
+        this.createFire = createFire;
+        this.blockDestructionType = blockDestructionType;
+        this.regs = regs;
+    }
+
+    public void setAffectBlocks(boolean b) {
+        affectBlocks = b;
+    }
+
+    public void onExplosionDone(long gametime) {
+        newTick = false;
+        if (!(lastGametime == gametime)) {
+            explosionCountInCurrentGT = 0;
+            lastGametime = gametime;
+            newTick = true;
+        }
+        explosionCountInCurrentGT++;
+        LoggerRegistry.getLogger("explosions").log((option) -> {
+            List<Component> messages = new ArrayList<>();
+            if (newTick) messages.add(c("wb tick : ", "d " + gametime));
+            if ("brief".equals(option)) {
+                messages.add(c("d #" + explosionCountInCurrentGT, "gb ->",
+                        Messenger.dblt("l", pos.x, pos.y, pos.z), (affectBlocks) ? "m  (affects blocks)" : "m  (doesn't affect blocks)"));
+            }
+            if ("full".equals(option)) {
+                messages.add(c("d #" + explosionCountInCurrentGT, "gb ->", Messenger.dblt("l", pos.x, pos.y, pos.z)));
+                messages.add(c("w   affects blocks: ", "m " + this.affectBlocks));
+                messages.add(c("w   creates fire: ", "m " + this.createFire));
+                messages.add(c("w   power: ", "c " + this.power));
+                messages.add(c("w   destruction: ", "c " + this.blockDestructionType.name()));
+                if (impactedEntities.isEmpty()) {
+                    messages.add(c("w   affected entities: ", "m None"));
+                } else {
+                    messages.add(c("w   affected entities:"));
+                    impactedEntities.forEach((k, v) ->
+                    {
+                        messages.add(c((k.pos.equals(pos)) ? "r   - TNT" : "w   - ",
+                                Messenger.dblt((k.pos.equals(pos)) ? "r" : "y", k.pos.x, k.pos.y, k.pos.z), "w  dV",
+                                Messenger.dblt("d", k.accel.x, k.accel.y, k.accel.z),
+                                "w  " + regs.lookupOrThrow(Registries.ENTITY_TYPE).getKey(k.type).getPath(), (v > 1) ? "l (" + v + ")" : ""
+                        ));
+                    });
+                }
+            }
+            return messages.toArray(new Component[0]);
+        });
+    }
+
+    public void onEntityImpacted(Entity entity, Vec3 accel) {
+        EntityChangedStatusWithCount ent = new EntityChangedStatusWithCount(entity, accel);
+        impactedEntities.put(ent, impactedEntities.getOrDefault(ent, 0) + 1);
+    }
+
+
+    public static record EntityChangedStatusWithCount(Vec3 pos, EntityType<?> type, Vec3 accel) {
+        public EntityChangedStatusWithCount(Entity e, Vec3 accel) {
+            this(e.position(), e.getType(), accel);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PacketCounter.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PacketCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..4be144181afab0e195f6b35d4453ded4b9a93ad9
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PacketCounter.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+public class PacketCounter {
+    public static long totalOut = 0;
+    public static long totalIn = 0;
+
+    public static void reset() {
+        totalIn = 0L;
+        totalOut = 0L;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PathfindingVisualizer.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PathfindingVisualizer.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf4111fd49530f21dd71dc380ae54637bbe529f1
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/PathfindingVisualizer.java
@@ -0,0 +1,35 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.helpers.ParticleDisplay;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+
+public class PathfindingVisualizer {
+    public static void slowPath(Entity entity, Vec3 target, float miliseconds, boolean successful) {
+        if (!LoggerRegistry.__pathfinding) return;
+        LoggerRegistry.getLogger("pathfinding").log((option, player) ->
+        {
+            if (!(player instanceof ServerPlayer))
+                return null;
+            int minDuration;
+            try {
+                minDuration = Integer.parseInt(option);
+            } catch (NumberFormatException ignored) {
+                return null;
+            }
+            if (miliseconds < minDuration)
+                return null;
+            if (player.distanceToSqr(entity) > 1000 && player.distanceToSqr(target) > 1000)
+                return null;
+            if (minDuration < 1)
+                minDuration = 1;
+
+            String accent = successful ? "happy_villager" : "angry_villager";
+            String color = (miliseconds / minDuration < 2) ? "dust 1 1 0 1" : ((miliseconds / minDuration < 4) ? "dust 1 0.5 0 1" : "dust 1 0 0 1");
+            ParticleDisplay.drawParticleLine((ServerPlayer) player, entity.position(), target, color, accent, 5, 0.5);
+            return null;
+        });
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TNTLogHelper.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TNTLogHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..d9052a7f2fa4d66b8cfd832508c9a29b7ab5c5f4
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TNTLogHelper.java
@@ -0,0 +1,50 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.phys.Vec3;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+public class TNTLogHelper {
+    public boolean initialized;
+    private double primedX, primedY, primedZ;
+    private static long lastGametime = 0;
+    private static int tntCount = 0;
+    private Vec3 primedAngle;
+
+    /**
+     * Runs when the TNT is primed. Expects the position and motion angle of the TNT.
+     */
+    public void onPrimed(double x, double y, double z, Vec3 motion) {
+        primedX = x;
+        primedY = y;
+        primedZ = z;
+        primedAngle = motion;
+        initialized = true;
+    }
+
+    /**
+     * Runs when the TNT explodes. Expects the position of the TNT.
+     */
+    public void onExploded(double x, double y, double z, long gametime) {
+        if (!(lastGametime == gametime)) {
+            tntCount = 0;
+            lastGametime = gametime;
+        }
+        tntCount++;
+        LoggerRegistry.getLogger("tnt").log((option) -> switch (option) {
+            case "brief" -> new Component[]{Messenger.c(
+                    "l P ", Messenger.dblt("l", primedX, primedY, primedZ),
+                    "w  ", Messenger.dblt("l", primedAngle.x, primedAngle.y, primedAngle.z),
+                    "r  E ", Messenger.dblt("r", x, y, z))};
+            case "full" -> new Component[]{Messenger.c(
+                    "r #" + tntCount,
+                    "m @" + gametime,
+                    "g : ",
+                    "l P ", Messenger.dblf("l", primedX, primedY, primedZ),
+                    "w  ", Messenger.dblf("l", primedAngle.x, primedAngle.y, primedAngle.z),
+                    "r  E ", Messenger.dblf("r", x, y, z))};
+            default -> null;
+        });
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TrajectoryLogHelper.java b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TrajectoryLogHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..93c3c260737bf2e3ec5627c89f021eea3f847cfb
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/logging/logHelpers/TrajectoryLogHelper.java
@@ -0,0 +1,72 @@
+package org.leavesmc.lumina.carpet.logging.logHelpers;
+
+import org.leavesmc.lumina.carpet.logging.Logger;
+import org.leavesmc.lumina.carpet.logging.LoggerRegistry;
+import org.leavesmc.lumina.carpet.utils.Messenger;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.phys.Vec3;
+
+/**
+ * A generic log helper for logging the trajectory of things like blocks and throwables.
+ */
+public class TrajectoryLogHelper {
+    private static final int MAX_TICKS_PER_LINE = 20;
+
+    private boolean doLog;
+    private final Logger logger;
+
+    private final ArrayList<Vec3> positions = new ArrayList<>();
+    private final ArrayList<Vec3> motions = new ArrayList<>();
+
+    public TrajectoryLogHelper(String logName) {
+        this.logger = LoggerRegistry.getLogger(logName);
+        this.doLog = this.logger.hasOnlineSubscribers();
+    }
+
+    public void onTick(double x, double y, double z, Vec3 velocity) {
+        if (!doLog) return;
+        positions.add(new Vec3(x, y, z));
+        motions.add(velocity);
+    }
+
+    public void onFinish() {
+        if (!doLog) return;
+        logger.log((option) -> {
+            List<Component> comp = new ArrayList<>();
+            switch (option) {
+                case "brief" -> {
+                    comp.add(Messenger.s(""));
+                    List<String> line = new ArrayList<>();
+                    for (int i = 0; i < positions.size(); i++) {
+                        Vec3 pos = positions.get(i);
+                        Vec3 mot = motions.get(i);
+                        line.add("w  x");
+                        line.add(String.format("^w Tick: %d\nx: %f\ny: %f\nz: %f\n------------\nmx: %f\nmy: %f\nmz: %f",
+                                i, pos.x, pos.y, pos.z, mot.x, mot.y, mot.z));
+                        if ((((i + 1) % MAX_TICKS_PER_LINE) == 0) || i == positions.size() - 1) {
+                            comp.add(Messenger.c(line.toArray(new Object[0])));
+                            line.clear();
+                        }
+                    }
+                }
+                case "full" -> {
+                    comp.add(Messenger.c("w ---------"));
+                    for (int i = 0; i < positions.size(); i++) {
+                        Vec3 pos = positions.get(i);
+                        Vec3 mot = motions.get(i);
+                        comp.add(Messenger.c(
+                                String.format("w tick: %3d pos", i), Messenger.dblt("w", pos.x, pos.y, pos.z),
+                                "w   mot", Messenger.dblt("w", mot.x, mot.y, mot.z)));
+                    }
+                }
+            }
+            return comp.toArray(new Component[0]);
+        });
+        doLog = false;
+    }
+}
+
diff --git a/src/main/java/org/leavesmc/lumina/carpet/patches/TickSyncedBorderExtent.java b/src/main/java/org/leavesmc/lumina/carpet/patches/TickSyncedBorderExtent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b84b143f70c3e3e82324b27cde90e4eb450a2f08
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/patches/TickSyncedBorderExtent.java
@@ -0,0 +1,145 @@
+package org.leavesmc.lumina.carpet.patches;
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.util.Mth;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.world.level.border.BorderChangeListener;
+import net.minecraft.world.level.border.BorderStatus;
+import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.phys.shapes.BooleanOp;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * This class is essentially a copy of {@link net.minecraft.world.level.border.WorldBorder.MovingBorderExtent}
+ * but instead of using real time to lerp the border
+ * this class uses the in game ticks.
+ */
+@SuppressWarnings("JavadocReference")
+public class TickSyncedBorderExtent implements WorldBorder.BorderExtent {
+    private final WorldBorder border;
+    private final long realDuration;
+    private final double tickDuration;
+    private final double from;
+    private final double to;
+
+    private int ticks;
+
+    public TickSyncedBorderExtent(WorldBorder border, long realDuration, double from, double to) {
+        this.border = border;
+        this.realDuration = realDuration;
+        this.tickDuration = realDuration / 50.0;
+        this.from = from;
+        this.to = to;
+        this.ticks = 0;
+    }
+
+    @Override
+    public double getMinX() {
+        int maxSize = this.border.getAbsoluteMaxSize();
+        return Mth.clamp(this.border.getCenterX() - this.getSize() / 2.0, -maxSize, maxSize);
+    }
+
+    @Override
+    public double getMaxX() {
+        int maxSize = this.border.getAbsoluteMaxSize();
+        return Mth.clamp(this.border.getCenterX() + this.getSize() / 2.0, -maxSize, maxSize);
+    }
+
+    @Override
+    public double getMinZ() {
+        int maxSize = this.border.getAbsoluteMaxSize();
+        return Mth.clamp(this.border.getCenterZ() - this.getSize() / 2.0, -maxSize, maxSize);
+    }
+
+    @Override
+    public double getMaxZ() {
+        int maxSize = this.border.getAbsoluteMaxSize();
+        return Mth.clamp(this.border.getCenterZ() + this.getSize() / 2.0, -maxSize, maxSize);
+    }
+
+    @Override
+    public double getSize() {
+        double progress = this.ticks / this.tickDuration;
+        return progress < 1.0 ? Mth.lerp(progress, this.from, this.to) : this.to;
+    }
+
+    @Override
+    public double getLerpSpeed() {
+        return Math.abs(this.from - this.to) / this.realDuration;
+    }
+
+    @Override
+    public long getLerpRemainingTime() {
+        // Rough estimation
+        MinecraftServer server = MinecraftServer.getServer();
+        double ms;
+        ms = ((double) server.getAverageTickTimeNanos()) / TimeUtil.NANOSECONDS_PER_MILLISECOND;
+        ServerTickRateManager trm = server.tickRateManager();
+        if (!trm.isSprinting()) {
+            ms = Math.max(ms, trm.millisecondsPerTick());
+        }
+        double tps = 1_000.0D / ms;
+        return (long) ((this.tickDuration - this.ticks) / tps * 1_000);
+    }
+
+    @Override
+    public double getLerpTarget() {
+        return this.to;
+    }
+
+    @NotNull
+    @Override
+    public BorderStatus getStatus() {
+        return this.to < this.from ? BorderStatus.SHRINKING : BorderStatus.GROWING;
+    }
+
+    @Override
+    public void onAbsoluteMaxSizeChange() {
+
+    }
+
+    @Override
+    public void onCenterChange() {
+
+    }
+
+    @NotNull
+    @Override
+    public WorldBorder.BorderExtent update() {
+        if (this.ticks++ % 20 == 0) {
+            // We need to update any listeners
+            // Most importantly those that send updates to the client
+            // This is because the client logic uses real time
+            // So if the tick speed has changed we need to tell the client
+            for (BorderChangeListener listener : this.border.getListeners()) {
+                // We do not want to update DelegateBorderChangeListener
+                // This updates borders in other dimensions
+                if (!(listener instanceof BorderChangeListener.DelegateBorderChangeListener)) {
+                    listener.onBorderSizeLerping(this.border, this.from, this.to, this.realDuration);
+                }
+            }
+        }
+
+        return this.ticks >= this.tickDuration ? this.border.new StaticBorderExtent(this.to) : this;
+    }
+
+    @NotNull
+    @Override
+    public VoxelShape getCollisionShape() {
+        return Shapes.join(
+                Shapes.INFINITY,
+                Shapes.box(
+                        Math.floor(this.getMinX()),
+                        Double.NEGATIVE_INFINITY,
+                        Math.floor(this.getMinZ()),
+                        Math.ceil(this.getMaxX()),
+                        Double.POSITIVE_INFINITY,
+                        Math.ceil(this.getMaxZ())
+                ),
+                BooleanOp.ONLY_FIRST
+        );
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/script/utils/Colors.java b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Colors.java
new file mode 100644
index 0000000000000000000000000000000000000000..a85fc086dfd15b30d6066fd888fb17507dd0e26d
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Colors.java
@@ -0,0 +1,155 @@
+package org.leavesmc.lumina.carpet.script.utils;
+
+import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.material.MapColor;
+
+import java.util.Map;
+
+import static java.util.Map.entry;
+
+public class Colors {
+    public static final Map<SoundType, String> soundName = Map.<SoundType, String>ofEntries(
+            entry(SoundType.WOOD, "wood"),
+            entry(SoundType.GRAVEL, "gravel"),
+            entry(SoundType.GRASS, "grass"),
+            entry(SoundType.LILY_PAD, "lily_pad"),
+            entry(SoundType.STONE, "stone"),
+            entry(SoundType.METAL, "metal"),
+            entry(SoundType.GLASS, "glass"),
+            entry(SoundType.WOOL, "wool"),
+            entry(SoundType.SAND, "sand"),
+            entry(SoundType.SNOW, "snow"),
+            entry(SoundType.POWDER_SNOW, "powder_snow"),
+            entry(SoundType.LADDER, "ladder"),
+            entry(SoundType.ANVIL, "anvil"),
+            entry(SoundType.SLIME_BLOCK, "slime"),
+            entry(SoundType.HONEY_BLOCK, "honey"),
+            entry(SoundType.WET_GRASS, "sea_grass"),
+            entry(SoundType.CORAL_BLOCK, "coral"),
+            entry(SoundType.BAMBOO, "bamboo"),
+            entry(SoundType.BAMBOO_SAPLING, "shoots"),
+            entry(SoundType.SCAFFOLDING, "scaffolding"),
+            entry(SoundType.SWEET_BERRY_BUSH, "berry"),
+            entry(SoundType.CROP, "crop"),
+            entry(SoundType.HARD_CROP, "stem"),
+            entry(SoundType.VINE, "vine"),
+            entry(SoundType.NETHER_WART, "wart"),
+            entry(SoundType.LANTERN, "lantern"),
+            entry(SoundType.STEM, "fungi_stem"),
+            entry(SoundType.NYLIUM, "nylium"),
+            entry(SoundType.FUNGUS, "fungus"),
+            entry(SoundType.ROOTS, "roots"),
+            entry(SoundType.SHROOMLIGHT, "shroomlight"),
+            entry(SoundType.WEEPING_VINES, "weeping_vine"),
+            entry(SoundType.TWISTING_VINES, "twisting_vine"),
+            entry(SoundType.SOUL_SAND, "soul_sand"),
+            entry(SoundType.SOUL_SOIL, "soul_soil"),
+            entry(SoundType.BASALT, "basalt"),
+            entry(SoundType.WART_BLOCK, "wart"),
+            entry(SoundType.NETHERRACK, "netherrack"),
+            entry(SoundType.NETHER_BRICKS, "nether_bricks"),
+            entry(SoundType.NETHER_SPROUTS, "nether_sprouts"),
+            entry(SoundType.NETHER_ORE, "nether_ore"),
+            entry(SoundType.BONE_BLOCK, "bone"),
+            entry(SoundType.NETHERITE_BLOCK, "netherite"),
+            entry(SoundType.ANCIENT_DEBRIS, "ancient_debris"),
+            entry(SoundType.LODESTONE, "lodestone"),
+            entry(SoundType.CHAIN, "chain"),
+            entry(SoundType.NETHER_GOLD_ORE, "nether_gold_ore"),
+            entry(SoundType.GILDED_BLACKSTONE, "gilded_blackstone"),
+            entry(SoundType.CANDLE, "candle"),
+            entry(SoundType.AMETHYST, "amethyst"),
+            entry(SoundType.AMETHYST_CLUSTER, "amethyst_cluster"),
+            entry(SoundType.SMALL_AMETHYST_BUD, "small_amethyst_bud"),
+            entry(SoundType.MEDIUM_AMETHYST_BUD, "medium_amethyst_bud"),
+            entry(SoundType.LARGE_AMETHYST_BUD, "large_amethyst_bud"),
+
+            entry(SoundType.TUFF, "tuff"),
+            entry(SoundType.CALCITE, "calcite"),
+            entry(SoundType.DRIPSTONE_BLOCK, "dripstone"),
+            entry(SoundType.POINTED_DRIPSTONE, "pointed_dripstone"),
+            entry(SoundType.COPPER, "copper"),
+            entry(SoundType.CAVE_VINES, "cave_vine"),
+            entry(SoundType.SPORE_BLOSSOM, "spore_blossom"),
+            entry(SoundType.AZALEA, "azalea"),
+            entry(SoundType.FLOWERING_AZALEA, "flowering_azalea"),
+            entry(SoundType.MOSS_CARPET, "moss_carpet"),
+            entry(SoundType.MOSS, "moss"),
+            entry(SoundType.BIG_DRIPLEAF, "big_dripleaf"),
+            entry(SoundType.SMALL_DRIPLEAF, "small_dripleaf"),
+            entry(SoundType.ROOTED_DIRT, "rooted_dirt"),
+            entry(SoundType.HANGING_ROOTS, "hanging_roots"),
+            entry(SoundType.AZALEA_LEAVES, "azalea_leaves"),
+            entry(SoundType.SCULK_SENSOR, "sculk_sensor"),
+            entry(SoundType.GLOW_LICHEN, "glow_lichen"),
+            entry(SoundType.DEEPSLATE, "deepslate"),
+            entry(SoundType.DEEPSLATE_BRICKS, "deepslate_bricks"),
+            entry(SoundType.DEEPSLATE_TILES, "deepslate_tiles"),
+            entry(SoundType.POLISHED_DEEPSLATE, "polished_deepslate")
+    );
+
+    public static final Map<MapColor, String> mapColourName = Map.<MapColor, String>ofEntries(
+            entry(MapColor.NONE, "air"),
+            entry(MapColor.GRASS, "grass"),
+            entry(MapColor.SAND, "sand"),
+            entry(MapColor.WOOL, "wool"),
+            entry(MapColor.FIRE, "tnt"),
+            entry(MapColor.ICE, "ice"),
+            entry(MapColor.METAL, "iron"),
+            entry(MapColor.PLANT, "foliage"),
+            entry(MapColor.SNOW, "snow"),
+            entry(MapColor.CLAY, "clay"),
+            entry(MapColor.DIRT, "dirt"),
+            entry(MapColor.STONE, "stone"),
+            entry(MapColor.WATER, "water"),
+            entry(MapColor.WOOD, "wood"),
+            entry(MapColor.QUARTZ, "quartz"),
+            entry(MapColor.COLOR_ORANGE, "adobe"),
+            entry(MapColor.COLOR_MAGENTA, "magenta"),
+            entry(MapColor.COLOR_LIGHT_BLUE, "light_blue"),
+            entry(MapColor.COLOR_YELLOW, "yellow"),
+            entry(MapColor.COLOR_LIGHT_GREEN, "lime"),
+            entry(MapColor.COLOR_PINK, "pink"),
+            entry(MapColor.COLOR_GRAY, "gray"),
+            entry(MapColor.COLOR_LIGHT_GRAY, "light_gray"),
+            entry(MapColor.COLOR_CYAN, "cyan"),
+            entry(MapColor.COLOR_PURPLE, "purple"),
+            entry(MapColor.COLOR_BLUE, "blue"),
+            entry(MapColor.COLOR_BROWN, "brown"),
+            entry(MapColor.COLOR_GREEN, "green"),
+            entry(MapColor.COLOR_RED, "red"),
+            entry(MapColor.COLOR_BLACK, "black"),
+            entry(MapColor.GOLD, "gold"),
+            entry(MapColor.DIAMOND, "diamond"),
+            entry(MapColor.LAPIS, "lapis"),
+            entry(MapColor.EMERALD, "emerald"),
+            entry(MapColor.PODZOL, "obsidian"),
+            entry(MapColor.NETHER, "netherrack"), // TODO fix these
+            entry(MapColor.TERRACOTTA_WHITE, "white_terracotta"),
+            entry(MapColor.TERRACOTTA_ORANGE, "orange_terracotta"),
+            entry(MapColor.TERRACOTTA_MAGENTA, "magenta_terracotta"),
+            entry(MapColor.TERRACOTTA_LIGHT_BLUE, "light_blue_terracotta"),
+            entry(MapColor.TERRACOTTA_YELLOW, "yellow_terracotta"),
+            entry(MapColor.TERRACOTTA_LIGHT_GREEN, "lime_terracotta"),
+            entry(MapColor.TERRACOTTA_PINK, "pink_terracotta"),
+            entry(MapColor.TERRACOTTA_GRAY, "gray_terracotta"),
+            entry(MapColor.TERRACOTTA_LIGHT_GRAY, "light_gray_terracotta"),
+            entry(MapColor.TERRACOTTA_CYAN, "cyan_terracotta"),
+            entry(MapColor.TERRACOTTA_PURPLE, "purple_terracotta"),
+            entry(MapColor.TERRACOTTA_BLUE, "blue_terracotta"),
+            entry(MapColor.TERRACOTTA_BROWN, "brown_terracotta"),
+            entry(MapColor.TERRACOTTA_GREEN, "green_terracotta"),
+            entry(MapColor.TERRACOTTA_RED, "red_terracotta"),
+            entry(MapColor.TERRACOTTA_BLACK, "black_terracotta"),
+            entry(MapColor.CRIMSON_NYLIUM, "crimson_nylium"),
+            entry(MapColor.CRIMSON_STEM, "crimson_stem"),
+            entry(MapColor.CRIMSON_HYPHAE, "crimson_hyphae"),
+            entry(MapColor.WARPED_NYLIUM, "warped_nylium"),
+            entry(MapColor.WARPED_STEM, "warped_stem"),
+            entry(MapColor.WARPED_HYPHAE, "warped_hyphae"),
+            entry(MapColor.WARPED_WART_BLOCK, "warped_wart"),
+            entry(MapColor.DEEPSLATE, "deepslate"),
+            entry(MapColor.RAW_IRON, "raw_iron"),
+            entry(MapColor.GLOW_LICHEN, "glow_lichen")
+    );
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/script/utils/ParticleParser.java b/src/main/java/org/leavesmc/lumina/carpet/script/utils/ParticleParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..2eb8d9aaa421ecbd0ae7b3969ce53113d67fe0be
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/script/utils/ParticleParser.java
@@ -0,0 +1,44 @@
+package org.leavesmc.lumina.carpet.script.utils;
+
+import com.google.common.collect.Maps;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.minecraft.commands.arguments.ParticleArgument;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.particles.ParticleOptions;
+
+import javax.annotation.Nullable;
+import java.util.HashMap;
+import java.util.Map;
+
+public class ParticleParser
+{
+    private static final Map<String, ParticleOptions> particleCache = Maps.newConcurrentMap(); // we reset this on reloads, but probably need something better
+
+    private static ParticleOptions parseParticle(String name, RegistryAccess lookup)
+    {
+        try
+        {
+            return ParticleArgument.readParticle(new StringReader(name), lookup);
+        }
+        catch (CommandSyntaxException e)
+        {
+            throw new IllegalArgumentException("No such particle: " + name);
+        }
+    }
+
+    @Nullable
+    public static ParticleOptions getEffect(@Nullable String name, RegistryAccess lookup)
+    {
+        if (name == null)
+        {
+            return null;
+        }
+        return particleCache.computeIfAbsent(name, particle -> parseParticle(particle, lookup));
+    }
+
+    public static void resetCache()
+    {
+        particleCache.clear();
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/script/utils/Tracer.java b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Tracer.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc9b7281eadf2ca97ded226c19559b0d3d5334b5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/script/utils/Tracer.java
@@ -0,0 +1,74 @@
+package org.leavesmc.lumina.carpet.script.utils;
+
+import java.util.Optional;
+import java.util.function.Predicate;
+
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+
+public class Tracer {
+    public static HitResult rayTrace(Entity source, float partialTicks, double reach, boolean fluids) {
+        BlockHitResult blockHit = rayTraceBlocks(source, partialTicks, reach, fluids);
+        double maxSqDist = reach * reach;
+        if (blockHit != null) {
+            maxSqDist = blockHit.getLocation().distanceToSqr(source.getEyePosition(partialTicks));
+        }
+        EntityHitResult entityHit = rayTraceEntities(source, partialTicks, reach, maxSqDist);
+        return entityHit == null ? blockHit : entityHit;
+    }
+
+    public static BlockHitResult rayTraceBlocks(Entity source, float partialTicks, double reach, boolean fluids) {
+        Vec3 pos = source.getEyePosition(partialTicks);
+        Vec3 rotation = source.getViewVector(partialTicks);
+        Vec3 reachEnd = pos.add(rotation.x * reach, rotation.y * reach, rotation.z * reach);
+        return source.level().clip(new ClipContext(pos, reachEnd, ClipContext.Block.OUTLINE, fluids ?
+                ClipContext.Fluid.ANY : ClipContext.Fluid.NONE, source));
+    }
+
+    public static EntityHitResult rayTraceEntities(Entity source, float partialTicks, double reach, double maxSqDist) {
+        Vec3 pos = source.getEyePosition(partialTicks);
+        Vec3 reachVec = source.getViewVector(partialTicks).scale(reach);
+        AABB box = source.getBoundingBox().expandTowards(reachVec).inflate(1);
+        return rayTraceEntities(source, pos, pos.add(reachVec), box, e -> !e.isSpectator() && e.isPickable(), maxSqDist);
+    }
+
+    public static EntityHitResult rayTraceEntities(Entity source, Vec3 start, Vec3 end, AABB box, Predicate<Entity> predicate, double maxSqDistance) {
+        Level world = source.level();
+        double targetDistance = maxSqDistance;
+        Entity target = null;
+        Vec3 targetHitPos = null;
+        for (Entity current : world.getEntities(source, box, predicate)) {
+            AABB currentBox = current.getBoundingBox().inflate(current.getPickRadius());
+            Optional<Vec3> currentHit = currentBox.clip(start, end);
+            if (currentBox.contains(start)) {
+                if (targetDistance >= 0) {
+                    target = current;
+                    targetHitPos = currentHit.orElse(start);
+                    targetDistance = 0;
+                }
+            } else if (currentHit.isPresent()) {
+                Vec3 currentHitPos = currentHit.get();
+                double currentDistance = start.distanceToSqr(currentHitPos);
+                if (currentDistance < targetDistance || targetDistance == 0) {
+                    if (current.getRootVehicle() == source.getRootVehicle()) {
+                        if (targetDistance == 0) {
+                            target = current;
+                            targetHitPos = currentHitPos;
+                        }
+                    } else {
+                        target = current;
+                        targetHitPos = currentHitPos;
+                        targetDistance = currentDistance;
+                    }
+                }
+            }
+        }
+        return target == null ? null : new EntityHitResult(target, targetHitPos);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/BlockInfo.java b/src/main/java/org/leavesmc/lumina/carpet/utils/BlockInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..d35a4dbd9ef43be2132c990edc0c7a9a0bf3e7ba
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/BlockInfo.java
@@ -0,0 +1,112 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.world.entity.EntitySpawnReason;
+import org.leavesmc.lumina.carpet.script.utils.Colors;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.PathfinderMob;
+import net.minecraft.world.entity.ai.goal.RandomStrollGoal;
+import net.minecraft.world.entity.ai.util.DefaultRandomPos;
+import net.minecraft.world.entity.monster.ZombifiedPiglin;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.phys.Vec3;
+
+public class BlockInfo
+{
+    public static List<Component> blockInfo(BlockPos pos, ServerLevel world)
+    {
+        BlockState state = world.getBlockState(pos);
+        Block block = state.getBlock();
+        String metastring = "";
+        final Registry<Block> blocks = world.registryAccess().lookupOrThrow(Registries.BLOCK);
+        for (net.minecraft.world.level.block.state.properties.Property<?> iproperty : state.getProperties())
+        {
+            metastring += ", "+iproperty.getName() + '='+state.getValue(iproperty);
+        }
+        List<Component> lst = new ArrayList<>();
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s("====================================="));
+        lst.add(Messenger.s(String.format("Block info for %s%s (id %d%s):", blocks.getKey(block),metastring, blocks.getId(block), metastring )));
+        lst.add(Messenger.s(String.format(" - Map colour: %s", Colors.mapColourName.get(state.getMapColor(world, pos)))));
+        lst.add(Messenger.s(String.format(" - Sound type: %s", Colors.soundName.get(state.getSoundType()))));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Full block: %s", state.isCollisionShapeFullBlock(world, pos)))); //  isFullCube() )));
+        lst.add(Messenger.s(String.format(" - Normal cube: %s", state.isRedstoneConductor(world, pos)))); //isNormalCube()))); isSimpleFullBlock
+        lst.add(Messenger.s(String.format(" - Is liquid: %s", state.is(Blocks.WATER) || state.is(Blocks.LAVA))));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Light in: %d, above: %d",
+                Math.max(world.getBrightness(LightLayer.BLOCK, pos),world.getBrightness(LightLayer.SKY, pos)) ,
+                Math.max(world.getBrightness(LightLayer.BLOCK, pos.above()),world.getBrightness(LightLayer.SKY, pos.above())))));
+        lst.add(Messenger.s(String.format(" - Brightness in: %.2f, above: %.2f", world.getLightLevelDependentMagicValue(pos), world.getLightLevelDependentMagicValue(pos.above()))));
+        lst.add(Messenger.s(String.format(" - Is opaque: %s", state.isSolid() )));
+        //lst.add(Messenger.s(String.format(" - Light opacity: %d", state.getOpacity(world,pos))));
+        //lst.add(Messenger.s(String.format(" - Emitted light: %d", state.getLightValue())));
+        //lst.add(Messenger.s(String.format(" - Picks neighbour light value: %s", state.useNeighborBrightness(world, pos))));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Causes suffocation: %s", state.isSuffocating(world, pos)))); //canSuffocate
+        lst.add(Messenger.s(String.format(" - Blocks movement on land: %s", !state.isPathfindable(PathComputationType.LAND))));
+        lst.add(Messenger.s(String.format(" - Blocks movement in air: %s", !state.isPathfindable(PathComputationType.AIR))));
+        lst.add(Messenger.s(String.format(" - Blocks movement in liquids: %s", !state.isPathfindable(PathComputationType.WATER))));
+        lst.add(Messenger.s(String.format(" - Can burn: %s", state.ignitedByLava())));
+        lst.add(Messenger.s(String.format(" - Hardness: %.2f", state.getDestroySpeed(world, pos))));
+        lst.add(Messenger.s(String.format(" - Blast resistance: %.2f", block.getExplosionResistance())));
+        lst.add(Messenger.s(String.format(" - Ticks randomly: %s", state.isRandomlyTicking())));
+        lst.add(Messenger.s(""));
+        lst.add(Messenger.s(String.format(" - Can provide power: %s", state.isSignalSource())));
+        lst.add(Messenger.s(String.format(" - Strong power level: %d", world.getDirectSignalTo(pos))));
+        lst.add(Messenger.s(String.format(" - Redstone power level: %d", world.getBestNeighborSignal(pos))));
+        lst.add(Messenger.s(""));
+        lst.add(wander_chances(pos.above(), world));
+
+        return lst;
+    }
+
+    private static Component wander_chances(BlockPos pos, ServerLevel worldIn)
+    {
+        PathfinderMob creature = new ZombifiedPiglin(EntityType.ZOMBIFIED_PIGLIN, worldIn);
+        creature.finalizeSpawn(worldIn, worldIn.getCurrentDifficultyAt(pos), EntitySpawnReason.NATURAL, null);
+        creature.moveTo(pos, 0.0F, 0.0F);
+        RandomStrollGoal wander = new RandomStrollGoal(creature, 0.8D);
+        int success = 0;
+        for (int i=0; i<1000; i++)
+        {
+
+            Vec3 vec = DefaultRandomPos.getPos(creature, 10, 7); // TargetFinder.findTarget(creature, 10, 7);
+            if (vec == null)
+            {
+                continue;
+            }
+            success++;
+        }
+        long total_ticks = 0;
+        for (int trie=0; trie<1000; trie++)
+        {
+            int i;
+            for (i=1;i<30*20*60; i++) //*60 used to be 5 hours, limited to 30 mins
+            {
+                if (wander.canUse())
+                {
+                    break;
+                }
+            }
+            total_ticks += 3*i;
+        }
+        creature.discard(); // discarded // remove(Entity.RemovalReason.field_26999); // 2nd option - DISCARDED
+        long total_time = (total_ticks)/1000/20;
+        return Messenger.s(String.format(" - Wander chance above: %.1f%%\n - Average standby above: %s",
+                (100.0F*success)/1000,
+                ((total_time>5000)?"INFINITY":(total_time +" s"))
+        ));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/CarpetRulePrinter.java b/src/main/java/org/leavesmc/lumina/carpet/utils/CarpetRulePrinter.java
new file mode 100644
index 0000000000000000000000000000000000000000..1affe86d3db96ccf54f2f74741ef82e0e94c064d
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/CarpetRulePrinter.java
@@ -0,0 +1,63 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import joptsimple.OptionParser;
+import joptsimple.OptionSet;
+import joptsimple.OptionSpec;
+import joptsimple.util.PathConverter;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.lang.System;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Provides a command line interface to generate a dump with all rules
+ * in a pretty markdown format to a specified file, with an optional
+ * category filter
+ */
+public class CarpetRulePrinter {
+    public void onInitializeServer() {
+        // When launching, we use the "--" separator to prevent the game rejecting to launch because of unknown options
+        // Clear it in case it's present given else our option parser would also ignore them!
+        String[] args = new String[]{};
+        // Arrays.stream(FabricLoader.getInstance().getLaunchArguments(true)).filter(opt -> !opt.equals("--")).toArray(String[]::new); // TODO
+
+        // Prepare an OptionParser for our parameters
+        OptionParser parser = new OptionParser();
+        OptionSpec<Void> shouldDump = parser.accepts("carpetDumpRules");
+        OptionSpec<Path> pathSpec = parser.accepts("dumpPath").withRequiredArg().withValuesConvertedBy(new PathConverter());
+        OptionSpec<String> filterSpec = parser.accepts("dumpFilter").withRequiredArg();
+        parser.allowsUnrecognizedOptions(); // minecraft may need more stuff later that we don't want to special-case
+        OptionSet options = parser.parse(args);
+        // If our flag isn't set, continue regular launch
+        if (!options.has(shouldDump)) return;
+
+
+        Logger logger = LoggerFactory.getLogger("Carpet Rule Printer");
+        logger.info("Starting in rule dump mode...");
+        // at this point, onGameStarted() already ran given it as an entrypoint runs before
+        PrintStream outputStream;
+        try {
+            Path path = options.valueOf(pathSpec).toAbsolutePath();
+            logger.info("Printing rules to: " + path);
+            Files.createDirectories(path.getParent());
+            outputStream = new PrintStream(Files.newOutputStream(path));
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+        // Ensure translations fallbacks have been generated given we run before the validator that ensures that has.
+        // Remove after removing old setting system, given there'll be no fallbacks
+        Translations.updateLanguage();
+        String filter = options.valueOf(filterSpec);
+        if (filter != null) logger.info("Applying category filter: " + filter);
+        // CarpetServer.settingsManager.dumpAllRulesToStream(outputStream, filter); // TODO
+        outputStream.close();
+        logger.info("Rules have been printed");
+        System.exit(0);
+    }
+}
+
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/ConfigIdentifier.java b/src/main/java/org/leavesmc/lumina/carpet/utils/ConfigIdentifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..877e536f33ea784ecfe695cb2cbf20a1c972dec7
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/ConfigIdentifier.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target({ElementType.FIELD})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ConfigIdentifier {
+    String value();
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/DistanceCalculator.java b/src/main/java/org/leavesmc/lumina/carpet/utils/DistanceCalculator.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd15a409c0488dce5eb23d625c4b3ac212c75c78
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/DistanceCalculator.java
@@ -0,0 +1,97 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.utils.ComponentUtils;
+
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
+import static net.kyori.adventure.text.format.Style.style;
+import static net.kyori.adventure.text.format.TextDecoration.*;
+
+public class DistanceCalculator {
+    public static final HashMap<String, Vec3> START_POINT_STORAGE = new HashMap<>();
+
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public static boolean hasStartingPoint(@NotNull CommandSender sender) {
+        return START_POINT_STORAGE.containsKey(sender.getName());
+    }
+
+    public static @NotNull List<Component> findDistanceBetweenTwoPoints(@NotNull Vec3 pos1, @NotNull Vec3 pos2) {
+        double dx = Mth.abs((float) pos1.x - (float) pos2.x);
+        double dy = Mth.abs((float) pos1.y - (float) pos2.y);
+        double dz = Mth.abs((float) pos1.z - (float) pos2.z);
+        double manhattan = dx + dy + dz;
+        double spherical = Math.sqrt(dx * dx + dy * dy + dz * dz);
+        double cylindrical = Math.sqrt(dx * dx + dz * dz);
+        List<Component> res = new ArrayList<>();
+        res.add(Messenger.c("w Distance between ",
+                Messenger.tp("c", pos1), "w  and ",
+                Messenger.tp("c", pos2), "w :"));
+        res.add(Messenger.c("w  - Spherical: ", String.format("wb %.2f", spherical)));
+        res.add(Messenger.c("w  - Cylindrical: ", String.format("wb %.2f", cylindrical)));
+        res.add(Messenger.c("w  - Manhattan: ", String.format("wb %.1f", manhattan)));
+        return res;
+    }
+
+    public static void distance(CommandSender sender, Vec3 pos1, Vec3 pos2) {
+        for (Component message : findDistanceBetweenTwoPoints(pos1, pos2)) {
+            sender.sendMessage(ComponentUtils.toAdventure(message));
+        }
+    }
+
+    public static int setStart(@NotNull CommandSender sender, Vec3 pos) {
+        START_POINT_STORAGE.put(sender.getName(), pos);
+        sender.sendMessage(ComponentUtils.toAdventure(
+                Messenger.c("gi Initial point set to: ", Messenger.tp("g", pos))));
+        return 1;
+    }
+
+    public static void setEnd(CommandSender sender, Vec3 pos) {
+        if (!hasStartingPoint(sender)) {
+            START_POINT_STORAGE.put(sender.getName(), pos);
+            sender.sendMessage(text("There was no initial point for " + sender.getName()));
+            sender.sendMessage(ComponentUtils.toAdventure(
+                    Messenger.c("gi Initial point set to: ", Messenger.tp("g", pos))));
+            return;
+        }
+        for (Component message : findDistanceBetweenTwoPoints(START_POINT_STORAGE.get(sender.getName()), pos)) {
+            sender.sendMessage(ComponentUtils.toAdventure(message));
+        }
+    }
+
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public static boolean hasStartingPoint(@NotNull CommandSourceStack source) {
+        return START_POINT_STORAGE.containsKey(source.getTextName());
+    }
+
+    public static int distance(CommandSourceStack source, Vec3 pos1, Vec3 pos2) {
+        Messenger.send(source, findDistanceBetweenTwoPoints(pos1, pos2));
+        return 1;
+    }
+
+    public static void setStart(@NotNull CommandSourceStack source, Vec3 pos) {
+        START_POINT_STORAGE.put(source.getTextName(), pos);
+        Messenger.m(source, "gi Initial point set to: ", Messenger.tp("g", pos));
+    }
+
+    public static void setEnd(CommandSourceStack source, Vec3 pos) {
+        if (!hasStartingPoint(source)) {
+            START_POINT_STORAGE.put(source.getTextName(), pos);
+            Messenger.m(source, "gi There was no initial point for " + source.getTextName());
+            Messenger.m(source, "gi Initial point set to: ", Messenger.tp("g", pos));
+            return;
+        }
+        Messenger.send(source, findDistanceBetweenTwoPoints(START_POINT_STORAGE.get(source.getTextName()), pos));
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/EvictingQueue.java b/src/main/java/org/leavesmc/lumina/carpet/utils/EvictingQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..3da1c5a39484ae2e0b394ab02f48e0fac0872e15
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/EvictingQueue.java
@@ -0,0 +1,15 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public class EvictingQueue<K> extends LinkedHashMap<K, Integer> {
+    public void put(K key) {
+        super.put(key, 1);
+    }
+
+    @Override
+    protected boolean removeEldestEntry(Map.Entry<K, Integer> eldest) {
+        return this.size() > 10;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/Messenger.java b/src/main/java/org/leavesmc/lumina/carpet/utils/Messenger.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e764f32a56b8d353a852901f6c78ddc93c53191
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/Messenger.java
@@ -0,0 +1,308 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import net.minecraft.ChatFormatting;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.ClickEvent;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.command.CommandSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class Messenger {
+    public static final Logger LOG = LoggerFactory.getLogger("Messaging System");
+
+    private static final Pattern colorExtract = Pattern.compile("#([0-9a-fA-F]{6})");
+
+    public enum CarpetFormatting {
+        ITALIC('i', (s, f) -> s.withItalic(true)),
+        STRIKE('s', (s, f) -> s.applyFormat(ChatFormatting.STRIKETHROUGH)),
+        UNDERLINE('u', (s, f) -> s.applyFormat(ChatFormatting.UNDERLINE)),
+        BOLD('b', (s, f) -> s.withBold(true)),
+        OBFUSCATE('o', (s, f) -> s.applyFormat(ChatFormatting.OBFUSCATED)),
+
+        WHITE('w', (s, f) -> s.withColor(ChatFormatting.WHITE)),
+        YELLOW('y', (s, f) -> s.withColor(ChatFormatting.YELLOW)),
+        LIGHT_PURPLE('m', (s, f) -> s.withColor(ChatFormatting.LIGHT_PURPLE)), // magenta
+        RED('r', (s, f) -> s.withColor(ChatFormatting.RED)),
+        AQUA('c', (s, f) -> s.withColor(ChatFormatting.AQUA)), // cyan
+        GREEN('l', (s, f) -> s.withColor(ChatFormatting.GREEN)), // lime
+        BLUE('t', (s, f) -> s.withColor(ChatFormatting.BLUE)), // light blue, teal
+        DARK_GRAY('f', (s, f) -> s.withColor(ChatFormatting.DARK_GRAY)),
+        GRAY('g', (s, f) -> s.withColor(ChatFormatting.GRAY)),
+        GOLD('d', (s, f) -> s.withColor(ChatFormatting.GOLD)),
+        DARK_PURPLE('p', (s, f) -> s.withColor(ChatFormatting.DARK_PURPLE)), // purple
+        DARK_RED('n', (s, f) -> s.withColor(ChatFormatting.DARK_RED)),  // brown
+        DARK_AQUA('q', (s, f) -> s.withColor(ChatFormatting.DARK_AQUA)),
+        DARK_GREEN('e', (s, f) -> s.withColor(ChatFormatting.DARK_GREEN)),
+        DARK_BLUE('v', (s, f) -> s.withColor(ChatFormatting.DARK_BLUE)), // navy
+        BLACK('k', (s, f) -> s.withColor(ChatFormatting.BLACK)),
+
+        COLOR('#', (s, f) -> {
+            TextColor color;
+            try {
+                color = TextColor.parseColor("#" + f).getOrThrow(RuntimeException::new);
+            } catch (RuntimeException e) {
+                return s;
+            }
+            return color == null ? s : s.withColor(color);
+        }, s -> {
+            Matcher m = colorExtract.matcher(s);
+            return m.find() ? m.group(1) : null;
+        }),
+        ;
+
+        public char code;
+        public BiFunction<Style, String, Style> applier;
+        public Function<String, String> container;
+
+        CarpetFormatting(char code, BiFunction<Style, String, Style> applier) {
+            this(code, applier, s -> s.indexOf(code) >= 0 ? Character.toString(code) : null);
+        }
+
+        CarpetFormatting(char code, BiFunction<Style, String, Style> applier, Function<String, String> container) {
+            this.code = code;
+            this.applier = applier;
+            this.container = container;
+        }
+
+        public Style apply(String format, Style previous) {
+            String fmt;
+            if ((fmt = container.apply(format)) != null) return applier.apply(previous, fmt);
+            return previous;
+        }
+    }
+
+    ;
+
+    public static Style parseStyle(String style) {
+        Style myStyle = Style.EMPTY.withColor(ChatFormatting.WHITE);
+        for (CarpetFormatting cf : CarpetFormatting.values()) myStyle = cf.apply(style, myStyle);
+        return myStyle;
+    }
+
+    public static String heatmap_color(double actual, double reference) {
+        String color = "g";
+        if (actual >= 0.0D) color = "e";
+        if (actual > 0.5D * reference) color = "y";
+        if (actual > 0.8D * reference) color = "r";
+        if (actual > reference) color = "m";
+        return color;
+    }
+
+    public static String creatureTypeColor(MobCategory type) {
+        return switch (type) {
+            case MONSTER -> "n";
+            case CREATURE -> "e";
+            case AMBIENT -> "f";
+            case WATER_CREATURE -> "v";
+            case WATER_AMBIENT -> "q";
+            default -> "w"; // missing MISC and UNDERGROUND_WATER_CREATURE
+        };
+    }
+
+    private static MutableComponent getChatComponentFromDesc(String message, MutableComponent previousMessage) {
+        if (message.equalsIgnoreCase("")) {
+            return Component.literal("");
+        }
+        if (Character.isWhitespace(message.charAt(0))) {
+            message = "w" + message;
+        }
+        int limit = message.indexOf(' ');
+        String desc = message;
+        String str = "";
+        if (limit >= 0) {
+            desc = message.substring(0, limit);
+            str = message.substring(limit + 1);
+        }
+        if (previousMessage == null) {
+            MutableComponent text = Component.literal(str);
+            text.setStyle(parseStyle(desc));
+            return text;
+        }
+        Style previousStyle = previousMessage.getStyle();
+        MutableComponent ret = previousMessage;
+        previousMessage.setStyle(switch (desc.charAt(0)) {
+            case '?' ->
+                    previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, message.substring(1)));
+            case '!' ->
+                    previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, message.substring(1)));
+            case '^' ->
+                    previousStyle.withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, c(message.substring(1))));
+            case '@' -> previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, message.substring(1)));
+            case '&' ->
+                    previousStyle.withClickEvent(new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, message.substring(1)));
+            default -> { // Create a new component
+                ret = Component.literal(str);
+                ret.setStyle(parseStyle(desc));
+                yield previousStyle; // no op for the previous style
+            }
+        });
+        return ret;
+    }
+
+    public static Component tp(String desc, Vec3 pos) {
+        return tp(desc, pos.x, pos.y, pos.z);
+    }
+
+    public static Component tp(String desc, BlockPos pos) {
+        return tp(desc, pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    public static Component tp(String desc, double x, double y, double z) {
+        return tp(desc, (float) x, (float) y, (float) z);
+    }
+
+    public static Component tp(String desc, float x, float y, float z) {
+        return getCoordsTextComponent(desc, x, y, z, false);
+    }
+
+    public static Component tp(String desc, int x, int y, int z) {
+        return getCoordsTextComponent(desc, x, y, z, true);
+    }
+
+    /// to be continued
+    public static Component dbl(String style, double double_value) {
+        return c(String.format("%s %.1f", style, double_value), String.format("^w %f", double_value));
+    }
+
+    public static Component dbls(String style, double... doubles) {
+        StringBuilder str = new StringBuilder(style + " [ ");
+        String prefix = "";
+        for (double dbl : doubles) {
+            str.append(String.format("%s%.1f", prefix, dbl));
+            prefix = ", ";
+        }
+        str.append(" ]");
+        return c(str.toString());
+    }
+
+    public static Component dblf(String style, double... doubles) {
+        StringBuilder str = new StringBuilder(style + " [ ");
+        String prefix = "";
+        for (double dbl : doubles) {
+            str.append(String.format("%s%f", prefix, dbl));
+            prefix = ", ";
+        }
+        str.append(" ]");
+        return c(str.toString());
+    }
+
+    public static Component dblt(String style, double... doubles) {
+        List<Object> components = new ArrayList<>();
+        components.add(style + " [ ");
+        String prefix = "";
+        for (double dbl : doubles) {
+
+            components.add(String.format("%s %s%.1f", style, prefix, dbl));
+            components.add("?" + dbl);
+            components.add("^w " + dbl);
+            prefix = ", ";
+        }
+        // components.remove(components.size()-1);
+        components.add(style + "  ]");
+        return c(components.toArray(new Object[0]));
+    }
+
+    private static Component getCoordsTextComponent(String style, float x, float y, float z, boolean isInt) {
+        String text;
+        String command;
+        if (isInt) {
+            text = String.format("%s [ %d, %d, %d ]", style, (int) x, (int) y, (int) z);
+            command = String.format("!/tp %d %d %d", (int) x, (int) y, (int) z);
+        } else {
+            text = String.format("%s [ %.1f, %.1f, %.1f]", style, x, y, z);
+            command = String.format("!/tp %.3f %.3f %.3f", x, y, z);
+        }
+        return c(text, command);
+    }
+
+    // message source
+    public static void m(CommandSourceStack source, Object... fields) {
+        if (source != null)
+            source.sendSuccess(() -> Messenger.c(fields), source.getServer() != null && source.getServer().overworld() != null);
+    }
+
+    public static void m(Player player, Object... fields) {
+        ((ServerPlayer)player).sendSystemMessage(Messenger.c(fields));
+    }
+
+    /*
+    composes single line, multicomponent message, and returns as one chat messagge
+     */
+    public static Component c(Object... fields) {
+        MutableComponent message = Component.literal("");
+        MutableComponent previousComponent = null;
+        for (Object o : fields) {
+            if (o instanceof MutableComponent) {
+                message.append((MutableComponent) o);
+                previousComponent = (MutableComponent) o;
+                continue;
+            }
+            String txt = o.toString();
+            MutableComponent comp = getChatComponentFromDesc(txt, previousComponent);
+            if (comp != previousComponent) message.append(comp);
+            previousComponent = comp;
+        }
+        return message;
+    }
+
+    // simple text
+
+    public static Component s(String text) {
+        return s(text, "");
+    }
+
+    public static Component s(String text, String style) {
+        MutableComponent message = Component.literal(text);
+        message.setStyle(parseStyle(style));
+        return message;
+    }
+
+
+    public static void send(Player player, Collection<Component> lines) {
+        lines.forEach(message -> ((ServerPlayer)player).sendSystemMessage(message));
+    }
+
+    public static void send(CommandSourceStack source, Collection<Component> lines) {
+        lines.stream().forEachOrdered((s) -> source.sendSuccess(() -> s, false));
+    }
+
+
+    public static void print_server_message(MinecraftServer server, String message) {
+        if (server == null)
+            LOG.error("Message not delivered: " + message);
+        server.sendSystemMessage(Component.literal(message));
+        Component txt = c("gi " + message);
+        for (Player entityplayer : server.getPlayerList().getPlayers()) {
+            ((ServerPlayer)entityplayer).sendSystemMessage(txt);
+        }
+    }
+
+    public static void print_server_message(MinecraftServer server, Component message) {
+        if (server == null)
+            LOG.error("Message not delivered: " + message.getString());
+        server.sendSystemMessage(message);
+        for (Player entityplayer : server.getPlayerList().getPlayers()) {
+            ((ServerPlayer)entityplayer).sendSystemMessage(message);
+        }
+    }
+}
+
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/MobAI.java b/src/main/java/org/leavesmc/lumina/carpet/utils/MobAI.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ce683d3ee99fd2236b088a23e588999cf257d9b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/MobAI.java
@@ -0,0 +1,57 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+
+import java.util.Map;
+import java.util.Set;
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import org.jetbrains.annotations.NotNull;
+
+public class MobAI {
+    @SuppressWarnings("MapOrSetKeyShouldOverrideHashCodeEquals")
+    private static final Map<EntityType<?>, Set<TrackingType>> AI_TRACKERS = Maps.newConcurrentMap();
+
+    public static void resetTrackers() {
+        AI_TRACKERS.clear();
+    }
+
+    public static boolean isTracking(@NotNull Entity e, TrackingType type) {
+        if (e.getCommandSenderWorld().isClientSide())
+            return false;
+        Set<TrackingType> currentTrackers = AI_TRACKERS.get(e.getType());
+        if (currentTrackers == null)
+            return false;
+        return currentTrackers.contains(type);
+    }
+
+    public static void clearTracking(final @NotNull MinecraftServer server, EntityType<? extends Entity> etype) {
+        AI_TRACKERS.remove(etype);
+        for (ServerLevel world : server.getAllLevels()) {
+            for (Entity e : world.getEntities(etype, Entity::hasCustomName)) {
+                e.setCustomNameVisible(false);
+                e.setCustomName(null);
+            }
+        }
+    }
+
+    public static void startTracking(EntityType<?> e, TrackingType type) {
+        AI_TRACKERS.putIfAbsent(e, Sets.newHashSet());
+        AI_TRACKERS.get(e).add(type);
+    }
+
+    @SuppressWarnings("MapOrSetKeyShouldOverrideHashCodeEquals")
+    public enum TrackingType {
+        IRON_GOLEM_SPAWNING(Set.of(EntityType.VILLAGER)),
+        BREEDING(Set.of(EntityType.VILLAGER));
+        public final Set<EntityType<?>> types;
+
+        TrackingType(Set<EntityType<?>> applicableTypes) {
+            types = applicableTypes;
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/PerimeterDiagnostics.java b/src/main/java/org/leavesmc/lumina/carpet/utils/PerimeterDiagnostics.java
new file mode 100644
index 0000000000000000000000000000000000000000..ddeaf1538643e914ffec3c5c5ba93dbbe373bbc3
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/PerimeterDiagnostics.java
@@ -0,0 +1,156 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.world.entity.*;
+import net.minecraft.world.entity.ambient.AmbientCreature;
+import net.minecraft.world.entity.animal.WaterAnimal;
+import net.minecraft.world.entity.monster.Enemy;
+import net.minecraft.world.level.NaturalSpawner;
+import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+
+public class PerimeterDiagnostics {
+    public static class Result {
+        public int liquid;
+        public int ground;
+        public int specific;
+        public List<BlockPos> samples;
+
+        Result() {
+            samples = new ArrayList<>();
+        }
+    }
+
+    private MobSpawnSettings.SpawnerData sle;
+    private ServerLevel worldServer;
+    private MobCategory ctype;
+    private Mob el;
+
+    private PerimeterDiagnostics(ServerLevel server, MobCategory ctype, Mob el) {
+        this.sle = null;
+        this.worldServer = server;
+        this.ctype = ctype;
+        this.el = el;
+    }
+
+    public static Result countSpots(ServerLevel worldserver, BlockPos epos, Mob el) {
+        BlockPos pos;
+        // List<BlockPos> samples = new ArrayList<BlockPos>();
+        // if (el != null) CarpetSettings.LOG.error(String.format("Got %s to check",el.toString()));
+        int eY = epos.getY();
+        int eX = epos.getX();
+        int eZ = epos.getZ();
+        Result result = new Result();
+
+        // int ground_spawns = 0;
+        // int liquid_spawns = 0;
+        // int specific_spawns = 0;
+        boolean add_water = false;
+        boolean add_ground = false;
+        MobCategory ctype = null;
+
+        if (el != null) {
+            if (el instanceof WaterAnimal) {
+                add_water = true;
+                ctype = MobCategory.WATER_CREATURE;
+            } else if (el instanceof AgeableMob) {
+                add_ground = true;
+                ctype = MobCategory.CREATURE;
+            } else if (el instanceof Enemy) {
+                add_ground = true;
+                ctype = MobCategory.MONSTER;
+            } else if (el instanceof AmbientCreature) {
+                ctype = MobCategory.AMBIENT;
+            }
+        }
+        PerimeterDiagnostics diagnostic = new PerimeterDiagnostics(worldserver, ctype, el);
+        EntityType<?> type = EntityType.ZOMBIE;
+        if (el != null) type = el.getType();
+        int minY = worldserver.getMinY();
+        int maxY = worldserver.getMaxY();
+        for (int x = -128; x <= 128; ++x) {
+            for (int z = -128; z <= 128; ++z) {
+                if (x * x + z * z > 128 * 128) // cut out a cyllinder first
+                {
+                    continue;
+                }
+                for (int y = minY; y < maxY; ++y) {
+                    if ((Math.abs(y - eY) > 128)) {
+                        continue;
+                    }
+                    int distsq = (x) * (x) + (eY - y) * (eY - y) + (z) * (z);
+                    if (distsq > 128 * 128 || distsq < 24 * 24) {
+                        continue;
+                    }
+                    pos = new BlockPos(eX + x, y, eZ + z);
+
+                    BlockState iblockstate = worldserver.getBlockState(pos);
+                    BlockState iblockstate_down = worldserver.getBlockState(pos.below());
+                    BlockState iblockstate_up = worldserver.getBlockState(pos.above());
+
+                    if (iblockstate.getFluidState().is(FluidTags.WATER) && !iblockstate_up.isRedstoneConductor(worldserver, pos)) // isSimpleFUllBLock
+                    {
+                        result.liquid++;
+                        if (add_water && diagnostic.check_entity_spawn(pos)) {
+                            result.specific++;
+                            if (result.samples.size() < 10) {
+                                result.samples.add(pos);
+                            }
+                        }
+                    } else {
+                        if (iblockstate_down.isRedstoneConductor(worldserver, pos)) // isSimpleFUllBLock
+                        {
+                            Block block = iblockstate_down.getBlock();
+                            boolean flag = block != Blocks.BEDROCK && block != Blocks.BARRIER;
+                            if (flag && NaturalSpawner.isValidEmptySpawnBlock(worldserver, pos, iblockstate, iblockstate.getFluidState(), type) && NaturalSpawner.isValidEmptySpawnBlock(worldserver, pos.above(), iblockstate_up, iblockstate_up.getFluidState(), type)) {
+                                result.ground++;
+                                if (add_ground && diagnostic.check_entity_spawn(pos)) {
+                                    result.specific++;
+                                    if (result.samples.size() < 10) {
+                                        result.samples.add(pos);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // ashMap<String,Integer> result= new HashMap<>();
+        // result.put("Potential in-water spawning spaces", liquid_spawns);
+        // result.put("Potential on-ground spawning spaces", ground_spawns);
+        // if (el != null) result.put(String.format("%s spawning spaces",el.getDisplayName().getUnformattedText()),specific_spawns);
+        return result;
+    }
+
+
+    private boolean check_entity_spawn(BlockPos pos) {
+        if (sle == null || !worldServer.getChunkSource().getGenerator().getMobsAt(worldServer.getBiome(pos), worldServer.structureManager(), ctype, pos).unwrap().contains(sle)) {
+            sle = null;
+            for (MobSpawnSettings.SpawnerData sle : worldServer.getChunkSource().getGenerator().getMobsAt(worldServer.getBiome(pos), worldServer.structureManager(), ctype, pos).unwrap()) {
+                if (el.getType() == sle.type) {
+                    this.sle = sle;
+                    break;
+                }
+            }
+            if (sle == null || !worldServer.getChunkSource().getGenerator().getMobsAt(worldServer.getBiome(pos), worldServer.structureManager(), ctype, pos).unwrap().contains(sle)) {
+                return false;
+            }
+        }
+
+        if (SpawnPlacements.isSpawnPositionOk(sle.type, worldServer, pos)) {
+            el.moveTo(pos.getX() + 0.5F, pos.getY(), pos.getZ() + 0.5F, 0.0F, 0.0F);
+            return el.checkSpawnObstruction(worldServer) && el.checkSpawnRules(worldServer, EntitySpawnReason.NATURAL) &&
+                    SpawnPlacements.checkSpawnRules(el.getType(), (ServerLevel) el.getCommandSenderWorld(), EntitySpawnReason.NATURAL, el.blockPosition(), el.getCommandSenderWorld().random) &&
+                    worldServer.noCollision(el); // check collision rules once they stop fiddling with them after 1.14.1
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/RecipeHelper.java b/src/main/java/org/leavesmc/lumina/carpet/utils/RecipeHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..7fff9db7d097e5abf3e1c552652e7524683875ed
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/RecipeHelper.java
@@ -0,0 +1,61 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.context.ContextMap;
+import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeManager;
+import net.minecraft.world.item.crafting.RecipeType;
+import net.minecraft.world.item.crafting.display.RecipeDisplay;
+import net.minecraft.world.item.crafting.display.SlotDisplayContext;
+import net.minecraft.world.level.Level;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class RecipeHelper
+{
+    public static List<Recipe<?>> getRecipesForOutput(RecipeManager recipeManager, RecipeType<?> type, ResourceLocation id, Level level)
+    {
+        List<Recipe<?>> results = new ArrayList<>();
+
+
+        ContextMap context = SlotDisplayContext.fromLevel(level);
+        recipeManager.getRecipes().forEach(r -> {
+            if (r.value().getType() == type)
+            {
+                for (RecipeDisplay recipeDisplay : r.value().display())
+                {
+                    recipeDisplay.result().resolveForStacks(context).forEach(stack -> {
+                        if (BuiltInRegistries.ITEM.wrapAsHolder(stack.getItem()).unwrapKey().map(ResourceKey::location).orElseThrow(IllegalStateException::new).equals(id))
+                        {
+                            results.add(r.value());
+                        }
+                    });
+                }
+            }
+        });
+        return results;
+    }
+
+    public static List<Recipe<?>> getRecipesForOutput(RecipeManager recipeManager, ResourceLocation id, Level level)
+    {
+        List<Recipe<?>> results = new ArrayList<>();
+
+        ContextMap context = SlotDisplayContext.fromLevel(level);
+        recipeManager.getRecipes().forEach(r -> {
+            for (RecipeDisplay recipeDisplay : r.value().display())
+            {
+                recipeDisplay.result().resolveForStacks(context).forEach(stack -> {
+                    if (BuiltInRegistries.ITEM.wrapAsHolder(stack.getItem()).unwrapKey().map(ResourceKey::location).orElseThrow(IllegalStateException::new).equals(id))
+                    {
+                        results.add(r.value());
+                    }
+                });
+            }
+
+        });
+        return results;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnOverrides.java b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnOverrides.java
new file mode 100644
index 0000000000000000000000000000000000000000..54917a2efe2ef5b108c53eb72a0d3a686fa15bf3
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnOverrides.java
@@ -0,0 +1,99 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.random.WeightedRandomList;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
+import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
+import net.minecraft.world.level.levelgen.structure.Structure;
+import net.minecraft.world.level.levelgen.structure.StructureSpawnOverride;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.levelgen.structure.StructureType;
+import org.apache.commons.lang3.tuple.Pair;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.BooleanSupplier;
+
+public class SpawnOverrides {
+    final private static Map<Pair<MobCategory, ResourceKey<Structure>>, Pair<BooleanSupplier, StructureSpawnOverride>> carpetOverrides = new HashMap<>();
+
+    static {
+        addOverride(() -> CarpetConfig.configModule().huskSpawningInTemples, MobCategory.MONSTER, BuiltinStructures.DESERT_PYRAMID, StructureSpawnOverride.BoundingBoxType.STRUCTURE,
+                WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.HUSK, 1, 1, 1))
+        );
+        addOverride(() -> CarpetConfig.configModule().shulkerSpawningInEndCities, MobCategory.MONSTER, BuiltinStructures.END_CITY, StructureSpawnOverride.BoundingBoxType.PIECE,
+                WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.SHULKER, 10, 4, 4))
+        );
+        addOverride(() -> CarpetConfig.configModule().piglinsSpawningInBastions, MobCategory.MONSTER, BuiltinStructures.BASTION_REMNANT, StructureSpawnOverride.BoundingBoxType.PIECE,
+                WeightedRandomList.create(
+                        new MobSpawnSettings.SpawnerData(EntityType.PIGLIN_BRUTE, 5, 1, 2),
+                        new MobSpawnSettings.SpawnerData(EntityType.PIGLIN, 10, 2, 4),
+                        new MobSpawnSettings.SpawnerData(EntityType.HOGLIN, 2, 1, 2)
+                )
+        );
+
+    }
+
+    public static void addOverride(BooleanSupplier when, MobCategory cat, ResourceKey<Structure> poo,
+                                   StructureSpawnOverride.BoundingBoxType type, WeightedRandomList<MobSpawnSettings.SpawnerData> spawns) {
+        carpetOverrides.put(Pair.of(cat, poo), Pair.of(when, new StructureSpawnOverride(type, spawns)));
+    }
+
+    public static WeightedRandomList<MobSpawnSettings.SpawnerData> test(StructureManager structureFeatureManager, LongSet foo,
+                                                                        MobCategory cat, Structure confExisting, BlockPos where) {
+        ResourceLocation resource = structureFeatureManager.registryAccess().lookupOrThrow(Registries.STRUCTURE).getKey(confExisting);
+        ResourceKey<Structure> key = ResourceKey.create(Registries.STRUCTURE, resource);
+        final Pair<BooleanSupplier, StructureSpawnOverride> spawnData = carpetOverrides.get(Pair.of(cat, key));
+        if (spawnData == null || !spawnData.getKey().getAsBoolean()) return null;
+        StructureSpawnOverride override = spawnData.getRight();
+        if (override.boundingBox() == StructureSpawnOverride.BoundingBoxType.STRUCTURE) {
+            if (structureFeatureManager.getStructureAt(where, confExisting).isValid())
+                return override.spawns();
+        } else {
+            List<StructureStart> starts = new ArrayList<>(1);
+            structureFeatureManager.fillStartsForStructure(confExisting, foo, starts::add);
+            for (StructureStart start : starts) {
+                if (start != null && start.isValid() && structureFeatureManager.structureHasPieceAt(where, start)) {
+                    return override.spawns();
+                }
+            }
+        }
+        return null;
+    }
+
+    public static boolean isStructureAtPosition(ServerLevel level, ResourceKey<Structure> structureKey, BlockPos pos)
+    {
+        final Structure fortressFeature = level.registryAccess().lookupOrThrow(Registries.STRUCTURE).getValue(structureKey);
+        if (fortressFeature == null) {
+            return false;
+        }
+        return level.structureManager().getStructureAt(pos, fortressFeature).isValid();
+    }
+
+    public static List<StructureStart> startsForFeature(ServerLevel level, SectionPos sectionPos, StructureType<?> structure) {
+        Map<Structure, LongSet> allrefs = level.getChunk(sectionPos.x(), sectionPos.z(), ChunkStatus.STRUCTURE_REFERENCES).getAllReferences();
+        List<StructureStart> result = new ArrayList<>();
+        for (var entry: allrefs.entrySet())
+        {
+            Structure existing = entry.getKey();
+            if (existing.type() == structure)
+            {
+                level.structureManager().fillStartsForStructure(existing, entry.getValue(), result::add);
+            }
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnReporter.java b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnReporter.java
new file mode 100644
index 0000000000000000000000000000000000000000..171b4e2ddf4827b6332debdd508be6a40f4103af
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/SpawnReporter.java
@@ -0,0 +1,430 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2LongMap;
+import it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.*;
+import net.minecraft.world.entity.animal.Ocelot;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.NaturalSpawner;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.entity.EntityTypeTest;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure;
+import org.apache.commons.lang3.tuple.Pair;
+import org.jetbrains.annotations.Nullable;
+import org.leavesmc.lumina.carpet.CarpetServer;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+
+import static net.minecraft.world.entity.MobCategory.*;
+
+public class SpawnReporter {
+    private static final MobCategory[] CACHED_MOBCATEGORY_VALUES = MobCategory.values();
+    public static boolean mockSpawns = false;
+
+    public static final HashMap<ResourceKey<Level>, Integer> chunkCounts = new HashMap<>();
+
+    public static final HashMap<Pair<ResourceKey<Level>, MobCategory>, Object2LongOpenHashMap<EntityType<?>>> spawn_stats = new HashMap<>();
+    public static double mobcap_exponent = 0.0D;
+
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_attempts = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> overall_spawn_ticks = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_full = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_fail = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_succ = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_ticks_spawns = new Object2LongOpenHashMap<>();
+    public static final Object2LongOpenHashMap<Pair<ResourceKey<Level>, MobCategory>> spawn_cap_count = new Object2LongOpenHashMap<>();
+    public static final HashMap<Pair<ResourceKey<Level>, MobCategory>, EvictingQueue<Pair<EntityType<?>, BlockPos>>> spawned_mobs = new HashMap<>();
+    public static final HashMap<MobCategory, Integer> spawn_tries = new HashMap<>();
+
+    private static int spawnTrackingStartTime = 0;
+    private static BoundingBox trackedSpawningArea = null;
+    // in case game gets each thread for each world - these need to belong to workd.
+    public static Object2LongOpenHashMap<MobCategory> local_spawns = null; // per world
+    public static HashSet<MobCategory> first_chunk_marker = null;
+
+    public static void registerSpawn(Mob mob, MobCategory cat, BlockPos pos) {
+        if (trackedSpawningArea != null && !trackedSpawningArea.isInside(pos)) {
+            return;
+        }
+        Pair<ResourceKey<Level>, MobCategory> key = Pair.of(mob.level().dimension(), cat);
+        spawn_stats.get(key).addTo(mob.getType(), 1);
+        spawned_mobs.get(key).put(Pair.of(mob.getType(), pos));
+        if (!local_spawns.containsKey(cat)) {
+            CarpetServer.LOGGER.error("Rogue spawn detected for category " + cat.getName() + " for mob " + mob.getType().getDescription().getString() + ". If you see this message let carpet peeps know about it on github issues.");
+            local_spawns.put(cat, 0L);
+        }
+        local_spawns.addTo(cat, 1);
+    }
+
+    public static final int MAGIC_NUMBER = (int) Math.pow(17.0D, 2.0D);
+    /*public static double currentMagicNumber()
+    {
+        return MAGIC_NUMBER / (Math.pow(2.0,(SpawnReporter.mobcap_exponent/4)));
+    }*/
+
+    public static List<Component> printMobcapsForDimension(ServerLevel world, boolean multiline) {
+        ResourceKey<Level> dim = world.dimension();
+        String name = dim.location().getPath();
+        List<Component> lst = new ArrayList<>();
+        if (multiline)
+            lst.add(Messenger.s(String.format("Mobcaps for %s:", name)));
+        NaturalSpawner.SpawnState lastSpawner = world.getChunkSource().getLastSpawnState();
+        Object2IntMap<MobCategory> dimCounts = lastSpawner.getMobCategoryCounts();
+        int chunkcount = chunkCounts.getOrDefault(dim, -1);
+        if (dimCounts == null || chunkcount < 0) {
+            lst.add(Messenger.c("g   --UNAVAILABLE--"));
+            return lst;
+        }
+
+        List<String> shortCodes = new ArrayList<>();
+        for (MobCategory category : cachedMobCategories()) {
+            int cur = dimCounts.getOrDefault(category, -1);
+            int max = (int) (chunkcount * ((double) category.getMaxInstancesPerChunk() / MAGIC_NUMBER)); // from ServerChunkManager.CHUNKS_ELIGIBLE_FOR_SPAWNING
+            String color = Messenger.heatmap_color(cur, max);
+            String mobColor = Messenger.creatureTypeColor(category);
+            if (multiline) {
+                int rounds = spawn_tries.get(category);
+                lst.add(Messenger.c(String.format("w   %s: ", category.getName()),
+                        (cur < 0) ? "g -" : (color + " " + cur), "g  / ", mobColor + " " + max,
+                        (rounds == 1) ? "w " : String.format("gi  (%d rounds/tick)", spawn_tries.get(category))
+                ));
+            } else {
+                shortCodes.add(color + " " + ((cur < 0) ? "-" : cur));
+                shortCodes.add("g /");
+                shortCodes.add(mobColor + " " + max);
+                shortCodes.add("g ,");
+            }
+        }
+        if (!multiline) {
+            if (shortCodes.size() > 0) {
+                shortCodes.remove(shortCodes.size() - 1);
+                lst.add(Messenger.c(shortCodes.toArray(new Object[0])));
+            } else {
+                lst.add(Messenger.c("g   --UNAVAILABLE--"));
+            }
+
+        }
+        return lst;
+    }
+
+    public static List<Component> getRecentSpawns(Level world, MobCategory category) {
+        List<Component> lst = new ArrayList<>();
+        if (!trackingSpawns()) {
+            lst.add(Messenger.s("Spawn tracking not started"));
+            return lst;
+        }
+        String categoryName = category.getName();
+
+        lst.add(Messenger.s(String.format("Recent %s spawns:", categoryName)));
+        for (Pair<EntityType<?>, BlockPos> pair : spawned_mobs.get(Pair.of(world.dimension(), category)).keySet()) {
+            lst.add(Messenger.c(
+                    "w  - ",
+                    Messenger.tp("wb", pair.getRight()),
+                    String.format("w : %s", pair.getLeft().getDescription().getString())
+            ));
+        }
+
+        if (lst.size() == 1) {
+            lst.add(Messenger.s(" - Nothing spawned yet, sorry."));
+        }
+        return lst;
+
+    }
+
+    public static List<Component> handleWoolAction(BlockPos pos, ServerLevel worldIn) {
+        DyeColor under = WoolTool.getWoolColorAtPosition(worldIn, pos.below());
+        if (under == null) {
+            if (trackingSpawns()) {
+                return makeTrackingReport(worldIn);
+            } else {
+                return printMobcapsForDimension(worldIn, true);
+            }
+        }
+        MobCategory category = getCategoryFromWoolColor(under);
+        if (category != null) {
+            if (trackingSpawns()) {
+                return getRecentSpawns(worldIn, category);
+            } else {
+                return printEntitiesByType(category, worldIn, true);
+
+            }
+
+        }
+        if (trackingSpawns()) {
+            return makeTrackingReport(worldIn);
+        } else {
+            return printMobcapsForDimension(worldIn, true);
+        }
+
+    }
+
+    public static MobCategory getCategoryFromWoolColor(DyeColor color) {
+        return switch (color) {
+            case RED -> MONSTER;
+            case GREEN -> CREATURE;
+            case BLUE -> WATER_CREATURE;
+            case BROWN -> AMBIENT;
+            case CYAN -> WATER_AMBIENT;
+            default -> null;
+        };
+    }
+
+    public static List<Component> printEntitiesByType(MobCategory cat, ServerLevel worldIn, boolean all) {
+        List<Component> lst = new ArrayList<>();
+        lst.add(Messenger.s(String.format("Loaded entities for %s category:", cat)));
+        for (Entity entity : worldIn.getEntities(EntityTypeTest.forClass(Entity.class), (e) -> e.getType().getCategory() == cat)) {
+            boolean persistent = entity instanceof Mob mob && (mob.isPersistenceRequired() || mob.requiresCustomPersistence());
+            if (!all && persistent)
+                continue;
+
+            EntityType<?> type = entity.getType();
+            BlockPos pos = entity.blockPosition();
+            lst.add(Messenger.c(
+                    "w  - ",
+                    Messenger.tp(persistent ? "gb" : "wb", pos),
+                    String.format(persistent ? "g : %s" : "w : %s", type.getDescription().getString())
+            ));
+
+        }
+        if (lst.size() == 1) {
+            lst.add(Messenger.s(" - Empty."));
+        }
+        return lst;
+    }
+
+    public static void initializeMocking() {
+        mockSpawns = true;
+    }
+
+    public static void stopMocking() {
+        mockSpawns = false;
+    }
+
+    public static void resetSpawnStats(MinecraftServer server, boolean full) {
+        if (full) {
+            for (MobCategory category : cachedMobCategories())
+                spawn_tries.put(category, 1);
+        }
+        overall_spawn_ticks.clear();
+        spawn_attempts.clear();
+        spawn_ticks_full.clear();
+        spawn_ticks_fail.clear();
+        spawn_ticks_succ.clear();
+        spawn_ticks_spawns.clear();
+        spawn_cap_count.clear();
+
+        // can't fast-path to clear given different worlds could have different amount of worlds
+        for (MobCategory category : cachedMobCategories()) {
+            for (ResourceKey<Level> world : server.levelKeys()) {
+                Pair<ResourceKey<Level>, MobCategory> key = Pair.of(world, category);
+                spawn_stats.put(key, new Object2LongOpenHashMap<>());
+                spawned_mobs.put(key, new EvictingQueue<>());
+            }
+        }
+        spawnTrackingStartTime = 0;
+    }
+
+    public static MobCategory[] cachedMobCategories() {
+        return CACHED_MOBCATEGORY_VALUES;
+    }
+
+    public static boolean trackingSpawns() {
+        return spawnTrackingStartTime != 0L;
+    }
+
+    public static void startTracking(MinecraftServer server, BoundingBox trackedArea) {
+        resetSpawnStats(server, false);
+        spawnTrackingStartTime = server.getTickCount();
+        trackedSpawningArea = trackedArea;
+    }
+
+    public static void stopTracking(MinecraftServer server) {
+        resetSpawnStats(server, false);
+        SpawnReporter.spawnTrackingStartTime = 0;
+        trackedSpawningArea = null;
+    }
+
+    private static String getWorldCode(ResourceKey<Level> world) {
+        if (world == Level.OVERWORLD) return "";
+        return "(" + Character.toUpperCase(world.location().getPath().charAt("THE_".length())) + ")";
+    }
+
+    public static List<Component> makeTrackingReport(Level worldIn) {
+        List<Component> report = new ArrayList<>();
+        if (!trackingSpawns()) {
+            report.add(Messenger.c(
+                    "w Spawn tracking is disabled, type '",
+                    "wi /spawn tracking start", "/spawn tracking start",
+                    "w ' to enable"));
+            return report;
+        }
+        int duration = worldIn.getServer().getTickCount() - spawnTrackingStartTime;
+        report.add(Messenger.c("bw --------------------"));
+        String simulated = mockSpawns ? "[SIMULATED] " : "";
+        String location = (trackedSpawningArea != null) ? String.format("[in (%d, %d, %d)x(%d, %d, %d)]",
+                trackedSpawningArea.minX(), trackedSpawningArea.minY(), trackedSpawningArea.minZ(),
+                trackedSpawningArea.maxX(), trackedSpawningArea.maxY(), trackedSpawningArea.maxZ()) : "";
+        report.add(Messenger.s(String.format("%sSpawn statistics %s: for %.1f min", simulated, location, (duration / 72000.0) * 60)));
+
+        for (MobCategory category : cachedMobCategories()) {
+            for (ResourceKey<Level> dim : worldIn.getServer().levelKeys()) {
+                Pair<ResourceKey<Level>, MobCategory> key = Pair.of(dim, category);
+                if (spawn_ticks_spawns.getLong(key) > 0L) {
+                    double hours = overall_spawn_ticks.getLong(key) / 72000.0;
+                    long spawnAttemptsForCategory = spawn_attempts.getLong(key);
+                    report.add(Messenger.s(String.format(" > %s%s (%.1f min), %.1f m/t, %%{%.1fF %.1f- %.1f+}; %.2f s/att",
+                            category.getName().substring(0, 3), getWorldCode(dim),
+                            60 * hours,
+                            (1.0D * spawn_cap_count.getLong(key)) / spawnAttemptsForCategory,
+                            (100.0D * spawn_ticks_full.getLong(key)) / spawnAttemptsForCategory,
+                            (100.0D * spawn_ticks_fail.getLong(key)) / spawnAttemptsForCategory,
+                            (100.0D * spawn_ticks_succ.getLong(key)) / spawnAttemptsForCategory,
+                            (1.0D * spawn_ticks_spawns.getLong(key)) / (spawn_ticks_fail.getLong(key) + spawn_ticks_succ.getLong(key))
+                    )));
+                    for (Object2LongMap.Entry<EntityType<?>> entry : spawn_stats.get(key).object2LongEntrySet()) {
+                        report.add(Messenger.s(String.format("   - %s: %d spawns, %d per hour",
+                                entry.getKey().getDescription().getString(),
+                                entry.getLongValue(),
+                                (72000 * entry.getLongValue() / duration))));
+                    }
+                }
+            }
+        }
+        return report;
+    }
+
+    public static void killEntity(LivingEntity entity) {
+        if (entity.isPassenger()) {
+            entity.getVehicle().discard();
+        }
+        if (entity.isVehicle()) {
+            for (Entity e : entity.getPassengers()) {
+                e.discard();
+            }
+        }
+        if (entity instanceof Ocelot) {
+            for (Entity e : entity.getCommandSenderWorld().getEntities(entity, entity.getBoundingBox())) {
+                e.discard();
+            }
+        }
+        entity.discard();
+    }
+
+    // yeeted from NaturalSpawner - temporary access fix
+    private static List<MobSpawnSettings.SpawnerData> getSpawnEntries(ServerLevel serverLevel, StructureManager structureManager, ChunkGenerator chunkGenerator, MobCategory mobCategory, BlockPos blockPos, @Nullable Holder<Biome> holder) {
+        return NaturalSpawner.isInNetherFortressBounds(blockPos, serverLevel, mobCategory, structureManager) ? NetherFortressStructure.FORTRESS_ENEMIES.unwrap() : chunkGenerator.getMobsAt(holder != null ? holder : serverLevel.getBiome(blockPos), structureManager, mobCategory, blockPos).unwrap();
+    }
+
+    public static List<Component> report(BlockPos pos, ServerLevel worldIn) {
+        List<Component> rep = new ArrayList<>();
+        int x = pos.getX();
+        int y = pos.getY();
+        int z = pos.getZ();
+        ChunkAccess chunk = worldIn.getChunk(pos);
+        int lc = chunk.getHeight(Heightmap.Types.WORLD_SURFACE, x, z) + 1;
+        String relativeHeight = (y == lc) ? "right at it." : String.format("%d blocks %s it.", Mth.abs(y - lc), (y >= lc) ? "above" : "below");
+        rep.add(Messenger.s(String.format("Maximum spawn Y value for (%+d, %+d) is %d. You are " + relativeHeight, x, z, lc)));
+        rep.add(Messenger.s("Spawns:"));
+        for (MobCategory category : cachedMobCategories()) {
+            String categoryCode = String.valueOf(category).substring(0, 3);
+            List<MobSpawnSettings.SpawnerData> lst = getSpawnEntries(worldIn, worldIn.structureManager(), worldIn.getChunkSource().getGenerator(), category, pos, worldIn.getBiome(pos));
+            if (lst != null && !lst.isEmpty()) {
+                for (MobSpawnSettings.SpawnerData spawnEntry : lst) {
+                    if (SpawnPlacements.getPlacementType(spawnEntry.type) == null)
+                        continue; // vanilla bug
+                    boolean canSpawn = SpawnPlacements.isSpawnPositionOk(spawnEntry.type, worldIn, pos);
+                    int willSpawn = -1;
+                    boolean fits = false;
+
+                    Mob mob;
+                    try {
+                        mob = (Mob) spawnEntry.type.create(worldIn, EntitySpawnReason.NATURAL);
+                    } catch (Exception e) {
+                        CarpetServer.LOGGER.warn("Exception while creating mob for spawn reporter", e);
+                        return rep;
+                    }
+
+                    if (canSpawn) {
+                        willSpawn = 0;
+                        for (int attempt = 0; attempt < 50; ++attempt) {
+                            float f = x + 0.5F;
+                            float f1 = z + 0.5F;
+                            mob.moveTo(f, y, f1, worldIn.random.nextFloat() * 360.0F, 0.0F);
+                            fits = worldIn.noCollision(mob);
+                            EntityType<?> etype = mob.getType();
+
+                            for (int i = 0; i < 20; ++i) {
+                                if (
+                                        SpawnPlacements.checkSpawnRules(etype, worldIn, EntitySpawnReason.NATURAL, pos, worldIn.random) &&
+                                                SpawnPlacements.isSpawnPositionOk(etype, worldIn, pos) &&
+                                                mob.checkSpawnRules(worldIn, EntitySpawnReason.NATURAL)
+                                    // && mob.canSpawn(worldIn) // entity collisions // mostly - except ocelots
+                                ) {
+                                    if (etype == EntityType.OCELOT) {
+                                        BlockState blockState = worldIn.getBlockState(pos.below());
+                                        if ((pos.getY() < worldIn.getSeaLevel()) || !(blockState.is(Blocks.GRASS_BLOCK) || blockState.is(BlockTags.LEAVES))) {
+                                            continue;
+                                        }
+                                    }
+                                    willSpawn += 1;
+                                }
+                            }
+                            mob.finalizeSpawn(worldIn, worldIn.getCurrentDifficultyAt(mob.blockPosition()), EntitySpawnReason.NATURAL, null);
+                            // the code invokes onInitialSpawn after getCanSpawHere
+                            fits = fits && worldIn.noCollision(mob);
+
+                            killEntity(mob);
+
+                            try {
+                                mob = (Mob) spawnEntry.type.create(worldIn, EntitySpawnReason.NATURAL);
+                            } catch (Exception e) {
+                                CarpetServer.LOGGER.warn("Exception while creating mob for spawn reporter", e);
+                                return rep;
+                            }
+                        }
+                    }
+
+                    String mobTypeName = mob.getType().getDescription().getString();
+                    //String pack_size = Integer.toString(mob.getMaxSpawnClusterSize());//String.format("%d-%d", animal.minGroupCount, animal.maxGroupCount);
+                    int weight = spawnEntry.getWeight().asInt();
+                    if (canSpawn) {
+                        String color = (fits && willSpawn > 0) ? "e" : "gi";
+                        rep.add(Messenger.c(
+                                String.format("%s %s: %s (%d:%d-%d/%d), can: ", color, categoryCode, mobTypeName, weight, spawnEntry.minCount, spawnEntry.maxCount, mob.getMaxSpawnClusterSize()),
+                                "l YES",
+                                color + " , fit: ",
+                                (fits ? "l YES" : "r NO"),
+                                color + " , will: ",
+                                ((willSpawn > 0) ? "l " : "r ") + Math.round((double) willSpawn) / 10 + "%"
+                        ));
+                    } else {
+                        rep.add(Messenger.c(String.format("gi %s: %s (%d:%d-%d/%d), can: ", categoryCode, mobTypeName, weight, spawnEntry.minCount, spawnEntry.maxCount, mob.getMaxSpawnClusterSize()), "n NO"));
+                    }
+                    killEntity(mob);
+                }
+            }
+        }
+        return rep;
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/TranslationKeys.java b/src/main/java/org/leavesmc/lumina/carpet/utils/TranslationKeys.java
new file mode 100644
index 0000000000000000000000000000000000000000..284086d7deea77d43a6e3fa541e88f4a24cfdfe5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/TranslationKeys.java
@@ -0,0 +1,31 @@
+package org.leavesmc.lumina.carpet.utils;
+
+/**
+ * This is not public API!
+ */
+public final class TranslationKeys {
+    public static final String BASE_RULE_NAMESPACE = "%s.rule.";
+    public static final String BASE_RULE_PATTERN   = BASE_RULE_NAMESPACE + "%s."; // [settingsManager].rule.[name]
+    public static final String RULE_NAME_PATTERN   = BASE_RULE_PATTERN + "name";
+    public static final String RULE_DESC_PATTERN   = BASE_RULE_PATTERN + "desc";
+    public static final String RULE_EXTRA_PREFIX_PATTERN = BASE_RULE_PATTERN + "extra.";
+    public static final String CATEGORY_PATTERN    = "%s.category.%s"; //[settingsManager].category.[name]
+
+    // Settings command
+    private static final String SETTINGS_BASE           = "carpet.settings.command.";
+    public static final String BROWSE_CATEGORIES        = SETTINGS_BASE + "browse_categories";
+    public static final String VERSION                  = SETTINGS_BASE + "version";
+    public static final String LIST_ALL_CATEGORY        = SETTINGS_BASE + "list_all_category";
+    public static final String CURRENT_SETTINGS_HEADER  = SETTINGS_BASE + "current_settings_header";
+    public static final String SWITCH_TO                = SETTINGS_BASE + "switch_to";
+    public static final String UNKNOWN_RULE             = SETTINGS_BASE + "unknown_rule";
+    public static final String CURRENT_FROM_FILE_HEADER = SETTINGS_BASE + "current_from_file_header";
+    public static final String MOD_SETTINGS_MATCHING    = SETTINGS_BASE + "mod_settings_matching";
+    public static final String ALL_MOD_SETTINGS         = SETTINGS_BASE + "all_mod_settings";
+    public static final String TAGS                     = SETTINGS_BASE + "tags";
+    public static final String CHANGE_PERMANENTLY       = SETTINGS_BASE + "change_permanently";
+    public static final String CHANGE_PERMANENTLY_HOVER = SETTINGS_BASE + "change_permanently_tooltip";
+    public static final String DEFAULT_SET              = SETTINGS_BASE + "default_set";
+    public static final String DEFAULT_REMOVED          = SETTINGS_BASE + "default_removed";
+    public static final String CURRENT_VALUE            = SETTINGS_BASE + "current_value";
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/Translations.java b/src/main/java/org/leavesmc/lumina/carpet/utils/Translations.java
new file mode 100644
index 0000000000000000000000000000000000000000..af4b84fc175a0e75ede7cd4849cd5280acc2fb74
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/Translations.java
@@ -0,0 +1,119 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.CarpetServer;
+// import org.leavesmc.lumina.carpet.CarpetSettings; // TODO
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class Translations {
+    private static Map<String, String> translationMap = Collections.emptyMap();
+
+    public static String tr(String key) {
+        return translationMap.getOrDefault(key, key);
+    }
+
+    public static String trOrNull(String key) {
+        return translationMap.get(key);
+    }
+
+    public static String tr(String key, String str) {
+        return translationMap.getOrDefault(key, str);
+    }
+
+    public static boolean hasTranslations() {
+        return !translationMap.isEmpty();
+    }
+
+    public static boolean hasTranslation(String key) {
+        return translationMap.containsKey(key);
+    }
+
+    public static Map<String, String> getTranslationFromResourcePath(String path) {
+        InputStream langFile = Translations.class.getClassLoader().getResourceAsStream(path);
+        if (langFile == null) {
+            // we don't have that language
+            return Collections.emptyMap();
+        }
+        Gson gson = new GsonBuilder().setLenient().create();
+        return gson.fromJson(new InputStreamReader(langFile, StandardCharsets.UTF_8),
+                new TypeToken<Map<String, String>>() {
+                });
+    }
+
+    public static void updateLanguage() {
+        Map<String, String> translations = new HashMap<>();
+        translations.putAll(getTranslationFromResourcePath(String.format("assets/carpet/lang/%s.json", CarpetConfig.configModule().language)));
+
+        // for (CarpetExtension ext : CarpetServer.extensions)
+        // {
+        //     Map<String, String> extMappings = ext.canHasTranslations(CarpetSettings.language);
+        //     if (extMappings == null) continue; // would be nice to get rid of this, but too many extensions return null where they don't know they do
+        //     boolean warned = false;
+        //     for (var entry : extMappings.entrySet()) {
+        //         var key = entry.getKey();
+        //         // Migrate the old format
+        //         if (!key.startsWith("carpet.")) {
+        //             if (key.startsWith("rule.")) {
+        //                 // default to carpet's settings manager. Custom managers are really uncommon and the known ones don't provide translations anyway
+        //                 key = TranslationKeys.BASE_RULE_NAMESPACE.formatted("carpet") + key.substring(5);
+        //             } else if (key.startsWith("category.")) {
+        //                 key = TranslationKeys.CATEGORY_PATTERN.formatted("carpet", key.substring(9));
+        //             }
+        //             if (!warned && key != entry.getKey()) {
+        //                 CarpetSettings.LOG.warn("""
+        //                         Found outdated translation keys in extension '%s'!
+        //                         These won't be supported in a later Carpet version!
+        //                         Carpet will now try to map them to the correct keys in a best-effort basis""".formatted(ext.getClass().getName()));
+        //                 warned = true;
+        //             }
+        //         }
+        //         translations.putIfAbsent(key, entry.getValue());
+        //     }
+        // }
+        translations.keySet().removeIf(e -> {
+            if (e.startsWith("//")) {
+                CarpetServer.LOGGER.warn("""
+                        Found translation key starting with // while preparing translations!
+                        Doing this is deprecated and may cause issues in later versions! Consider settings GSON to "lenient" mode and
+                        using regular comments instead!
+                        Translation key is '%s'""".formatted(e));
+                return true;
+            } else
+                return false;
+        });
+        // Remove after deprecated settings api is removed
+        addFallbacksTo(translations);
+        translationMap = translations;
+    }
+
+    public static boolean isValidLanguage(String newValue) {
+        // will put some validations for availble languages at some point
+        return true;
+    }
+
+    // fallbacks for old rules that don't define rule descriptions or stuff in language files yet
+    // to be removed when old settings system is removed and translation refactor is finished
+
+    private static final Map<String, String> FALLBACKS = new HashMap<>();
+
+    /**
+     * @deprecated if you compile against this method I'll steal your kneecaps
+     */
+    @Deprecated(forRemoval = true)
+    public static void registerFallbackTranslation(String key, String description) {
+        FALLBACKS.put(key, description);
+    }
+
+    private static void addFallbacksTo(Map<String, String> translationMap) {
+        FALLBACKS.forEach(translationMap::putIfAbsent);
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/carpet/utils/WoolTool.java b/src/main/java/org/leavesmc/lumina/carpet/utils/WoolTool.java
new file mode 100644
index 0000000000000000000000000000000000000000..35bee3437502f9dcbefe3fa472c036367fce6bbe
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/carpet/utils/WoolTool.java
@@ -0,0 +1,120 @@
+package org.leavesmc.lumina.carpet.utils;
+
+import net.minecraft.server.level.ServerPlayer;
+import org.leavesmc.lumina.carpet.CarpetConfig;
+import org.leavesmc.lumina.carpet.helpers.HopperCounter;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.Vec3;
+
+import javax.annotation.Nullable;
+
+import static java.util.Map.entry;
+
+/**
+ * A series of utility functions and variables for dealing predominantly with hopper counters and determining which counter
+ * to add their items to, as well as helping dealing with carpet functionality.
+ */
+public class WoolTool {
+    /**
+     * A map from a wool {@link Block} to its {@link DyeColor} which is used in {@link WoolTool#getWoolColorAtPosition}
+     * to get the colour of wool at a position.
+     */
+    private static final Map<Block, DyeColor> WOOL_BLOCK_TO_DYE = Map.ofEntries(
+            entry(Blocks.WHITE_WOOL, DyeColor.WHITE),
+            entry(Blocks.ORANGE_WOOL, DyeColor.ORANGE),
+            entry(Blocks.MAGENTA_WOOL, DyeColor.MAGENTA),
+            entry(Blocks.LIGHT_BLUE_WOOL, DyeColor.LIGHT_BLUE),
+            entry(Blocks.YELLOW_WOOL, DyeColor.YELLOW),
+            entry(Blocks.LIME_WOOL, DyeColor.LIME),
+            entry(Blocks.PINK_WOOL, DyeColor.PINK),
+            entry(Blocks.GRAY_WOOL, DyeColor.GRAY),
+            entry(Blocks.LIGHT_GRAY_WOOL, DyeColor.LIGHT_GRAY),
+            entry(Blocks.CYAN_WOOL, DyeColor.CYAN),
+            entry(Blocks.PURPLE_WOOL, DyeColor.PURPLE),
+            entry(Blocks.BLUE_WOOL, DyeColor.BLUE),
+            entry(Blocks.BROWN_WOOL, DyeColor.BROWN),
+            entry(Blocks.GREEN_WOOL, DyeColor.GREEN),
+            entry(Blocks.RED_WOOL, DyeColor.RED),
+            entry(Blocks.BLACK_WOOL, DyeColor.BLACK)
+    );
+
+    /**
+     * The method which gets triggered when a player places a carpet, and decides what to do based on the carpet's colour:
+     * <ul>
+     *     <li>Red - Resets the counter of the colour of wool underneath the carpet (if there is no wool, then nothing happens)</li>
+     *     <li>Green - Prints the contents of the counter of the colour of wool underneath the carpet</li>
+     * </ul>
+     */
+    public static void carpetPlacedAction(DyeColor color, Player placer, BlockPos pos, ServerLevel worldIn) {
+        if (!CarpetConfig.configModule().carpets) {
+            return;
+        }
+        switch (color) {
+            case PINK:
+                if (!CarpetConfig.configModule().commandSpawn)
+                    Messenger.send(placer, SpawnReporter.report(pos, worldIn));
+
+                break;
+            case BLACK:
+                if (!CarpetConfig.configModule().commandSpawn)
+                    Messenger.send(placer, SpawnReporter.handleWoolAction(pos, worldIn));
+                break;
+            case BROWN:
+                if (!CarpetConfig.configModule().commandDistance) {
+                    CommandSourceStack source = ((ServerPlayer)placer).createCommandSourceStack();
+                    if (!DistanceCalculator.hasStartingPoint(source) || placer.isShiftKeyDown()) {
+                        DistanceCalculator.setStart(source, Vec3.atLowerCornerOf(pos)); // zero padded pos
+                    } else {
+                        DistanceCalculator.setEnd(source, Vec3.atLowerCornerOf(pos));
+                    }
+                }
+                break;
+            case GRAY:
+                if (!CarpetConfig.configModule().commandInfo)
+                    Messenger.send(placer, BlockInfo.blockInfo(pos.below(), worldIn));
+                break;
+            case GREEN:
+                if (CarpetConfig.configModule().hopperCounters) {
+                    DyeColor under = getWoolColorAtPosition(worldIn, pos.below());
+                    if (under == null) return;
+                    HopperCounter counter = HopperCounter.getCounter(under);
+                    Messenger.send(placer, counter.format(worldIn.getServer(), false, false));
+                }
+                break;
+            case RED:
+                if (CarpetConfig.configModule().hopperCounters) {
+                    DyeColor under = getWoolColorAtPosition(worldIn, pos.below());
+                    if (under == null) return;
+                    HopperCounter counter = HopperCounter.getCounter(under);
+                    counter.reset(placer.getServer());
+                    List<Component> res = new ArrayList<>();
+                    res.add(Messenger.s(String.format("%s counter reset", under.toString())));
+                    Messenger.send(placer, res);
+                }
+                break;
+        }
+    }
+
+    /**
+     * Gets the colour of wool at the position, for hoppers to be able to decide whether to add their items to the global counter.
+     */
+    @Nullable
+    public static DyeColor getWoolColorAtPosition(Level worldIn, BlockPos pos) {
+        BlockState state = worldIn.getBlockState(pos);
+        return WOOL_BLOCK_TO_DYE.get(state.getBlock());
+    }
+}
