From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MC_XiaoHei <xiaohei.xor7studio@foxmail.com>
Date: Thu, 11 Apr 2024 22:58:15 +0800
Subject: [PATCH] Lumina server config and command


diff --git a/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java b/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
index e3228efcb0d85c0c43cd4e52fe0b877414a5ebe5..bdc35ec969486f6f026f6fb9bb0b9c22b947c414 100644
--- a/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
+++ b/src/main/java/dev/jorel/commandapi/nms/NMS_1_20_R4.java
@@ -25,19 +25,12 @@ import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Predicate;
@@ -190,6 +183,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.ScoreHolder;
 import org.bukkit.loot.LootTable;
 import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.utils.ReflectTargetField;
 
 // Mojang-Mapped reflection
 
@@ -222,8 +216,10 @@ public class NMS_1_20_R4 extends NMS_Common {
         // entitySelectorUsesSelector = EntitySelector::usesSelector;
         Field usesSelector = null;
         for (Field field : EntitySelector.class.getFields()) {
-            if (field.getType().equals(boolean.class) && Modifier.isPublic(field.getModifiers())) {
-                usesSelector = CommandAPIHandler.getField(EntitySelector.class, field.getName(), "");
+            for (Annotation annotation : field.getAnnotations()) {
+                if (annotation instanceof ReflectTargetField) {
+                    usesSelector = CommandAPIHandler.getField(EntitySelector.class, field.getName(), "");
+                }
             }
         }
         entitySelectorUsesSelector = usesSelector;
diff --git a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
index 8302e4bedc03795c4cda526466fa4dc279b2dd21..17351285d16956d22eca0d5dce336699b485e42f 100644
--- a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -53,7 +53,8 @@ public class EntitySelector {
     @Nullable
     private final UUID entityUUID;
     private final EntityTypeTest<Entity, ?> type;
-    public final boolean usesSelector; // Lumina - Command API
+    @org.leavesmc.lumina.utils.ReflectTargetField // Lumina - Command API
+    private final boolean usesSelector;
 
     public EntitySelector(int count, boolean includesNonPlayers, boolean localWorldOnly, Predicate<Entity> basePredicate, MinMaxBounds.Doubles distance, Function<Vec3, Vec3> positionOffset, @Nullable AABB box, BiConsumer<Vec3, List<? extends Entity>> sorter, boolean senderOnly, @Nullable String playerName, @Nullable UUID uuid, @Nullable EntityType<?> type, boolean usesAt) {
         this.maxResults = count;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index f01863e33b7407c14e8bcd2a44e63bed01afe838..a37c35fd271ac815bd67a40ceaca95ff895ffd9e 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -222,6 +222,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.paperConfigurations.initializeGlobalConfiguration(this.registryAccess());
         this.paperConfigurations.initializeWorldDefaultsConfiguration(this.registryAccess());
         // Paper end - initialize global and world-defaults configuration
+        org.leavesmc.lumina.config.LuminaConfig.setup(); //Lumina - load config file
         // Paper start - fix converting txt to json file; convert old users earlier after PlayerList creation but before file load/save
         if (this.convertOldUsers()) {
             this.getProfileCache().save(false); // Paper
@@ -290,6 +291,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         );
         dev.jorel.commandapi.CommandAPI.onEnable();
         // Lumina end - enable CommandAPI
+        org.leavesmc.lumina.LuminaCommand.INSTANCE.registerCommands(); // Lumina - register commands
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // Spigot - moved up
         this.server.loadPlugins();
diff --git a/src/main/java/org/leavesmc/lumina/LuminaCommand.java b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3879e94473e6e8499a53d9c89fb6fab77ea818d3
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/LuminaCommand.java
@@ -0,0 +1,186 @@
+package org.leavesmc.lumina;
+
+import com.mojang.logging.LogUtils;
+import dev.jorel.commandapi.CommandAPICommand;
+import dev.jorel.commandapi.arguments.*;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.leavesmc.lumina.config.LuminaConfig;
+import org.slf4j.Logger;
+
+import java.util.Arrays;
+
+public class LuminaCommand {
+    private LuminaCommand() {
+    }
+
+    public static LuminaCommand INSTANCE = new LuminaCommand();
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public void registerCommands() {
+        registerLuminaCommand();
+    }
+
+    private void registerLuminaCommand() {
+        String[] configNodes = LuminaConfig.nodeInfos.keySet().toArray(new String[0]);
+        new CommandAPICommand("lumina")
+                .withSubcommand(new CommandAPICommand("config")
+                        .withSubcommand(new CommandAPICommand("set")
+                                .withPermission("lumina.config.set")
+                                .withArguments(new StringArgument("node")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes)))
+                                .withArguments(new GreedyStringArgument("value")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(info -> {
+                                            String node = (String) info.previousArgs().get("node");
+                                            LuminaConfig.ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                            if (node == null || nodeInfo == null) {
+                                                return new String[]{};
+                                            }
+                                            return nodeInfo.suggestions();
+                                        }))
+                                ).executes((sender, args) -> {
+                                    String node = (String) args.get("node");
+                                    LuminaConfig.ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                    if (node == null || nodeInfo == null) {
+                                        sendError(sender, "No config node specified.");
+                                        return;
+                                    }
+                                    String value = (String) args.get("value");
+                                    Class<?> type = nodeInfo.type();
+                                    Object parent = nodeInfo.parent();
+                                    if (value == null) {
+                                        sendError(sender, "No value specified, expected: " + type.getSimpleName());
+                                        return;
+                                    }
+                                    try {
+                                        boolean save = LuminaConfig.configModule.misc.saveConfigAfterSet;
+                                        if (type.isEnum()) {
+                                            @SuppressWarnings({"unchecked", "rawtypes"})
+                                            Class<? extends Enum> enumType = (Class<? extends Enum>) type;
+                                            try {
+                                                @SuppressWarnings("unchecked")
+                                                Object enumValue = Enum.valueOf(enumType, value);
+                                                nodeInfo.field().set(parent, enumValue);
+                                            } catch (IllegalArgumentException ignored) {
+                                                sendError(sender, "Expected enum " + Arrays.toString(nodeInfo.suggestions()) + ", but entered: " + value);
+                                            }
+                                        } else {
+                                            switch (type.getSimpleName()) {
+                                                case "boolean" -> {
+                                                    if ("true".equals(value)) {
+                                                        nodeInfo.field().setBoolean(parent, true);
+                                                    } else if ("false".equals(value)) {
+                                                        nodeInfo.field().setBoolean(parent, false);
+                                                    } else {
+                                                        sendError(sender, "Expected boolean, but entered: " + value);
+                                                    }
+                                                }
+                                                case "int" -> {
+                                                    try {
+                                                        nodeInfo.field().setInt(parent, Integer.parseInt(value));
+                                                    } catch (NumberFormatException ignored) {
+                                                        sendError(sender, "Expected int, but entered: " + value);
+                                                    }
+                                                }
+                                                case "long" -> {
+                                                    try {
+                                                        nodeInfo.field().setLong(parent, Long.parseLong(value));
+                                                    } catch (NumberFormatException ignored) {
+                                                        sendError(sender, "Expected long, but entered: " + value);
+                                                    }
+                                                }
+                                                case "double" -> {
+                                                    try {
+                                                        nodeInfo.field().setDouble(parent, Double.parseDouble(value));
+                                                    } catch (NumberFormatException ignored) {
+                                                        sendError(sender, "Expected double, but entered: " + value);
+                                                    }
+                                                }
+                                                case "String" -> nodeInfo.field().set(parent, value);
+                                                default -> throw new IllegalStateException("Please report this to Lumina developers: unexpected config field type " + type.getName());
+                                            }
+                                        }
+                                        sendSuccess(sender, "Already set " + node + " to " + value);
+                                        if (save) {
+                                            LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                                                LOGGER.info("Saved Lumina config after setting {} to {}", node, value);
+                                                return null;
+                                            });
+                                        }
+                                    } catch (IllegalAccessException e) {
+                                        throw new RuntimeException("Please report this to Lumina developers: " + e);
+                                    }
+                                })
+                        ).withSubcommand(new CommandAPICommand("get")
+                                .withPermission("lumina.config.get")
+                                .withArguments(new StringArgument("node")
+                                        .replaceSuggestions(ArgumentSuggestions.strings(configNodes)))
+                                .executes((sender, args) -> {
+                                    String node = (String) args.get("node");
+                                    LuminaConfig.ConfigNodeInfo nodeInfo = LuminaConfig.nodeInfos.getOrDefault(node, null);
+                                    if (node == null || nodeInfo == null) {
+                                        sendError(sender, "No config node specified.");
+                                        return;
+                                    }
+                                    try {
+                                        sendInfo(sender, "The value of " + node + " is " + nodeInfo.field().get(nodeInfo.parent()));
+                                    } catch (IllegalAccessException e) {
+                                        throw new RuntimeException("Please report this to Lumina developers: " + e);
+                                    }
+                                })
+                        ).withSubcommand(new CommandAPICommand("reload")
+                                .withPermission("lumina.config.reload")
+                                .executes((sender, args) -> {
+                                    sendSuccess(sender, "Reloading Lumina config...");
+                                    if (!(sender instanceof ConsoleCommandSender)) {
+                                        LOGGER.info("Reloading Lumina config...");
+                                    }
+                                    LuminaConfig.reloadAsync().thenApply((Void ignored) -> {
+                                        sendSuccess(sender, "Lumina config reloaded.");
+                                        if (!(sender instanceof ConsoleCommandSender)) {
+                                            LOGGER.info("Lumina config reloaded.");
+                                        }
+                                        return null;
+                                    });
+                                })
+                        ).withSubcommand(new CommandAPICommand("save"))
+                        .withPermission("lumina.config.set") // Cause `set` also called save, so use the same permission node
+                        .executes((sender, args) -> {
+                            sendSuccess(sender, "Saving Lumina config...");
+                            if (!(sender instanceof ConsoleCommandSender)) {
+                                LOGGER.info("Saving Lumina config...");
+                            }
+                            LuminaConfig.saveAsync().thenApply((Void ignored) -> {
+                                sendSuccess(sender, "Lumina config saved.");
+                                if (!(sender instanceof ConsoleCommandSender)) {
+                                    LOGGER.info("Lumina config saved.");
+                                }
+                                return null;
+                            });
+                        })
+                ).register();
+    }
+
+    private void sendError(@NotNull CommandSender sender, String message) {
+        sendMessage(sender, message, NamedTextColor.RED);
+    }
+
+    private void sendSuccess(@NotNull CommandSender sender, String message) {
+        sendMessage(sender, message, NamedTextColor.DARK_GREEN);
+    }
+
+    private void sendInfo(@NotNull CommandSender sender, String message) {
+        sendMessage(sender, message, NamedTextColor.WHITE);
+    }
+
+    private void sendMessage(@NotNull CommandSender sender, String message, TextColor color) {
+        sender.sendMessage(Component
+                .empty()
+                .color(color)
+                .append(Component.text(message)));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/ConfigModule.java b/src/main/java/org/leavesmc/lumina/config/ConfigModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..25e77db19cd365441216b82544fa0f4b59b5c04c
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/ConfigModule.java
@@ -0,0 +1,16 @@
+package org.leavesmc.lumina.config;
+
+import org.leavesmc.lumina.config.modules.Fix;
+import org.leavesmc.lumina.config.modules.Protocol;
+import org.leavesmc.lumina.config.modules.Misc;
+import org.leavesmc.lumina.config.modules.Performance;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class ConfigModule {
+    public String configVersion = "1";
+    public Fix fix = new Fix();
+    public Protocol protocol = new Protocol();
+    public Performance performance = new Performance();
+    public Misc misc = new Misc();
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a50bf4aae9cb4c20e160e0739aa1db40dd55f09
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/LuminaConfig.java
@@ -0,0 +1,122 @@
+package org.leavesmc.lumina.config;
+
+import io.papermc.paper.threadedregions.RegionizedServer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.hocon.HoconConfigurationLoader;
+
+import java.lang.reflect.Field;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+
+public class LuminaConfig {
+    private static final Set<Class<?>> CONFIG_FIELD_TYPES = new HashSet<>(Arrays.asList(
+            String.class,
+            boolean.class,
+            int.class,
+            long.class,
+            double.class));
+    public static ConfigModule configModule;
+    public static boolean alreadyInit = false;
+    private static final MinecraftInternalPlugin NULL_PLUGIN = new MinecraftInternalPlugin();
+    private static HoconConfigurationLoader loader;
+    private static CommentedConfigurationNode node;
+    public static Map<String, ConfigNodeInfo> nodeInfos = new HashMap<>();
+
+    public static void setup() {
+        if (alreadyInit) {
+            return;
+        }
+        loader = HoconConfigurationLoader.builder()
+                .emitComments(true)
+                .emitJsonCompatible(true)
+                .prettyPrinting(true)
+                .path(Paths.get("lumina.conf"))
+                .build();
+        try {
+            node = loader.load();
+            configModule = node.get(ConfigModule.class);
+            node.set(ConfigModule.class, configModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+        try {
+            generateNodeInfos(ConfigModule.class, null, LuminaConfig.configModule);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+        alreadyInit = true;
+    }
+
+    public static void reload() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        try {
+            configModule = loader.load().get(ConfigModule.class);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void save() {
+        RegionizedServer.ensureGlobalTickThread("Reload lumina config off global region thread!");
+        try {
+            node.set(ConfigModule.class, configModule);
+            loader.save(node);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> reloadAsync() {
+        return CompletableFuture.runAsync(LuminaConfig::reload, task -> Bukkit.getGlobalRegionScheduler().run(NULL_PLUGIN, scheduled -> task.run()));
+    }
+
+    @Contract(" -> new")
+    public static @NotNull CompletableFuture<Void> saveAsync() {
+        return CompletableFuture.runAsync(LuminaConfig::save, task -> Bukkit.getGlobalRegionScheduler().run(NULL_PLUGIN, scheduled -> task.run()));
+    }
+
+    private static @NotNull String toHyphen(String input) {
+        if (input == null || input.isEmpty()) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < input.length(); i++) {
+            char ch = input.charAt(i);
+            if (Character.isUpperCase(ch) && i > 0) {
+                sb.append('-');
+            }
+            sb.append(Character.toLowerCase(ch));
+        }
+        return sb.toString();
+    }
+
+    private static void generateNodeInfos(@NotNull Class<?> clazz, String parentKey, @NotNull Object parent) throws IllegalAccessException {
+        for (Field field : clazz.getFields()) {
+            String fieldName = field.getName();
+            Class<?> fieldType = field.getType();
+            String key = parentKey == null ? toHyphen(fieldName) : parentKey + "." + toHyphen(fieldName);
+            if ("boolean".equals(fieldType.getSimpleName())) {
+                nodeInfos.put(key, new ConfigNodeInfo(new String[]{"true", "false"}, fieldType, field, parent));
+            } else if (CONFIG_FIELD_TYPES.contains(fieldType)) {
+                nodeInfos.put(key, new ConfigNodeInfo(new String[]{field.get(parent).toString()}, fieldType, field, parent));
+            } else if (fieldType.isEnum()) {
+                nodeInfos.put(key, new ConfigNodeInfo((Arrays.stream(fieldType.getEnumConstants()).map(Object::toString).toArray(String[]::new)), fieldType, field, parent));
+            } else {
+                generateNodeInfos(fieldType, key, field.get(parent));
+            }
+        }
+    }
+
+    public record ConfigNodeInfo(String[] suggestions, Class<?> type, Field field, Object parent) {
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Fix.java b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
new file mode 100644
index 0000000000000000000000000000000000000000..405026bad89d1d5bf9272351c98502bb25d06ea2
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Fix.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.fix.FixFoliaEntityMovingFixConfig;
+import org.leavesmc.lumina.config.modules.fix.FixFoliaTeleportAsyncConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Fix {
+    public FixFoliaEntityMovingFixConfig fixFoliaEntityMoving = new FixFoliaEntityMovingFixConfig();
+    public FixFoliaTeleportAsyncConfig fixFoliaTeleportAsync = new FixFoliaTeleportAsyncConfig();
+    public boolean fixFoliaSpectorTeleport = true;
+    public boolean fixFoliaPoiAccessOffRegion = true;
+    public boolean mc2025 = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Misc.java b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6f41a391d597655d799249a17445dda22c83f03
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Misc.java
@@ -0,0 +1,20 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.misc.RegionFormatConfig;
+import org.leavesmc.lumina.config.modules.misc.WatchdogConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Misc {
+    public boolean mojangChatSign = true;
+    public boolean allowInorderChat = true;
+    public boolean offlineModeWarning = true;
+    public String serverModName = "Lumina";
+    public boolean fakeVanilla = false;
+    public boolean checkUsername = true;
+    public boolean alternativeKeepAlive = true;
+    public boolean saveConfigAfterSet = true;
+    public boolean verifyPublicKeyOnlyInOnlineMode = false;
+    public WatchdogConfig watchdog = new WatchdogConfig();
+    public RegionFormatConfig regionFormat = new RegionFormatConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Performance.java b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
new file mode 100644
index 0000000000000000000000000000000000000000..4739bdb828be18d9bec7ae2d6c6b332de879acee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Performance.java
@@ -0,0 +1,14 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.performance.*;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Performance {
+    public PetalReduceSensorWorkConfig petalReduceSensorWork = new PetalReduceSensorWorkConfig();
+    public ProjectileChunkReduceConfig projectileChunkReduce = new ProjectileChunkReduceConfig();
+    public DynamicEntityActivationRangeConfig dynamicEntityActivationRange = new DynamicEntityActivationRangeConfig();
+    public boolean entityGoalSelectorInactiveTick = false;
+    public boolean allowLoadChunksToActiveClimbingEntities = false;
+    public boolean optimizeSuffocation = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..76d518c8300c9db013822766618aa560f988b5d7
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/Protocol.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules;
+
+import org.leavesmc.lumina.config.modules.gameplay.LeavesBladerenProtocolConfig;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class Protocol {
+    public boolean carpetProtocol = false;
+    public LeavesBladerenProtocolConfig leavesBladerenProtocol = new LeavesBladerenProtocolConfig();
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abda15610a48676d145ef26bae7a7340b88b0ee
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaEntityMovingFixConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaEntityMovingFixConfig {
+    public boolean enabled = false;
+    public boolean warnOnDetected = true;
+}
\ No newline at end of file
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..b043bf36de0604028cb7bdd166d000d2dec76360
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/fix/FixFoliaTeleportAsyncConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.fix;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class FixFoliaTeleportAsyncConfig {
+    public boolean enabled = false;
+    public boolean throwOnDetected = true;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/gameplay/LeavesBladerenProtocolConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/gameplay/LeavesBladerenProtocolConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..94f61ca5e003d221415665a921988028e27b8fef
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/gameplay/LeavesBladerenProtocolConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.gameplay;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LeavesBladerenProtocolConfig {
+    public boolean enableBaseProtocol = false;
+    public boolean msptSyncProtocol = false;
+    public int msptSyncTickInterval = 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..35aed045ceb1f7647de4b0efbf7c609f62c402d8
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/RegionFormatConfig.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.stupidcraft.linearpaper.region.EnumRegionFileExtension;
+
+@ConfigSerializable
+public class RegionFormatConfig {
+    public EnumRegionFileExtension format = EnumRegionFileExtension.MCA;
+    public int linearCompressionLevel = 1;
+    public int linearFlushFrequency = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e79b3e1dfa56896c20e3b7e9c9d0cc37257af05
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/misc/WatchdogConfig.java
@@ -0,0 +1,10 @@
+package org.leavesmc.lumina.config.modules.misc;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class WatchdogConfig {
+    public boolean enabled = false;
+    public long warnPeriodTicks = 5 * 20;
+    public long timeOutTicks = 30 * 20;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/AsyncPathProcessingConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/AsyncPathProcessingConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8ae86452224380adce81229ed57757d6d4fa0ef
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/AsyncPathProcessingConfig.java
@@ -0,0 +1,24 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+
+@ConfigSerializable
+public class AsyncPathProcessingConfig {
+    public boolean enabled = false;
+    public int maxThreadNumber = 0;
+    public int keepalive = 60;
+
+    @PostProcess
+    public void onLoaded() {
+        if (!enabled) {
+            maxThreadNumber = 0;
+            return;
+        }
+        if (maxThreadNumber < 0) {
+            maxThreadNumber = Math.max(Runtime.getRuntime().availableProcessors() + maxThreadNumber, 1);
+        } else if (maxThreadNumber == 0) {
+            maxThreadNumber = Math.max(Runtime.getRuntime().availableProcessors() / 4, 1);
+        }
+    }
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..194817dc72555bfbb78e191d0c0f393e3dfe2bb5
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/DynamicEntityActivationRangeConfig.java
@@ -0,0 +1,12 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+
+@ConfigSerializable
+public class DynamicEntityActivationRangeConfig {
+    public boolean enabled = true;
+    public int startDistanceSquared = 144;
+    public int maximumActivationPriority = 20;
+    public int activationDistanceMod = 8;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..db160578fa0d35a275f953e88f04340c20d08942
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/LoadChunksToActiveClimbingEntitiesConfig.java
@@ -0,0 +1,8 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class LoadChunksToActiveClimbingEntitiesConfig {
+    public boolean allow = false;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..eed3fe3a9a7d5aa6eeeb3c2c3a40d73eafdd3f3f
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/PetalReduceSensorWorkConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class PetalReduceSensorWorkConfig {
+    public boolean enabled = true;
+    public int delayTicks = 10;
+}
diff --git a/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb64dd4c224c9246fa8d999c8217096f7bebe89b
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/config/modules/performance/ProjectileChunkReduceConfig.java
@@ -0,0 +1,9 @@
+package org.leavesmc.lumina.config.modules.performance;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+@ConfigSerializable
+public class ProjectileChunkReduceConfig {
+    public int maxProjectileLoadsPerTick;
+    public int maxProjectileLoadsPerProjectile;
+}
diff --git a/src/main/java/org/leavesmc/lumina/utils/ReflectTargetField.java b/src/main/java/org/leavesmc/lumina/utils/ReflectTargetField.java
new file mode 100644
index 0000000000000000000000000000000000000000..4deb7ca3c09a03faf0ddf2b49d0a0581a9682c75
--- /dev/null
+++ b/src/main/java/org/leavesmc/lumina/utils/ReflectTargetField.java
@@ -0,0 +1,11 @@
+package org.leavesmc.lumina.utils;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface ReflectTargetField {
+}
